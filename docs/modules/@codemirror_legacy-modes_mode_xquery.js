async function moduleInitFunction(require,exports={}){function chain(stream,state,f){return state.tokenize=f,f(stream,state)}// the primary mode tokenizer
function tokenBase(stream,state){var ch=stream.next(),mightBeFunction=!1,isEQName=isEQNameAhead(stream);// an XML tag (if not in some sub, chained tokenizer)
if("<"==ch){if(stream.match("!--",!0))return chain(stream,state,tokenXMLComment);if(stream.match("![CDATA",!1))return state.tokenize=tokenCDATA,"tag";if(stream.match("?",!1))return chain(stream,state,tokenPreProcessing);var isclose=stream.eat("/");stream.eatSpace();for(var c,tagName="";c=stream.eat(/[^\s\u00a0=<>\"\'\/?]/);)tagName+=c;return chain(stream,state,tokenTag(tagName,isclose))}// start code block
if("{"==ch)return pushStateStack(state,{type:"codeblock"}),null;// end code block
if("}"==ch)return popStateStack(state),null;// if we're in an XML block
if(isInXmlBlock(state))return">"==ch?"tag":"/"==ch&&stream.eat(">")?(popStateStack(state),"tag"):"variable";// if a number
if(/\d/.test(ch))return stream.match(/^\d*(?:\.\d*)?(?:E[+\-]?\d+)?/),"atom";// comment start
if("("===ch&&stream.eat(":"))return pushStateStack(state,{type:"comment"}),chain(stream,state,tokenComment);// quoted string
if(!isEQName&&("\""===ch||"'"===ch))return chain(stream,state,tokenString(ch));// variable
if("$"===ch)return chain(stream,state,tokenVariable);// assignment
if(":"===ch&&stream.eat("="))return"keyword";// open paren
if("("===ch)return pushStateStack(state,{type:"paren"}),null;// close paren
if(")"===ch)return popStateStack(state),null;// open paren
if("["===ch)return pushStateStack(state,{type:"bracket"}),null;// close paren
if("]"===ch)return popStateStack(state),null;var known=keywords.propertyIsEnumerable(ch)&&keywords[ch];// if there's a EQName ahead, consume the rest of the string portion, it's likely a function
if(isEQName&&"\""===ch)for(;"\""!==stream.next(););if(isEQName&&"'"===ch)for(;"'"!==stream.next(););// gobble up a word if the character is not known
known||stream.eatWhile(/[\w\$_-]/);// gobble a colon in the case that is a lib func type call fn:doc
var foundColon=stream.eat(":");// if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier
// which should get matched as a keyword
!stream.eat(":")&&foundColon&&stream.eatWhile(/[\w\$_-]/),stream.match(/^[ \t]*\(/,!1)&&(mightBeFunction=!0);// is the word a keyword?
var word=stream.current();// if the previous word was element, attribute, axis specifier, this word should be the name of that
return(known=keywords.propertyIsEnumerable(word)&&keywords[word],mightBeFunction&&!known&&(known={type:"function_call",style:"def"}),isInXmlConstructor(state))?(popStateStack(state),"variable"):(("element"==word||"attribute"==word||"axis_specifier"==known.type)&&pushStateStack(state,{type:"xmlconstructor"}),known?known.style:"variable");// as previously checked, if the word is element,attribute, axis specifier, call it an "xmlconstructor" and
// push the stack so we know to look for it on the next word
}// handle comments, including nested
function tokenComment(stream,state){for(var ch,maybeEnd=!1,maybeNested=!1,nestedCount=0;ch=stream.next();){if(!(")"==ch&&maybeEnd))":"==ch&&maybeNested&&nestedCount++;else if(0<nestedCount)nestedCount--;else{popStateStack(state);break}maybeEnd=":"==ch,maybeNested="("==ch}return"comment"}// tokenizer for string literals
// optionally pass a tokenizer function to set state.tokenize back to when finished
function tokenString(quote,f){return function(stream,state){var ch;if(isInString(state)&&stream.current()==quote)return popStateStack(state),f&&(state.tokenize=f),"string";// if we're in a string and in an XML block, allow an embedded code block
if(pushStateStack(state,{type:"string",name:quote,tokenize:tokenString(quote,f)}),stream.match("{",!1)&&isInXmlAttributeBlock(state))return state.tokenize=tokenBase,"string";for(;ch=stream.next();)if(ch==quote){popStateStack(state),f&&(state.tokenize=f);break}else// if we're in a string and in an XML block, allow an embedded code block in an attribute
if(stream.match("{",!1)&&isInXmlAttributeBlock(state))return state.tokenize=tokenBase,"string";return"string"}}// tokenizer for variables
function tokenVariable(stream,state){var isVariableChar=/[\w\$_-]/;// a variable may start with a quoted EQName so if the next character is quote, consume to the next quote
if(stream.eat("\"")){for(;"\""!==stream.next(););stream.eat(":")}else stream.eatWhile(isVariableChar),stream.match(":=",!1)||stream.eat(":");return stream.eatWhile(isVariableChar),state.tokenize=tokenBase,"variable"}// tokenizer for XML tags
function tokenTag(name,isclose){return function(stream,state){return(stream.eatSpace(),isclose&&stream.eat(">"))?(popStateStack(state),state.tokenize=tokenBase,"tag"):(stream.eat("/")||pushStateStack(state,{type:"tag",name:name,tokenize:tokenBase}),!stream.eat(">"))?(state.tokenize=tokenAttribute,"tag"):(state.tokenize=tokenBase,"tag");// self closing tag without attributes?
}}// tokenizer for XML attributes
function tokenAttribute(stream,state){var ch=stream.next();return"/"==ch&&stream.eat(">")?(isInXmlAttributeBlock(state)&&popStateStack(state),isInXmlBlock(state)&&popStateStack(state),"tag"):">"==ch?(isInXmlAttributeBlock(state)&&popStateStack(state),"tag"):"="==ch?null:"\""==ch||"'"==ch?chain(stream,state,tokenString(ch,tokenAttribute)):(isInXmlAttributeBlock(state)||pushStateStack(state,{type:"attribute",tokenize:tokenAttribute}),stream.eat(/[a-zA-Z_:]/),stream.eatWhile(/[-a-zA-Z0-9_:.]/),stream.eatSpace(),(stream.match(">",!1)||stream.match("/",!1))&&(popStateStack(state),state.tokenize=tokenBase),"attribute");// quoted string
}// handle comments, including nested
function tokenXMLComment(stream,state){for(var ch;ch=stream.next();)if("-"==ch&&stream.match("->",!0))return state.tokenize=tokenBase,"comment"}// handle CDATA
function tokenCDATA(stream,state){for(var ch;ch=stream.next();)if("]"==ch&&stream.match("]",!0))return state.tokenize=tokenBase,"comment"}// handle preprocessing instructions
function tokenPreProcessing(stream,state){for(var ch;ch=stream.next();)if("?"==ch&&stream.match(">",!0))return state.tokenize=tokenBase,"processingInstruction"}// functions to test the current context of the state
function isInXmlBlock(state){return isIn(state,"tag")}function isInXmlAttributeBlock(state){return isIn(state,"attribute")}function isInXmlConstructor(state){return isIn(state,"xmlconstructor")}function isInString(state){return isIn(state,"string")}function isEQNameAhead(stream){// assume we've already eaten a quote (")
return"\""===stream.current()?stream.match(/^[^\"]+\"\:/,!1):"'"===stream.current()&&stream.match(/^[^\"]+\'\:/,!1)}function isIn(state,type){return state.stack.length&&state.stack[state.stack.length-1].type==type}function pushStateStack(state,newState){state.stack.push(newState)}function popStateStack(state){state.stack.pop();var reinstateTokenize=state.stack.length&&state.stack[state.stack.length-1].tokenize;state.tokenize=reinstateTokenize||tokenBase}// the interface for the mode API
Object.defineProperty(exports,"__esModule",{value:!0});// The keywords object is set to the result of this self executing
// function. Each keyword is a property of the keywords object whose
// value is {type: atype, style: astyle}
var keywords=function(){// convenience functions used to build keywords object
function kw(type){return{type:type,style:"keyword"}}for(var operator=kw("operator"),atom={type:"atom",style:"atom"},punctuation={type:"punctuation",style:null},qualifier={type:"axis_specifier",style:"qualifier"},kwObj={",":punctuation},basic=["after","all","allowing","ancestor","ancestor-or-self","any","array","as","ascending","at","attribute","base-uri","before","boundary-space","by","case","cast","castable","catch","child","collation","comment","construction","contains","content","context","copy","copy-namespaces","count","decimal-format","declare","default","delete","descendant","descendant-or-self","descending","diacritics","different","distance","document","document-node","element","else","empty","empty-sequence","encoding","end","entire","every","exactly","except","external","first","following","following-sibling","for","from","ftand","ftnot","ft-option","ftor","function","fuzzy","greatest","group","if","import","in","inherit","insensitive","insert","instance","intersect","into","invoke","is","item","language","last","lax","least","let","levels","lowercase","map","modify","module","most","namespace","next","no","node","nodes","no-inherit","no-preserve","not","occurs","of","only","option","order","ordered","ordering","paragraph","paragraphs","parent","phrase","preceding","preceding-sibling","preserve","previous","processing-instruction","relationship","rename","replace","return","revalidation","same","satisfies","schema","schema-attribute","schema-element","score","self","sensitive","sentence","sentences","sequence","skip","sliding","some","stable","start","stemming","stop","strict","strip","switch","text","then","thesaurus","times","to","transform","treat","try","tumbling","type","typeswitch","union","unordered","update","updating","uppercase","using","validate","value","variable","version","weight","when","where","wildcards","window","with","without","word","words","xquery"],i=0,l=basic.length;i<l;i++)kwObj[basic[i]]=kw(basic[i]);// a list of types. For each add a property to kwObj with the value of
// {type: "atom", style: "atom"}
for(var types=["xs:anyAtomicType","xs:anySimpleType","xs:anyType","xs:anyURI","xs:base64Binary","xs:boolean","xs:byte","xs:date","xs:dateTime","xs:dateTimeStamp","xs:dayTimeDuration","xs:decimal","xs:double","xs:duration","xs:ENTITIES","xs:ENTITY","xs:float","xs:gDay","xs:gMonth","xs:gMonthDay","xs:gYear","xs:gYearMonth","xs:hexBinary","xs:ID","xs:IDREF","xs:IDREFS","xs:int","xs:integer","xs:item","xs:java","xs:language","xs:long","xs:Name","xs:NCName","xs:negativeInteger","xs:NMTOKEN","xs:NMTOKENS","xs:nonNegativeInteger","xs:nonPositiveInteger","xs:normalizedString","xs:NOTATION","xs:numeric","xs:positiveInteger","xs:precisionDecimal","xs:QName","xs:short","xs:string","xs:time","xs:token","xs:unsignedByte","xs:unsignedInt","xs:unsignedLong","xs:unsignedShort","xs:untyped","xs:untypedAtomic","xs:yearMonthDuration"],i=0,l=types.length;i<l;i++)kwObj[types[i]]=atom;// each operator will add a property to kwObj with value of {type: "operator", style: "keyword"}
for(var operators=["eq","ne","lt","le","gt","ge",":=","=",">",">=","<","<=",".","|","?","and","or","div","idiv","mod","*","/","+","-"],i=0,l=operators.length;i<l;i++)kwObj[operators[i]]=operator;// each axis_specifiers will add a property to kwObj with value of {type: "axis_specifier", style: "qualifier"}
for(var axis_specifiers=["self::","attribute::","child::","descendant::","descendant-or-self::","parent::","ancestor::","ancestor-or-self::","following::","preceding::","following-sibling::","preceding-sibling::"],i=0,l=axis_specifiers.length;i<l;i++)kwObj[axis_specifiers[i]]=qualifier;return kwObj}();return exports.xQuery={startState:function(){return{tokenize:tokenBase,cc:[],stack:[]}},token:function(stream,state){if(stream.eatSpace())return null;var style=state.tokenize(stream,state);return style},languageData:{commentTokens:{block:{open:"(:",close:":)"}}}},exports}