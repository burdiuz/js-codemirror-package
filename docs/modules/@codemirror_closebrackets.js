async function moduleInitFunction(require,exports={}){/// Extension to enable bracket-closing behavior. When a closeable
/// bracket is typed, its closing bracket is immediately inserted
/// after the cursor. When closing a bracket directly in front of a
/// closing bracket inserted by the extension, the cursor moves over
/// that bracket.
function closing(ch){for(let i=0;i<definedClosing.length;i+=2)if(definedClosing.charCodeAt(i)==ch)return definedClosing.charAt(i+1);return text.fromCodePoint(128>ch?ch:ch+1)}function config(state,pos){return state.languageDataAt("closeBrackets",pos)[0]||defaults}/// Implements the extension's behavior on text insertion. If the
/// given string counts as a bracket in the language around the
/// selection, and replacing the selection with it requires custom
/// behavior (inserting a closing version or skipping past a
/// previously-closed bracket), this function returns a transaction
/// representing that custom behavior. (You only need this if you want
/// to programmatically insert bracketsâ€”the
/// [`closeBrackets`](#closebrackets.closeBrackets) extension will
/// take care of running this for user input.)
function insertBracket(state,bracket){let conf=config(state,state.selection.main.head),tokens=conf.brackets||defaults.brackets;for(let tok of tokens){let closed=closing(text.codePointAt(tok,0));if(bracket==tok)return closed==tok?handleSame(state,tok,-1<tokens.indexOf(tok+tok+tok)):handleOpen(state,tok,closed,conf.before||defaults.before);if(bracket==closed&&closedBracketAt(state,state.selection.main.from))return handleClose(state,tok,closed)}return null}function closedBracketAt(state,pos){let found=!1;return state.field(bracketState).between(0,state.doc.length,from=>{from==pos&&(found=!0)}),found}function nextChar(doc,pos){let next=doc.sliceString(pos,pos+2);return next.slice(0,text.codePointSize(text.codePointAt(next,0)))}function prevChar(doc,pos){let prev=doc.sliceString(pos-2,pos);return text.codePointSize(text.codePointAt(prev,0))==prev.length?prev:prev.slice(1)}function handleOpen(state$1,open,close,closeBefore){let dont=null,changes=state$1.changeByRange(range=>{if(!range.empty)return{changes:[{insert:open,from:range.from},{insert:close,from:range.to}],effects:closeBracketEffect.of(range.to+open.length),range:state.EditorSelection.range(range.anchor+open.length,range.head+open.length)};let next=nextChar(state$1.doc,range.head);return!next||/\s/.test(next)||-1<closeBefore.indexOf(next)?{changes:{insert:open+close,from:range.head},effects:closeBracketEffect.of(range.head+open.length),range:state.EditorSelection.cursor(range.head+open.length)}:{range:dont=range}});return dont?null:state$1.update(changes,{scrollIntoView:!0,userEvent:"input.type"})}function handleClose(state$1,_open,close){let dont=null,moved=state$1.selection.ranges.map(range=>range.empty&&nextChar(state$1.doc,range.head)==close?state.EditorSelection.cursor(range.head+close.length):dont=range);return dont?null:state$1.update({selection:state.EditorSelection.create(moved,state$1.selection.mainIndex),scrollIntoView:!0,effects:state$1.selection.ranges.map(({from})=>skipBracketEffect.of(from))})}// Handles cases where the open and close token are the same, and
// possibly triple quotes (as in `"""abc"""`-style quoting).
function handleSame(state$1,token,allowTriple){let dont=null,changes=state$1.changeByRange(range=>{if(!range.empty)return{changes:[{insert:token,from:range.from},{insert:token,from:range.to}],effects:closeBracketEffect.of(range.to+token.length),range:state.EditorSelection.range(range.anchor+token.length,range.head+token.length)};let pos=range.head,next=nextChar(state$1.doc,pos);if(next==token){if(nodeStart(state$1,pos))return{changes:{insert:token+token,from:pos},effects:closeBracketEffect.of(pos+token.length),range:state.EditorSelection.cursor(pos+token.length)};if(closedBracketAt(state$1,pos)){let isTriple=allowTriple&&state$1.sliceDoc(pos,pos+3*token.length)==token+token+token;return{range:state.EditorSelection.cursor(pos+token.length*(isTriple?3:1)),effects:skipBracketEffect.of(pos)}}}else{if(allowTriple&&state$1.sliceDoc(pos-2*token.length,pos)==token+token&&nodeStart(state$1,pos-2*token.length))return{changes:{insert:token+token+token+token,from:pos},effects:closeBracketEffect.of(pos+token.length),range:state.EditorSelection.cursor(pos+token.length)};if(state$1.charCategorizer(pos)(next)!=state.CharCategory.Word){let prev=state$1.sliceDoc(pos-1,pos);if(prev!=token&&state$1.charCategorizer(pos)(prev)!=state.CharCategory.Word&&!probablyInString(state$1,pos,token))return{changes:{insert:token+token,from:pos},effects:closeBracketEffect.of(pos+token.length),range:state.EditorSelection.cursor(pos+token.length)}}}return{range:dont=range}});return dont?null:state$1.update(changes,{scrollIntoView:!0,userEvent:"input.type"})}function nodeStart(state,pos){let tree=language.syntaxTree(state).resolveInner(pos+1);return tree.parent&&tree.from==pos}function probablyInString(state,pos,quoteToken){let node=language.syntaxTree(state).resolveInner(pos,-1);for(let i=0;5>i;i++){if(state.sliceDoc(node.from,node.from+quoteToken.length)==quoteToken)return!0;let parent=node.to==pos&&node.parent;if(!parent)break;node=parent}return!1}Object.defineProperty(exports,"__esModule",{value:!0});var view=await require("@codemirror/view"),state=await require("@codemirror/state"),rangeset=await require("@codemirror/rangeset"),text=await require("@codemirror/text"),language=await require("@codemirror/language");const defaults={brackets:["(","[","{","'","\""],before:")]}'\":;>"},closeBracketEffect=state.StateEffect.define({map(value,mapping){let mapped=mapping.mapPos(value,-1,state.MapMode.TrackAfter);return null==mapped?void 0:mapped}}),skipBracketEffect=state.StateEffect.define({map(value,mapping){return mapping.mapPos(value)}}),closedBracket=new class extends rangeset.RangeValue{};closedBracket.startSide=1,closedBracket.endSide=-1;const bracketState=state.StateField.define({create(){return rangeset.RangeSet.empty},update(value,tr){if(tr.selection){let lineStart=tr.state.doc.lineAt(tr.selection.main.head).from,prevLineStart=tr.startState.doc.lineAt(tr.startState.selection.main.head).from;lineStart!=tr.changes.mapPos(prevLineStart,-1)&&(value=rangeset.RangeSet.empty)}value=value.map(tr.changes);for(let effect of tr.effects)effect.is(closeBracketEffect)?value=value.update({add:[closedBracket.range(effect.value,effect.value+1)]}):effect.is(skipBracketEffect)&&(value=value.update({filter:from=>from!=effect.value}));return value}}),definedClosing="()[]{}<>",inputHandler=view.EditorView.inputHandler.of((view,from,to,insert)=>{if(view.composing||view.state.readOnly)return!1;let sel=view.state.selection.main;if(2<insert.length||2==insert.length&&1==text.codePointSize(text.codePointAt(insert,0))||from!=sel.from||to!=sel.to)return!1;let tr=insertBracket(view.state,insert);return!!tr&&(view.dispatch(tr),!0)}),deleteBracketPair=({state:state$1,dispatch})=>{if(state$1.readOnly)return!1;let conf=config(state$1,state$1.selection.main.head),tokens=conf.brackets||defaults.brackets,dont=null,changes=state$1.changeByRange(range=>{if(range.empty){let before=prevChar(state$1.doc,range.head);for(let token of tokens)if(token==before&&nextChar(state$1.doc,range.head)==closing(text.codePointAt(token,0)))return{changes:{from:range.head-token.length,to:range.head+token.length},range:state.EditorSelection.cursor(range.head-token.length),userEvent:"delete.backward"}}return{range:dont=range}});return dont||dispatch(state$1.update(changes,{scrollIntoView:!0})),!dont};return exports.closeBrackets=function(){return[inputHandler,bracketState]},exports.closeBracketsKeymap=[{key:"Backspace",run:deleteBracketPair}],exports.deleteBracketPair=deleteBracketPair,exports.insertBracket=insertBracket,exports}