async function moduleInitFunction(require,exports={}){function skipForList(bl,cx,line){if(line.pos==line.text.length||bl!=cx.block&&line.indent>=cx.stack[line.depth+1].value+line.baseIndent)return!0;if(line.indent>=line.baseIndent+4)return!1;let size=(bl.type==Type.OrderedList?isOrderedList:isBulletList)(line,cx,!1);return 0<size&&(bl.type!=Type.BulletList||0>isHorizontalRule(line,cx,!1))&&line.text.charCodeAt(line.pos+size-1)==bl.value}function space(ch){return 32==ch||9==ch||10==ch||13==ch}function skipSpace(line,i=0){for(;i<line.length&&space(line.charCodeAt(i));)i++;return i}function skipSpaceBack(line,i,to){for(;i>to&&space(line.charCodeAt(i-1));)i--;return i}function isFencedCode(line){if(96!=line.next&&126!=line.next/* '`~' */)return-1;let pos=line.pos+1;for(;pos<line.text.length&&line.text.charCodeAt(pos)==line.next;)pos++;if(pos<line.pos+3)return-1;if(96==line.next)for(let i=pos;i<line.text.length;i++)if(96==line.text.charCodeAt(i))return-1;return pos}function isBlockquote(line){return 62==line.next/* '>' */?32==line.text.charCodeAt(line.pos+1)?2:1:-1}function isHorizontalRule(line,cx,breaking){if(42!=line.next&&45!=line.next&&95!=line.next/* '_-*' */)return-1;let count=1;for(let ch,pos=line.pos+1;pos<line.text.length;pos++)if(ch=line.text.charCodeAt(pos),ch==line.next)count++;else if(!space(ch))return-1;// Setext headers take precedence
return breaking&&45==line.next&&-1<isSetextUnderline(line)&&line.depth==cx.stack.length?-1:3>count?-1:1}function inList(cx,type){for(let i=cx.stack.length-1;0<=i;i--)if(cx.stack[i].type==type)return!0;return!1}function isBulletList(line,cx,breaking){return(45==line.next||43==line.next||42==line.next/* '-+*' */)&&(line.pos==line.text.length-1||space(line.text.charCodeAt(line.pos+1)))&&(!breaking||inList(cx,Type.BulletList)||line.skipSpace(line.pos+2)<line.text.length)?1:-1}function isOrderedList(line,cx,breaking){let pos=line.pos,next=line.next;for(;;){if(48<=next&&57>=next/* '0-9' */)pos++;else break;if(pos==line.text.length)return-1;next=line.text.charCodeAt(pos)}return pos==line.pos||pos>line.pos+9||46!=next&&41!=next/* '.)' */||pos<line.text.length-1&&!space(line.text.charCodeAt(pos+1))||breaking&&!inList(cx,Type.OrderedList)&&(line.skipSpace(pos+1)==line.text.length||pos>line.pos+1||49!=line.next/* '1' */)?-1:pos+1-line.pos}function isAtxHeading(line){if(35!=line.next/* '#' */)return-1;let pos=line.pos+1;for(;pos<line.text.length&&35==line.text.charCodeAt(pos);)pos++;if(pos<line.text.length&&32!=line.text.charCodeAt(pos))return-1;let size=pos-line.pos;return 6<size?-1:size}function isSetextUnderline(line){if(45!=line.next&&61!=line.next/* '-=' */||line.indent>=line.baseIndent+4)return-1;let pos=line.pos+1;for(;pos<line.text.length&&line.text.charCodeAt(pos)==line.next;)pos++;let end=pos;for(;pos<line.text.length&&space(line.text.charCodeAt(pos));)pos++;return pos==line.text.length?end:-1}function isHTMLBlock(line,_cx,breaking){if(60!=line.next/* '<' */)return-1;let rest=line.text.slice(line.pos);for(let i=0,e=HTMLBlockStyle.length-(breaking?1:0);i<e;i++)if(HTMLBlockStyle[i][0].test(rest))return i;return-1}function getListIndent(line,pos){let indentAfter=line.countIndent(pos,line.pos,line.indent),indented=line.countIndent(line.skipSpace(pos),pos,indentAfter);return indented>=indentAfter+5?indentAfter+1:indented}function addCodeText(marks,from,to){let last=marks.length-1;0<=last&&marks[last].to==from&&marks[last].type==Type.CodeText?marks[last].to=to:marks.push(elt(Type.CodeText,from,to))}// Rules for parsing blocks. A return value of false means the rule
// doesn't apply here, true means it does. When true is returned and
// `p.line` has been updated, the rule is assumed to have consumed a
// leaf block. Otherwise, it is assumed to have opened a context.
function lineEnd(text,pos){for(;pos<text.length;pos++){let next=text.charCodeAt(pos);if(10==next)break;if(!space(next))return-1}return pos}function injectGaps(ranges,rangeI,tree,offset,dont){function movePastNext(upto,inclusive){for(;inclusive?upto>=rangeEnd:upto>rangeEnd;){let size=ranges[rangeI+1].from-rangeEnd;offset+=size,upto+=size,rangeI++,rangeEnd=ranges[rangeI].to}}if(dont.has(tree.tree))return tree.tree;let rangeEnd=ranges[rangeI].to,children=[],positions=[],start=tree.from+offset;for(let ch=tree.firstChild;ch;ch=ch.nextSibling){movePastNext(ch.from+offset,!0);let node,from=ch.from+offset;ch.to+offset>rangeEnd?(node=injectGaps(ranges,rangeI,ch,offset,dont),movePastNext(ch.to+offset,!1)):node=ch.toTree(),children.push(node),positions.push(from-start)}return movePastNext(tree.to+offset,!1),new common.Tree(tree.type,children,positions,tree.to+offset-start,tree.tree?tree.tree.propValues:void 0)}/// A Markdown parser configuration.
function nonEmpty(a){return null!=a&&0<a.length}function resolveConfig(spec){if(!Array.isArray(spec))return spec;if(0==spec.length)return null;let conf=resolveConfig(spec[0]);if(1==spec.length)return conf;let rest=resolveConfig(spec.slice(1));if(!rest||!conf)return conf||rest;let conc=(a,b)=>(a||none).concat(b||none),wrapA=conf.wrap,wrapB=rest.wrap;return{props:conc(conf.props,rest.props),defineNodes:conc(conf.defineNodes,rest.defineNodes),parseBlock:conc(conf.parseBlock,rest.parseBlock),parseInline:conc(conf.parseInline,rest.parseInline),remove:conc(conf.remove,rest.remove),wrap:wrapA?wrapB?(inner,input,fragments,ranges)=>wrapA(wrapB(inner,input,fragments,ranges),input,fragments,ranges):wrapA:wrapB}}function findName(names,name){let found=names.indexOf(name);if(0>found)throw new RangeError(`Position specified relative to unknown parser ${name}`);return found}function elt(type,from,to,children){return new Element(type,from,to,children)}function finishLink(cx,content,type,start,startPos){let{text}=cx,next=cx.char(startPos),endPos=startPos;if(content.unshift(elt(Type.LinkMark,start,start+(type==Type.Image?2:1))),content.push(elt(Type.LinkMark,startPos-1,startPos)),40==next/* '(' */){let title,pos=cx.skipSpace(startPos+1),dest=parseURL(text,pos-cx.offset,cx.offset);dest&&(pos=cx.skipSpace(dest.to),title=parseLinkTitle(text,pos-cx.offset,cx.offset),title&&(pos=cx.skipSpace(title.to))),41==cx.char(pos)/* ')' */&&(content.push(elt(Type.LinkMark,startPos,startPos+1)),endPos=pos+1,dest&&content.push(dest),title&&content.push(title),content.push(elt(Type.LinkMark,pos,endPos)))}else if(91==next/* '[' */){let label=parseLinkLabel(text,startPos-cx.offset,cx.offset,!1);label&&(content.push(label),endPos=label.to)}return elt(type,start,endPos,content)}// These return `null` when falling off the end of the input, `false`
// when parsing fails otherwise (for use in the incremental link
// reference parser).
function parseURL(text,start,offset){let next=text.charCodeAt(start);if(60==next/* '<' */){for(let ch,pos=start+1;pos<text.length;pos++){if(ch=text.charCodeAt(pos),62==ch/* '>' */)return elt(Type.URL,start+offset,pos+1+offset);if(60==ch||10==ch/* '<\n' */)return!1}return null}else{let depth=0,pos=start;for(let ch,escaped=!1;pos<text.length&&(ch=text.charCodeAt(pos),!space(ch));pos++)if(escaped)escaped=!1;else if(40==ch/* '(' */)depth++;else if(41==ch/* ')' */){if(!depth)break;depth--}else 92==ch/* '\\' */&&(escaped=!0);return pos>start?elt(Type.URL,start+offset,pos+offset):pos==text.length&&null}}function parseLinkTitle(text,start,offset){let next=text.charCodeAt(start);if(39!=next&&34!=next&&40!=next/* '"\'(' */)return!1;let end=40==next?41:next;for(let ch,pos=start+1,escaped=!1;pos<text.length;pos++)if(ch=text.charCodeAt(pos),escaped)escaped=!1;else{if(ch==end)return elt(Type.LinkTitle,start+offset,pos+1+offset);92==ch/* '\\' */&&(escaped=!0)}return null}function parseLinkLabel(text,start,offset,requireNonWS){for(let ch,escaped=!1,pos=start+1,end=Math.min(text.length,pos+999);pos<end;pos++)if(ch=text.charCodeAt(pos),escaped)escaped=!1;else{if(93==ch/* ']' */)return!requireNonWS&&elt(Type.LinkLabel,start+offset,pos+1+offset);if(requireNonWS&&!space(ch)&&(requireNonWS=!1),91==ch/* '[' */)return!1;92==ch/* '\\' */&&(escaped=!0)}return null}/// Inline parsing functions get access to this context, and use it to
/// read the content and emit syntax nodes.
function injectMarks(elements,marks){if(!marks.length)return elements;if(!elements.length)return marks;let elts=elements.slice(),eI=0;for(let mark of marks){for(;eI<elts.length&&elts[eI].to<mark.to;)eI++;if(eI<elts.length&&elts[eI].from<mark.from){let e=elts[eI];e instanceof Element&&(elts[eI]=new Element(e.type,e.from,e.to,injectMarks(e.children,[mark])))}else elts.splice(eI++,0,mark)}return elts}// These are blocks that can span blank lines, and should thus only be
// reused if their next sibling is also being reused.
function leftOverSpace(node,from,to){let ranges=[];for(let nextPos,n=node.firstChild,pos=from;;n=n.nextSibling){if(nextPos=n?n.from:to,nextPos>pos&&ranges.push({from:pos,to:nextPos}),!n)break;pos=n.to}return ranges}/// Create a Markdown extension to enable nested parsing on code
/// blocks and/or embedded HTML.
function parseRow(cx,line,startI=0,elts,offset=0){let count=0,first=!0,cellStart=-1,cellEnd=-1,esc=!1,parseCell=()=>{elts.push(cx.elt("TableCell",offset+cellStart,offset+cellEnd,cx.parser.parseInline(line.slice(cellStart,cellEnd),offset+cellStart)))};for(let next,i=startI;i<line.length;i++)next=line.charCodeAt(i),124!=next/* '|' */||esc?(esc||32!=next&&9!=next)&&(0>cellStart&&(cellStart=i),cellEnd=i+1):((!first||-1<cellStart)&&count++,first=!1,elts&&(-1<cellStart&&parseCell(),elts.push(cx.elt("TableDelimiter",i+offset,i+offset+1))),cellStart=cellEnd=-1),esc=!esc&&92==next;return-1<cellStart&&(count++,elts&&parseCell()),count}function hasPipe(str,start){for(let next,i=start;i<str.length;i++){if(next=str.charCodeAt(i),124==next/* '|' */)return!0;92==next/* '\\' */&&i++}return!1}function parseSubSuper(ch,node,mark){return(cx,next,pos)=>{if(next!=ch||cx.char(pos+1)==ch)return-1;let elts=[cx.elt(mark,pos,pos+1)];for(let next,i=pos+1;i<cx.end;i++){if(next=cx.char(i),next==ch)return cx.addElement(cx.elt(node,pos,i+1,elts.concat(cx.elt(mark,i,i+1))));if(92==next/* '\\' */&&elts.push(cx.elt("Escape",i,i++ +2)),space(next))break}return-1}}/// Extension providing
/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)
/// superscript using `^` markers.
Object.defineProperty(exports,"__esModule",{value:!0});var common=await require("@lezer/common");class CompositeBlock{constructor(type,// Used for indentation in list items, markup character in lists
value,from,hash,end,children,positions){this.type=type,this.value=value,this.from=from,this.hash=hash,this.end=end,this.children=children,this.positions=positions,this.hashProp=[[common.NodeProp.contextHash,hash]]}static create(type,value,from,parentHash,end){return new CompositeBlock(type,value,from,0|parentHash+(parentHash<<8)+type+(value<<4),end,[],[])}addChild(child,pos){child.prop(common.NodeProp.contextHash)!=this.hash&&(child=new common.Tree(child.type,child.children,child.positions,child.length,this.hashProp)),this.children.push(child),this.positions.push(pos)}toTree(nodeSet,end=this.end){let last=this.children.length-1;0<=last&&(end=Math.max(end,this.positions[last]+this.children[last].length+this.from));let tree=new common.Tree(nodeSet.types[this.type],this.children,this.positions,end-this.from).balance({makeTree:(children,positions,length)=>new common.Tree(common.NodeType.none,children,positions,length,this.hashProp)});return tree}}var Type;(function(Type){Type[Type.Document=1]="Document",Type[Type.CodeBlock=2]="CodeBlock",Type[Type.FencedCode=3]="FencedCode",Type[Type.Blockquote=4]="Blockquote",Type[Type.HorizontalRule=5]="HorizontalRule",Type[Type.BulletList=6]="BulletList",Type[Type.OrderedList=7]="OrderedList",Type[Type.ListItem=8]="ListItem",Type[Type.ATXHeading1=9]="ATXHeading1",Type[Type.ATXHeading2=10]="ATXHeading2",Type[Type.ATXHeading3=11]="ATXHeading3",Type[Type.ATXHeading4=12]="ATXHeading4",Type[Type.ATXHeading5=13]="ATXHeading5",Type[Type.ATXHeading6=14]="ATXHeading6",Type[Type.SetextHeading1=15]="SetextHeading1",Type[Type.SetextHeading2=16]="SetextHeading2",Type[Type.HTMLBlock=17]="HTMLBlock",Type[Type.LinkReference=18]="LinkReference",Type[Type.Paragraph=19]="Paragraph",Type[Type.CommentBlock=20]="CommentBlock",Type[Type.ProcessingInstructionBlock=21]="ProcessingInstructionBlock",Type[Type.Escape=22]="Escape",Type[Type.Entity=23]="Entity",Type[Type.HardBreak=24]="HardBreak",Type[Type.Emphasis=25]="Emphasis",Type[Type.StrongEmphasis=26]="StrongEmphasis",Type[Type.Link=27]="Link",Type[Type.Image=28]="Image",Type[Type.InlineCode=29]="InlineCode",Type[Type.HTMLTag=30]="HTMLTag",Type[Type.Comment=31]="Comment",Type[Type.ProcessingInstruction=32]="ProcessingInstruction",Type[Type.URL=33]="URL",Type[Type.HeaderMark=34]="HeaderMark",Type[Type.QuoteMark=35]="QuoteMark",Type[Type.ListMark=36]="ListMark",Type[Type.LinkMark=37]="LinkMark",Type[Type.EmphasisMark=38]="EmphasisMark",Type[Type.CodeMark=39]="CodeMark",Type[Type.CodeText=40]="CodeText",Type[Type.CodeInfo=41]="CodeInfo",Type[Type.LinkTitle=42]="LinkTitle",Type[Type.LinkLabel=43]="LinkLabel"})(Type||(Type={}));/// Data structure used to accumulate a block's content during [leaf
/// block parsing](#BlockParser.leaf).
class LeafBlock{/// @internal
constructor(/// The start position of the block.
start,/// The block's text content.
content){this.start=start,this.content=content,this.marks=[],this.parsers=[]}}/// Data structure used during block-level per-line parsing.
class Line{constructor(){this.text="",this.baseIndent=0,this.basePos=0,this.depth=0,this.markers=[],this.pos=0,this.indent=0,this.next=-1}/// @internal
forward(){this.basePos>this.pos&&this.forwardInner()}/// @internal
forwardInner(){let newPos=this.skipSpace(this.basePos);this.indent=this.countIndent(newPos,this.pos,this.indent),this.pos=newPos,this.next=newPos==this.text.length?-1:this.text.charCodeAt(newPos)}/// Skip whitespace after the given position, return the position of
/// the next non-space character or the end of the line if there's
/// only space after `from`.
skipSpace(from){return skipSpace(this.text,from)}/// @internal
reset(text){for(this.text=text,this.baseIndent=this.basePos=this.pos=this.indent=0,this.forwardInner(),this.depth=1;this.markers.length;)this.markers.pop()}/// Move the line's base position forward to the given position.
/// This should only be called by composite [block
/// parsers](#BlockParser.parse) or [markup skipping
/// functions](#NodeSpec.composite).
moveBase(to){this.basePos=to,this.baseIndent=this.countIndent(to,this.pos,this.indent)}/// Move the line's base position forward to the given _column_.
moveBaseColumn(indent){this.baseIndent=indent,this.basePos=this.findColumn(indent)}/// Store a composite-block-level marker. Should be called from
/// [markup skipping functions](#NodeSpec.composite) when they
/// consume any non-whitespace characters.
addMarker(elt){this.markers.push(elt)}/// Find the column position at `to`, optionally starting at a given
/// position and column.
countIndent(to,from=0,indent=0){for(let i=from;i<to;i++)indent+=9==this.text.charCodeAt(i)?4-indent%4:1;return indent}/// Find the position corresponding to the given column.
findColumn(goal){let i=0;for(let indent=0;i<this.text.length&&indent<goal;i++)indent+=9==this.text.charCodeAt(i)?4-indent%4:1;return i}/// @internal
scrub(){if(!this.baseIndent)return this.text;let result="";for(let i=0;i<this.basePos;i++)result+=" ";return result+this.text.slice(this.basePos)}}const DefaultSkipMarkup={[Type.Blockquote](bl,cx,line){return 62==line.next/* '>' */&&(line.markers.push(elt(Type.QuoteMark,cx.lineStart+line.pos,cx.lineStart+line.pos+1)),line.moveBase(line.pos+(space(line.text.charCodeAt(line.pos+1))?2:1)),bl.end=cx.lineStart+line.text.length,!0)},[Type.ListItem](bl,_cx,line){return!(line.indent<line.baseIndent+bl.value&&-1<line.next)&&(line.moveBaseColumn(line.baseIndent+bl.value),!0)},[Type.OrderedList]:skipForList,[Type.BulletList]:skipForList,[Type.Document](){return!0}},EmptyLine=/^[ \t]*$/,CommentEnd=/-->/,ProcessingEnd=/\?>/,HTMLBlockStyle=[[/^<(?:script|pre|style)(?:\s|>|$)/i,/<\/(?:script|pre|style)>/i],[/^\s*<!--/,CommentEnd],[/^\s*<\?/,ProcessingEnd],[/^\s*<![A-Z]/,/>/],[/^\s*<!\[CDATA\[/,/\]\]>/],[/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i,EmptyLine],[/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i,EmptyLine]],DefaultBlockParsers={LinkReference:void 0,IndentedCode(cx,line){let base=line.baseIndent+4;if(line.indent<base)return!1;let start=line.findColumn(base),from=cx.lineStart+start,to=cx.lineStart+line.text.length,marks=[],pendingMarks=[];for(addCodeText(marks,from,to);cx.nextLine()&&line.depth>=cx.stack.length;)if(line.pos==line.text.length){addCodeText(pendingMarks,cx.lineStart-1,cx.lineStart);for(let m of line.markers)pendingMarks.push(m)}else if(line.indent<base)break;else{if(pendingMarks.length){for(let m of pendingMarks)m.type==Type.CodeText?addCodeText(marks,m.from,m.to):marks.push(m);pendingMarks=[]}addCodeText(marks,cx.lineStart-1,cx.lineStart);for(let m of line.markers)marks.push(m);to=cx.lineStart+line.text.length;let codeStart=cx.lineStart+line.findColumn(line.baseIndent+4);codeStart<to&&addCodeText(marks,codeStart,to)}return pendingMarks.length&&(pendingMarks=pendingMarks.filter(m=>m.type!=Type.CodeText),pendingMarks.length&&(line.markers=pendingMarks.concat(line.markers))),cx.addNode(cx.buffer.writeElements(marks,-from).finish(Type.CodeBlock,to-from),from),!0},FencedCode(cx,line){let fenceEnd=isFencedCode(line);if(0>fenceEnd)return!1;let from=cx.lineStart+line.pos,ch=line.next,len=fenceEnd-line.pos,infoFrom=line.skipSpace(fenceEnd),infoTo=skipSpaceBack(line.text,line.text.length,infoFrom),marks=[elt(Type.CodeMark,from,from+len)];infoFrom<infoTo&&marks.push(elt(Type.CodeInfo,cx.lineStart+infoFrom,cx.lineStart+infoTo));for(let i,first=!0;cx.nextLine()&&line.depth>=cx.stack.length;first=!1){if(i=line.pos,4>line.indent-line.baseIndent)for(;i<line.text.length&&line.text.charCodeAt(i)==ch;)i++;if(i-line.pos>=len&&line.skipSpace(i)==line.text.length){for(let m of line.markers)marks.push(m);marks.push(elt(Type.CodeMark,cx.lineStart+line.pos,cx.lineStart+i)),cx.nextLine();break}else{first||addCodeText(marks,cx.lineStart-1,cx.lineStart);for(let m of line.markers)marks.push(m);let textStart=cx.lineStart+line.basePos,textEnd=cx.lineStart+line.text.length;textStart<textEnd&&addCodeText(marks,textStart,textEnd)}}return cx.addNode(cx.buffer.writeElements(marks,-from).finish(Type.FencedCode,cx.prevLineEnd()-from),from),!0},Blockquote(cx,line){let size=isBlockquote(line);return!(0>size)&&(cx.startContext(Type.Blockquote,line.pos),cx.addNode(Type.QuoteMark,cx.lineStart+line.pos,cx.lineStart+line.pos+1),line.moveBase(line.pos+size),null)},HorizontalRule(cx,line){if(0>isHorizontalRule(line,cx,!1))return!1;let from=cx.lineStart+line.pos;return cx.nextLine(),cx.addNode(Type.HorizontalRule,from),!0},BulletList(cx,line){let size=isBulletList(line,cx,!1);if(0>size)return!1;cx.block.type!=Type.BulletList&&cx.startContext(Type.BulletList,line.basePos,line.next);let newBase=getListIndent(line,line.pos+1);return cx.startContext(Type.ListItem,line.basePos,newBase-line.baseIndent),cx.addNode(Type.ListMark,cx.lineStart+line.pos,cx.lineStart+line.pos+size),line.moveBaseColumn(newBase),null},OrderedList(cx,line){let size=isOrderedList(line,cx,!1);if(0>size)return!1;cx.block.type!=Type.OrderedList&&cx.startContext(Type.OrderedList,line.basePos,line.text.charCodeAt(line.pos+size-1));let newBase=getListIndent(line,line.pos+size);return cx.startContext(Type.ListItem,line.basePos,newBase-line.baseIndent),cx.addNode(Type.ListMark,cx.lineStart+line.pos,cx.lineStart+line.pos+size),line.moveBaseColumn(newBase),null},ATXHeading(cx,line){let size=isAtxHeading(line);if(0>size)return!1;let off=line.pos,from=cx.lineStart+off,endOfSpace=skipSpaceBack(line.text,line.text.length,off),after=endOfSpace;for(;after>off&&line.text.charCodeAt(after-1)==line.next;)after--;after!=endOfSpace&&after!=off&&space(line.text.charCodeAt(after-1))||(after=line.text.length);let buf=cx.buffer.write(Type.HeaderMark,0,size).writeElements(cx.parser.parseInline(line.text.slice(off+size+1,after),from+size+1),-from);after<line.text.length&&buf.write(Type.HeaderMark,after-off,endOfSpace-off);let node=buf.finish(Type.ATXHeading1-1+size,line.text.length-off);return cx.nextLine(),cx.addNode(node,from),!0},HTMLBlock(cx,line){let type=isHTMLBlock(line,cx,!1);if(0>type)return!1;let from=cx.lineStart+line.pos,end=HTMLBlockStyle[type][1],marks=[],trailing=end!=EmptyLine;for(;!end.test(line.text)&&cx.nextLine();){if(line.depth<cx.stack.length){trailing=!1;break}for(let m of line.markers)marks.push(m)}trailing&&cx.nextLine();let nodeType=end==CommentEnd?Type.CommentBlock:end==ProcessingEnd?Type.ProcessingInstructionBlock:Type.HTMLBlock,to=cx.prevLineEnd();return cx.addNode(cx.buffer.writeElements(marks,-from).finish(nodeType,to-from),from),!0},SetextHeading:void 0// Specifies relative precedence for block-continue function
};// This implements a state machine that incrementally parses link references. At each
// next line, it looks ahead to see if the line continues the reference or not. If it
// doesn't and a valid link is available ending before that line, it finishes that.
// Similarly, on `finish` (when the leaf is terminated by external circumstances), it
// creates a link reference if there's a valid reference up to the current point.
class LinkReferenceParser{constructor(leaf){this.stage=0/* Start */,this.elts=[],this.pos=0,this.start=leaf.start,this.advance(leaf.content)}nextLine(cx,line,leaf){if(-1==this.stage/* Failed */)return!1;let content=leaf.content+"\n"+line.scrub(),finish=this.advance(content);return!!(-1<finish&&finish<content.length)&&this.complete(cx,leaf,finish)}finish(cx,leaf){return(2==this.stage/* Link */||3==this.stage/* Title */)&&skipSpace(leaf.content,this.pos)==leaf.content.length&&this.complete(cx,leaf,leaf.content.length)}complete(cx,leaf,len){return cx.addLeafElement(leaf,elt(Type.LinkReference,this.start,this.start+len,this.elts)),!0}nextStage(elt){return elt?(this.pos=elt.to-this.start,this.elts.push(elt),this.stage++,!0):(!1===elt&&(this.stage=-1/* Failed */),!1)}advance(content){for(;;){if(-1==this.stage/* Failed */)return-1;if(0==this.stage/* Start */){if(!this.nextStage(parseLinkLabel(content,this.pos,this.start,!0)))return-1;if(58!=content.charCodeAt(this.pos)/* ':' */)return this.stage=-1/* Failed */;this.elts.push(elt(Type.LinkMark,this.pos+this.start,this.pos+this.start+1)),this.pos++}else{if(1!=this.stage/* Label */){if(2==this.stage/* Link */){let skip=skipSpace(content,this.pos),end=0;if(skip>this.pos){let title=parseLinkTitle(content,skip,this.start);if(title){let titleEnd=lineEnd(content,title.to-this.start);0<titleEnd&&(this.nextStage(title),end=titleEnd)}}return end||(end=lineEnd(content,this.pos)),0<end&&end<content.length?end:-1}// RefStage.Title
return lineEnd(content,this.pos)}if(!this.nextStage(parseURL(content,skipSpace(content,this.pos),this.start)))return-1}}}}class SetextHeadingParser{nextLine(cx,line,leaf){let underline=line.depth<cx.stack.length?-1:isSetextUnderline(line),next=line.next;if(0>underline)return!1;let underlineMark=elt(Type.HeaderMark,cx.lineStart+line.pos,cx.lineStart+underline);return cx.nextLine(),cx.addLeafElement(leaf,elt(61==next?Type.SetextHeading1:Type.SetextHeading2,leaf.start,cx.prevLineEnd(),[...cx.parser.parseInline(leaf.content,leaf.start),underlineMark])),!0}finish(){return!1}}const DefaultLeafBlocks={LinkReference(_,leaf){return 91==leaf.content.charCodeAt(0)/* '[' */?new LinkReferenceParser(leaf):null},SetextHeading(){return new SetextHeadingParser}};/// Block-level parsing functions get access to this context object.
class BlockContext{/// @internal
constructor(/// The parser configuration used.
parser,/// @internal
input,fragments,/// @internal
ranges){this.parser=parser,this.input=input,this.ranges=ranges,this.line=new Line,this.atEnd=!1,this.dontInject=new Set,this.stoppedAt=null,this.rangeI=0,this.to=ranges[ranges.length-1].to,this.lineStart=this.absoluteLineStart=this.absoluteLineEnd=ranges[0].from,this.block=CompositeBlock.create(Type.Document,0,this.lineStart,0,0),this.stack=[this.block],this.fragments=fragments.length?new FragmentCursor(fragments,input):null,this.readLine()}get parsedPos(){return this.absoluteLineStart}advance(){if(null!=this.stoppedAt&&this.absoluteLineStart>this.stoppedAt)return this.finish();let{line}=this;for(;;){for(;line.depth<this.stack.length;)this.finishContext();for(let mark of line.markers)this.addNode(mark.type,mark.from,mark.to);if(line.pos<line.text.length)break;// Empty line
if(!this.nextLine())return this.finish()}if(this.fragments&&this.reuseFragment(line.basePos))return null;start:for(;;){for(let type of this.parser.blockParsers)if(type){let result=type(this,line);if(!1!=result){if(!0==result)return null;line.forward();continue start}}break}let leaf=new LeafBlock(this.lineStart+line.pos,line.text.slice(line.pos));for(let parse of this.parser.leafBlockParsers)if(parse){let parser=parse(this,leaf);parser&&leaf.parsers.push(parser)}lines:for(;this.nextLine()&&line.pos!=line.text.length;){if(line.indent<line.baseIndent+4)for(let stop of this.parser.endLeafBlock)if(stop(this,line))break lines;for(let parser of leaf.parsers)if(parser.nextLine(this,line,leaf))return null;leaf.content+="\n"+line.scrub();for(let m of line.markers)leaf.marks.push(m)}return this.finishLeaf(leaf),null}stopAt(pos){if(null!=this.stoppedAt&&this.stoppedAt<pos)throw new RangeError("Can't move stoppedAt forward");this.stoppedAt=pos}reuseFragment(start){if(!this.fragments.moveTo(this.absoluteLineStart+start,this.absoluteLineStart)||!this.fragments.matches(this.block.hash))return!1;let taken=this.fragments.takeNodes(this);if(!taken)return!1;let withoutGaps=taken,end=this.absoluteLineStart+taken;for(let i=1;i<this.ranges.length;i++){let gapFrom=this.ranges[i-1].to,gapTo=this.ranges[i].from;gapFrom>=this.lineStart&&gapTo<end&&(withoutGaps-=gapTo-gapFrom)}return this.lineStart+=withoutGaps,this.absoluteLineStart+=taken,this.moveRangeI(),this.absoluteLineStart<this.to?(this.lineStart++,this.absoluteLineStart++,this.readLine()):(this.atEnd=!0,this.readLine()),!0}/// Move to the next input line. This should only be called by
/// (non-composite) [block parsers](#BlockParser.parse) that consume
/// the line directly, or leaf block parser
/// [`nextLine`](#LeafBlockParser.nextLine) methods when they
/// consume the current line (and return true).
nextLine(){return this.lineStart+=this.line.text.length,this.absoluteLineEnd>=this.to?(this.absoluteLineStart=this.absoluteLineEnd,this.atEnd=!0,this.readLine(),!1):(this.lineStart++,this.absoluteLineStart=this.absoluteLineEnd+1,this.moveRangeI(),this.readLine(),!0)}moveRangeI(){for(;this.rangeI<this.ranges.length-1&&this.absoluteLineStart>=this.ranges[this.rangeI].to;)this.rangeI++}/// @internal
readLine(){let text,{line}=this,end=this.absoluteLineStart;if(this.atEnd)text="";else if(text=this.lineChunkAt(end),end+=text.length,1<this.ranges.length)for(let textOffset=this.absoluteLineStart,rangeI=this.rangeI;this.ranges[rangeI].to<end;){rangeI++;let nextFrom=this.ranges[rangeI].from,after=this.lineChunkAt(nextFrom);end=nextFrom+after.length,text=text.slice(0,this.ranges[rangeI-1].to-textOffset)+after,textOffset=end-text.length}for(this.absoluteLineEnd=end,line.reset(text);line.depth<this.stack.length;line.depth++){let cx=this.stack[line.depth],handler=this.parser.skipContextMarkup[cx.type];if(!handler)throw new Error("Unhandled block context "+Type[cx.type]);if(!handler(cx,this,line))break;line.forward()}}lineChunkAt(pos){let text,next=this.input.chunk(pos);if(!this.input.lineChunks){let eol=next.indexOf("\n");text=0>eol?next:next.slice(0,eol)}else text="\n"==next?"":next;return pos+text.length>this.to?text.slice(0,this.to-pos):text}/// The end position of the previous line.
prevLineEnd(){return this.atEnd?this.lineStart:this.lineStart-1}/// @internal
startContext(type,start,value=0){this.block=CompositeBlock.create(type,value,this.lineStart+start,this.block.hash,this.lineStart+this.line.text.length),this.stack.push(this.block)}/// Start a composite block. Should only be called from [block
/// parser functions](#BlockParser.parse) that return null.
startComposite(type,start,value=0){this.startContext(this.parser.getNodeType(type),start,value)}/// @internal
addNode(block,from,to){"number"==typeof block&&(block=new common.Tree(this.parser.nodeSet.types[block],none,none,(null!==to&&void 0!==to?to:this.prevLineEnd())-from)),this.block.addChild(block,from-this.block.from)}/// Add a block element. Can be called by [block
/// parsers](#BlockParser.parse).
addElement(elt){this.block.addChild(elt.toTree(this.parser.nodeSet),elt.from-this.block.from)}/// Add a block element from a [leaf parser](#LeafBlockParser). This
/// makes sure any extra composite block markup (such as blockquote
/// markers) inside the block are also added to the syntax tree.
addLeafElement(leaf,elt){this.addNode(this.buffer.writeElements(injectMarks(elt.children,leaf.marks),-elt.from).finish(elt.type,elt.to-elt.from),elt.from)}/// @internal
finishContext(){let cx=this.stack.pop(),top=this.stack[this.stack.length-1];top.addChild(cx.toTree(this.parser.nodeSet),cx.from-top.from),this.block=top}finish(){for(;1<this.stack.length;)this.finishContext();return this.addGaps(this.block.toTree(this.parser.nodeSet,this.lineStart))}addGaps(tree){return 1<this.ranges.length?injectGaps(this.ranges,0,tree.topNode,this.ranges[0].from,this.dontInject):tree}/// @internal
finishLeaf(leaf){for(let parser of leaf.parsers)if(parser.finish(this,leaf))return;let inline=injectMarks(this.parser.parseInline(leaf.content,leaf.start),leaf.marks);this.addNode(this.buffer.writeElements(inline,-leaf.start).finish(Type.Paragraph,leaf.content.length),leaf.start)}elt(type,from,to,children){return"string"==typeof type?elt(this.parser.getNodeType(type),from,to,children):new TreeElement(type,from)}/// @internal
get buffer(){return new Buffer(this.parser.nodeSet)}}class MarkdownParser extends common.Parser{/// @internal
constructor(/// The parser's syntax [node
/// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).
nodeSet,/// @internal
blockParsers,/// @internal
leafBlockParsers,/// @internal
blockNames,/// @internal
endLeafBlock,/// @internal
skipContextMarkup,/// @internal
inlineParsers,/// @internal
inlineNames,/// @internal
wrappers){super(),this.nodeSet=nodeSet,this.blockParsers=blockParsers,this.leafBlockParsers=leafBlockParsers,this.blockNames=blockNames,this.endLeafBlock=endLeafBlock,this.skipContextMarkup=skipContextMarkup,this.inlineParsers=inlineParsers,this.inlineNames=inlineNames,this.wrappers=wrappers,this.nodeTypes=Object.create(null);for(let t of nodeSet.types)this.nodeTypes[t.name]=t.id}createParse(input,fragments,ranges){let parse=new BlockContext(this,input,fragments,ranges);for(let w of this.wrappers)parse=w(parse,input,fragments,ranges);return parse}/// Reconfigure the parser.
configure(spec){let config=resolveConfig(spec);if(!config)return this;let{nodeSet,skipContextMarkup}=this,blockParsers=this.blockParsers.slice(),leafBlockParsers=this.leafBlockParsers.slice(),blockNames=this.blockNames.slice(),inlineParsers=this.inlineParsers.slice(),inlineNames=this.inlineNames.slice(),endLeafBlock=this.endLeafBlock.slice(),wrappers=this.wrappers;if(nonEmpty(config.defineNodes)){skipContextMarkup=Object.assign({},skipContextMarkup);let nodeTypes=nodeSet.types.slice();for(let s of config.defineNodes){let{name,block,composite}="string"==typeof s?{name:s}:s;if(nodeTypes.some(t=>t.name==name))continue;composite&&(skipContextMarkup[nodeTypes.length]=(bl,cx,line)=>composite(cx,line,bl.value));let id=nodeTypes.length,group=composite?["Block","BlockContext"]:block?id>=Type.ATXHeading1&&id<=Type.SetextHeading2?["Block","LeafBlock","Heading"]:["Block","LeafBlock"]:void 0;nodeTypes.push(common.NodeType.define({id,name,props:group&&[[common.NodeProp.group,group]]}))}nodeSet=new common.NodeSet(nodeTypes)}if(nonEmpty(config.props)&&(nodeSet=nodeSet.extend(...config.props)),nonEmpty(config.remove))for(let rm of config.remove){let block=this.blockNames.indexOf(rm),inline=this.inlineNames.indexOf(rm);-1<block&&(blockParsers[block]=leafBlockParsers[block]=void 0),-1<inline&&(inlineParsers[inline]=void 0)}if(nonEmpty(config.parseBlock))for(let spec of config.parseBlock){let found=blockNames.indexOf(spec.name);if(-1<found)blockParsers[found]=spec.parse,leafBlockParsers[found]=spec.leaf;else{let pos=spec.before?findName(blockNames,spec.before):spec.after?findName(blockNames,spec.after)+1:blockNames.length-1;blockParsers.splice(pos,0,spec.parse),leafBlockParsers.splice(pos,0,spec.leaf),blockNames.splice(pos,0,spec.name)}spec.endLeaf&&endLeafBlock.push(spec.endLeaf)}if(nonEmpty(config.parseInline))for(let spec of config.parseInline){let found=inlineNames.indexOf(spec.name);if(-1<found)inlineParsers[found]=spec.parse;else{let pos=spec.before?findName(inlineNames,spec.before):spec.after?findName(inlineNames,spec.after)+1:inlineNames.length-1;inlineParsers.splice(pos,0,spec.parse),inlineNames.splice(pos,0,spec.name)}}return config.wrap&&(wrappers=wrappers.concat(config.wrap)),new MarkdownParser(nodeSet,blockParsers,leafBlockParsers,blockNames,endLeafBlock,skipContextMarkup,inlineParsers,inlineNames,wrappers)}/// @internal
getNodeType(name){let found=this.nodeTypes[name];if(null==found)throw new RangeError(`Unknown node type '${name}'`);return found}/// Parse the given piece of inline text at the given offset,
/// returning an array of [`Element`](#Element) objects representing
/// the inline content.
parseInline(text,offset){let cx=new InlineContext(this,text,offset);outer:for(let next,pos=offset;pos<cx.end;){next=cx.char(pos);for(let token of this.inlineParsers)if(token){let result=token(cx,next,pos);if(0<=result){pos=result;continue outer}}pos++}return cx.resolveMarkers(0)}}let nodeTypes=[common.NodeType.none];for(let name,i=1;name=Type[i];i++)nodeTypes[i]=common.NodeType.define({id:i,name,props:i>=Type.Escape?[]:[[common.NodeProp.group,i in DefaultSkipMarkup?["Block","BlockContext"]:["Block","LeafBlock"]]]});const none=[];class Buffer{constructor(nodeSet){this.nodeSet=nodeSet,this.content=[],this.nodes=[]}write(type,from,to,children=0){return this.content.push(type,from,to,4+4*children),this}writeElements(elts,offset=0){for(let e of elts)e.writeTo(this,offset);return this}finish(type,length){return common.Tree.build({buffer:this.content,nodeSet:this.nodeSet,reused:this.nodes,topID:type,length})}}/// Elements are used to compose syntax nodes during parsing.
class Element{/// @internal
constructor(/// The node's
/// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).
type,/// The start of the node, as an offset from the start of the document.
from,/// The end of the node.
to,/// The node's child nodes @internal
children=none){this.type=type,this.from=from,this.to=to,this.children=children}/// @internal
writeTo(buf,offset){let startOff=buf.content.length;buf.writeElements(this.children,offset),buf.content.push(this.type,this.from+offset,this.to+offset,buf.content.length+4-startOff)}/// @internal
toTree(nodeSet){return new Buffer(nodeSet).writeElements(this.children,-this.from).finish(this.type,this.to-this.from)}}class TreeElement{constructor(tree,from){this.tree=tree,this.from=from}get to(){return this.from+this.tree.length}get type(){return this.tree.type.id}get children(){return none}writeTo(buf,offset){buf.nodes.push(this.tree),buf.content.push(buf.nodes.length-1,this.from+offset,this.to+offset,-1)}toTree(){return this.tree}}const EmphasisUnderscore={resolve:"Emphasis",mark:"EmphasisMark"},EmphasisAsterisk={resolve:"Emphasis",mark:"EmphasisMark"},LinkStart={},ImageStart={};class InlineDelimiter{constructor(type,from,to,side){this.type=type,this.from=from,this.to=to,this.side=side}}const Escapable="!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";let Punctuation=/[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;try{Punctuation=/[\p{Pc}|\p{Pd}|\p{Pe}|\p{Pf}|\p{Pi}|\p{Po}|\p{Ps}]/u}catch(_){}const DefaultInline={Escape(cx,next,start){if(92!=next/* '\\' */||start==cx.end-1)return-1;let escaped=cx.char(start+1);for(let i=0;i<Escapable.length;i++)if(Escapable.charCodeAt(i)==escaped)return cx.append(elt(Type.Escape,start,start+2));return-1},Entity(cx,next,start){if(38!=next/* '&' */)return-1;let m=/^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start+1,start+31));return m?cx.append(elt(Type.Entity,start,start+1+m[0].length)):-1},InlineCode(cx,next,start){if(96!=next/* '`' */||start&&96==cx.char(start-1))return-1;let pos=start+1;for(;pos<cx.end&&96==cx.char(pos);)pos++;for(let size=pos-start,curSize=0;pos<cx.end;pos++)if(96!=cx.char(pos))curSize=0;else if(curSize++,curSize==size&&96!=cx.char(pos+1))return cx.append(elt(Type.InlineCode,start,pos+1,[elt(Type.CodeMark,start,start+size),elt(Type.CodeMark,pos+1-size,pos+1)]));return-1},HTMLTag(cx,next,start){if(60!=next/* '<' */||start==cx.end-1)return-1;let after=cx.slice(start+1,cx.end),url=/^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);if(url)return cx.append(elt(Type.URL,start,start+1+url[0].length));let comment=/^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);if(comment)return cx.append(elt(Type.Comment,start,start+1+comment[0].length));let procInst=/^\?[^]*?\?>/.exec(after);if(procInst)return cx.append(elt(Type.ProcessingInstruction,start,start+1+procInst[0].length));let m=/^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);return m?cx.append(elt(Type.HTMLTag,start,start+1+m[0].length)):-1},Emphasis(cx,next,start){if(95!=next&&42!=next)return-1;let pos=start+1;for(;cx.char(pos)==next;)pos++;let before=cx.slice(start-1,start),after=cx.slice(pos,pos+1),pBefore=Punctuation.test(before),pAfter=Punctuation.test(after),sBefore=/\s|^$/.test(before),sAfter=/\s|^$/.test(after),leftFlanking=!sAfter&&(!pAfter||sBefore||pBefore),rightFlanking=!sBefore&&(!pBefore||sAfter||pAfter);return cx.append(new InlineDelimiter(95==next?EmphasisUnderscore:EmphasisAsterisk,start,pos,(leftFlanking&&(42==next||!rightFlanking||pBefore)?1/* Open */:0)|(rightFlanking&&(42==next||!leftFlanking||pAfter)?2/* Close */:0)))},HardBreak(cx,next,start){if(92==next/* '\\' */&&10==cx.char(start+1)/* '\n' */)return cx.append(elt(Type.HardBreak,start,start+2));if(32==next){let pos=start+1;for(;32==cx.char(pos);)pos++;if(10==cx.char(pos)&&pos>=start+2)return cx.append(elt(Type.HardBreak,start,pos+1))}return-1},Link(cx,next,start){return 91==next/* '[' */?cx.append(new InlineDelimiter(LinkStart,start,start+1,1/* Open */)):-1},Image(cx,next,start){return 33==next/* '!' */&&91==cx.char(start+1)/* '[' */?cx.append(new InlineDelimiter(ImageStart,start,start+2,1/* Open */)):-1},LinkEnd(cx,next,start){if(93!=next/* ']' */)return-1;// Scanning back to the next link/image start marker
for(let part,i=cx.parts.length-1;0<=i;i--)if(part=cx.parts[i],part instanceof InlineDelimiter&&(part.type==LinkStart||part.type==ImageStart)){// If this one has been set invalid (because it would produce
// a nested link) or there's no valid link here ignore both.
if(!part.side||cx.skipSpace(part.to)==start&&!/[(\[]/.test(cx.slice(start+1,start+2)))return cx.parts[i]=null,-1;// Finish the content and replace the entire range in
// this.parts with the link/image node.
let content=cx.takeContent(i),link=cx.parts[i]=finishLink(cx,content,part.type==LinkStart?Type.Link:Type.Image,part.from,start+1);// Set any open-link markers before this link to invalid.
if(part.type==LinkStart)for(let p,j=0;j<i;j++)p=cx.parts[j],p instanceof InlineDelimiter&&p.type==LinkStart&&(p.side=0);return link.to}return-1}};class InlineContext{/// @internal
constructor(/// The parser that is being used.
parser,/// The text of this inline section.
text,/// The starting offset of the section in the document.
offset){this.parser=parser,this.text=text,this.offset=offset,this.parts=[]}/// Get the character code at the given (document-relative)
/// position.
char(pos){return pos>=this.end?-1:this.text.charCodeAt(pos-this.offset)}/// The position of the end of this inline section.
get end(){return this.offset+this.text.length}/// Get a substring of this inline section. Again uses
/// document-relative positions.
slice(from,to){return this.text.slice(from-this.offset,to-this.offset)}/// @internal
append(elt){return this.parts.push(elt),elt.to}/// Add a [delimiter](#DelimiterType) at this given position. `open`
/// and `close` indicate whether this delimiter is opening, closing,
/// or both. Returns the end of the delimiter, for convenient
/// returning from [parse functions](#InlineParser.parse).
addDelimiter(type,from,to,open,close){return this.append(new InlineDelimiter(type,from,to,(open?1/* Open */:0)|(close?2/* Close */:0)))}/// Add an inline element. Returns the end of the element.
addElement(elt){return this.append(elt)}/// @internal
resolveMarkers(from){for(let close,i=from;i<this.parts.length;i++){if(close=this.parts[i],!(close instanceof InlineDelimiter&&close.type.resolve&&2&close.side/* Close */))continue;let open,emp=close.type==EmphasisUnderscore||close.type==EmphasisAsterisk,closeSize=close.to-close.from,j=i-1;for(;j>=from;j--){let part=this.parts[j];if(!(!(part instanceof InlineDelimiter&&1&part.side/* Open */&&part.type==close.type)||emp&&(1&close.side/* Open */||2&part.side/* Close */)&&0==(part.to-part.from+closeSize)%3&&((part.to-part.from)%3||closeSize%3))){open=part;break}}if(!open)continue;let type=close.type.resolve,content=[],start=open.from,end=close.to;if(emp){let size=Math.min(2,open.to-open.from,closeSize);start=open.to-size,end=close.from+size,type=1==size?"Emphasis":"StrongEmphasis"}open.type.mark&&content.push(this.elt(open.type.mark,start,open.to));for(let k=j+1;k<i;k++)this.parts[k]instanceof Element&&content.push(this.parts[k]),this.parts[k]=null;close.type.mark&&content.push(this.elt(close.type.mark,close.from,end));let element=this.elt(type,start,end,content);this.parts[j]=emp&&open.from!=start?new InlineDelimiter(open.type,open.from,start,open.side):null;let keep=this.parts[i]=emp&&close.to!=end?new InlineDelimiter(close.type,end,close.to,close.side):null;keep?this.parts.splice(i,0,element):this.parts[i]=element}let result=[];for(let part,i=from;i<this.parts.length;i++)part=this.parts[i],part instanceof Element&&result.push(part);return result}/// Find an opening delimiter of the given type. Returns `null` if
/// no delimiter is found, or an index that can be passed to
/// [`takeContent`](#InlineContext.takeContent) otherwise.
findOpeningDelimiter(type){for(let part,i=this.parts.length-1;0<=i;i--)if(part=this.parts[i],part instanceof InlineDelimiter&&part.type==type)return i;return null}/// Remove all inline elements and delimiters starting from the
/// given index (which you should get from
/// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
/// resolve delimiters inside of them, and return them as an array
/// of elements.
takeContent(startIndex){let content=this.resolveMarkers(startIndex);return this.parts.length=startIndex,content}/// Skip space after the given (document) position, returning either
/// the position of the next non-space character or the end of the
/// section.
skipSpace(from){return skipSpace(this.text,from-this.offset)+this.offset}elt(type,from,to,children){return"string"==typeof type?elt(this.parser.getNodeType(type),from,to,children):new TreeElement(type,from)}}const NotLast=[Type.CodeBlock,Type.ListItem,Type.OrderedList,Type.BulletList];class FragmentCursor{constructor(fragments,input){this.fragments=fragments,this.input=input,this.i=0,this.fragment=null,this.fragmentEnd=-1,this.cursor=null,fragments.length&&(this.fragment=fragments[this.i++])}nextFragment(){this.fragment=this.i<this.fragments.length?this.fragments[this.i++]:null,this.cursor=null,this.fragmentEnd=-1}moveTo(pos,lineStart){for(;this.fragment&&this.fragment.to<=pos;)this.nextFragment();if(!this.fragment||this.fragment.from>(pos?pos-1:0))return!1;if(0>this.fragmentEnd){let end=this.fragment.to;for(;0<end&&"\n"!=this.input.read(end-1,end);)end--;this.fragmentEnd=end?end-1:0}let c=this.cursor;c||(c=this.cursor=this.fragment.tree.cursor(),c.firstChild());let rPos=pos+this.fragment.offset;for(;c.to<=rPos;)if(!c.parent())return!1;for(;;){if(c.from>=rPos)return this.fragment.from<=lineStart;if(!c.childAfter(rPos))return!1}}matches(hash){let tree=this.cursor.tree;return tree&&tree.prop(common.NodeProp.contextHash)==hash}takeNodes(cx){let cur=this.cursor,off=this.fragment.offset,fragEnd=this.fragmentEnd-(this.fragment.openEnd?1:0),start=cx.absoluteLineStart,end=start,blockI=cx.block.children.length,prevEnd=end,prevI=blockI;for(;;){if(cur.to-off>fragEnd){if(cur.type.isAnonymous&&cur.firstChild())continue;break}if(cx.dontInject.add(cur.tree),cx.addNode(cur.tree,cur.from-off),cur.type.is("Block")&&(0>NotLast.indexOf(cur.type.id)?(end=cur.to-off,blockI=cx.block.children.length):(end=prevEnd,blockI=prevI,prevEnd=cur.to-off,prevI=cx.block.children.length)),!cur.nextSibling())break}for(;cx.block.children.length>blockI;)cx.block.children.pop(),cx.block.positions.pop();return end-start}}/// The default CommonMark parser.
const parser=new MarkdownParser(new common.NodeSet(nodeTypes),Object.keys(DefaultBlockParsers).map(n=>DefaultBlockParsers[n]),Object.keys(DefaultBlockParsers).map(n=>DefaultLeafBlocks[n]),Object.keys(DefaultBlockParsers),[(_,line)=>0<=isAtxHeading(line),(_,line)=>0<=isFencedCode(line),(_,line)=>0<=isBlockquote(line),(p,line)=>0<=isBulletList(line,p,!0),(p,line)=>0<=isOrderedList(line,p,!0),(p,line)=>0<=isHorizontalRule(line,p,!0),(p,line)=>0<=isHTMLBlock(line,p,!0)],DefaultSkipMarkup,Object.keys(DefaultInline).map(n=>DefaultInline[n]),Object.keys(DefaultInline),[]),StrikethroughDelim={resolve:"Strikethrough",mark:"StrikethroughMark"},Strikethrough={defineNodes:["Strikethrough","StrikethroughMark"],parseInline:[{name:"Strikethrough",parse(cx,next,pos){return 126!=next/* '~' */||126!=cx.char(pos+1)?-1:cx.addDelimiter(StrikethroughDelim,pos,pos+2,!0,!0)},after:"Emphasis"}]};class TableParser{constructor(){this.rows=null}nextLine(cx,line,leaf){if(null==this.rows){this.rows=!1;let lineText;if((45==line.next||58==line.next||124==line.next/* '-:|' */)&&/^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/.test(lineText=line.text.slice(line.pos))){let firstRow=[],firstCount=parseRow(cx,leaf.content,0,firstRow,leaf.start);firstCount==parseRow(cx,lineText,line.pos)&&(this.rows=[cx.elt("TableHeader",leaf.start,leaf.start+leaf.content.length,firstRow),cx.elt("TableDelimiter",cx.lineStart+line.pos,cx.lineStart+line.text.length)])}}else if(this.rows){// Line after the second
let content=[];parseRow(cx,line.text,line.pos,content,cx.lineStart),this.rows.push(cx.elt("TableRow",cx.lineStart+line.pos,cx.lineStart+line.text.length,content))}return!1}finish(cx,leaf){return!!this.rows&&(this.emit(cx,leaf),!0)}emit(cx,leaf){cx.addLeafElement(leaf,cx.elt("Table",leaf.start,leaf.start+leaf.content.length,this.rows))}}/// This extension provides
/// [GFM-style](https://github.github.com/gfm/#tables-extension-)
/// tables, using syntax like this:
///
/// ```
/// | head 1 | head 2 |
/// | ---    | ---    |
/// | cell 1 | cell 2 |
/// ```
const Table={defineNodes:[{name:"Table",block:!0},"TableHeader","TableRow","TableCell","TableDelimiter"],parseBlock:[{name:"Table",leaf(_,leaf){return hasPipe(leaf.content,0)?new TableParser:null},before:"SetextHeading"}]};class TaskParser{nextLine(){return!1}finish(cx,leaf){return cx.addLeafElement(leaf,cx.elt("Task",leaf.start,leaf.start+leaf.content.length,[cx.elt("TaskMarker",leaf.start,leaf.start+3),...cx.parser.parseInline(leaf.content.slice(3),leaf.start+3)])),!0}}/// Extension providing
/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)
/// task list items, where list items can be prefixed with `[ ]` or
/// `[x]` to add a checkbox.
const TaskList={defineNodes:[{name:"Task",block:!0},"TaskMarker"],parseBlock:[{name:"TaskList",leaf(cx,leaf){return /^\[[ xX]\]/.test(leaf.content)&&"ListItem"==cx.parser.nodeSet.types[cx.block.type].name?new TaskParser:null},after:"SetextHeading"}]},Superscript={defineNodes:["Superscript","SuperscriptMark"],parseInline:[{name:"Superscript",parse:parseSubSuper(94/* '^' */,"Superscript","SuperscriptMark")}]},Subscript={defineNodes:["Subscript","SubscriptMark"],parseInline:[{name:"Subscript",parse:parseSubSuper(126/* '~' */,"Subscript","SubscriptMark")}]};/// Extension bundle containing [`Table`](#Table),
/// [`TaskList`](#TaskList) and [`Strikethrough`](#Strikethrough).
return exports.BlockContext=BlockContext,exports.Element=Element,exports.Emoji={defineNodes:["Emoji"],parseInline:[{name:"Emoji",parse(cx,next,pos){let match;return 58==next/* ':' */&&(match=/^[a-zA-Z_0-9]+:/.exec(cx.slice(pos+1,cx.end)))?cx.addElement(cx.elt("Emoji",pos,pos+1+match[0].length)):-1}}]},exports.GFM=[Table,TaskList,Strikethrough],exports.InlineContext=InlineContext,exports.LeafBlock=LeafBlock,exports.Line=Line,exports.MarkdownParser=MarkdownParser,exports.Strikethrough=Strikethrough,exports.Subscript=Subscript,exports.Superscript=Superscript,exports.Table=Table,exports.TaskList=TaskList,exports.parseCode=function(config){let{codeParser,htmlParser}=config,wrap=common.parseMixed((node,input)=>{let id=node.type.id;if(codeParser&&(id==Type.CodeBlock||id==Type.FencedCode)){let info="";if(id=Type.FencedCode){let infoNode=node.node.getChild(Type.CodeInfo);infoNode&&(info=input.read(infoNode.from,infoNode.to))}let parser=codeParser(info);if(parser)return{parser,overlay:node=>node.type.id==Type.CodeText}}else if(htmlParser&&(id==Type.HTMLBlock||id==Type.HTMLTag))return{parser:htmlParser,overlay:leftOverSpace(node.node,node.from,node.to)};return null});return{wrap}},exports.parser=parser,exports}