async function moduleInitFunction(require,exports={}){function cmpRange(a,b){return a.from-b.from||a.value.startSide-b.value.startSide}function lazySort(ranges){if(1<ranges.length)for(let cur,prev=ranges[0],i=1;i<ranges.length;i++){if(cur=ranges[i],0<cmpRange(prev,cur))return ranges.slice().sort(cmpRange);prev=cur}return ranges}function findSharedChunks(a,b,textDiff){let inA=new Map;for(let set of a)for(let i=0;i<set.chunk.length;i++)0>=set.chunk[i].maxPoint&&inA.set(set.chunk[i],set.chunkPos[i]);let shared=new Set;for(let set of b)for(let known,i=0;i<set.chunk.length;i++)known=inA.get(set.chunk[i]),null==known||(textDiff?textDiff.mapPos(known):known)!=set.chunkPos[i]||(null===textDiff||void 0===textDiff?void 0:textDiff.touchesRange(known,known+set.chunk[i].length))||shared.add(set.chunk[i]);return shared}function heapBubble(heap,index){for(let childIndex,cur=heap[index];;){if(childIndex=(index<<1)+1,childIndex>=heap.length)break;let child=heap[childIndex];if(childIndex+1<heap.length&&0<=child.compare(heap[childIndex+1])&&(child=heap[childIndex+1],childIndex++),0>cur.compare(child))break;heap[childIndex]=cur,heap[index]=child,index=childIndex}}function compare(a,startA,b,startB,length,comparator){a.goto(startA),b.goto(startB);let endB=startB+length,pos=startB,dPos=startB-startA;for(;;){let diff=a.to+dPos-b.to||a.endSide-b.endSide,end=0>diff?a.to+dPos:b.to,clipEnd=Math.min(end,endB);if(a.point||b.point?!(a.point&&b.point&&(a.point==b.point||a.point.eq(b.point))&&sameValues(a.activeForPoint(a.to+dPos),b.activeForPoint(b.to)))&&comparator.comparePoint(pos,clipEnd,a.point,b.point):clipEnd>pos&&!sameValues(a.active,b.active)&&comparator.compareRange(pos,clipEnd,a.active,b.active),end>endB)break;pos=end,0>=diff&&a.next(),0<=diff&&b.next()}}function sameValues(a,b){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(a[i]!=b[i]&&!a[i].eq(b[i]))return!1;return!0}function remove(array,index){for(let i=index,e=array.length-1;i<e;i++)array[i]=array[i+1];array.pop()}function insert(array,index,value){for(let i=array.length-1;i>=index;i--)array[i+1]=array[i];array[index]=value}function findMinIndex(value,array){let found=-1,foundPos=1e9/* Far */;for(let i=0;i<array.length;i++)0>(array[i]-foundPos||value[i].endSide-value[found].endSide)&&(found=i,foundPos=array[i]);return found}Object.defineProperty(exports,"__esModule",{value:!0});var state=await require("@codemirror/state");/// Each range is associated with a value, which must inherit from
/// this class.
class RangeValue{/// Compare this value with another value. The default
/// implementation compares by identity.
eq(other){return this==other}/// Create a [range](#rangeset.Range) with this value.
range(from,to=from){return new Range(from,to,this)}}RangeValue.prototype.startSide=RangeValue.prototype.endSide=0,RangeValue.prototype.point=!1,RangeValue.prototype.mapMode=state.MapMode.TrackDel;/// A range associates a value with a range of positions.
class Range{/// @internal
constructor(/// The range's start position.
from,/// Its end position.
to,/// The value associated with this range.
value){this.from=from,this.to=to,this.value=value}}class Chunk{constructor(from,to,value,// Chunks are marked with the largest point that occurs
// in them (or -1 for no points), so that scans that are
// only interested in points (such as the
// heightmap-related logic) can skip range-only chunks.
maxPoint){this.from=from,this.to=to,this.value=value,this.maxPoint=maxPoint}get length(){return this.to[this.to.length-1]}// Find the index of the given position and side. Use the ranges'
// `from` pos when `end == false`, `to` when `end == true`.
findIndex(pos,side,end,startAt=0){let arr=end?this.to:this.from;for(let lo=startAt,hi=arr.length;;){if(lo==hi)return lo;let mid=lo+hi>>1,diff=arr[mid]-pos||(end?this.value[mid].endSide:this.value[mid].startSide)-side;if(mid==lo)return 0<=diff?lo:hi;0<=diff?hi=mid:lo=mid+1}}between(offset,from,to,f){for(let i=this.findIndex(from,-1e9/* Far */,!0),e=this.findIndex(to,1e9/* Far */,!1,i);i<e;i++)if(!1===f(this.from[i]+offset,this.to[i]+offset,this.value[i]))return!1}map(offset,changes){let value=[],from=[],to=[],newPos=-1,maxPoint=-1;for(let i=0;i<this.value.length;i++){let newFrom,newTo,val=this.value[i],curFrom=this.from[i]+offset,curTo=this.to[i]+offset;if(curFrom==curTo){let mapped=changes.mapPos(curFrom,val.startSide,val.mapMode);if(null==mapped)continue;if(newFrom=newTo=mapped,val.startSide!=val.endSide&&(newTo=changes.mapPos(curFrom,val.endSide),newTo<newFrom))continue}else if(newFrom=changes.mapPos(curFrom,val.startSide),newTo=changes.mapPos(curTo,val.endSide),newFrom>newTo||newFrom==newTo&&0<val.startSide&&0>=val.endSide)continue;0>(newTo-newFrom||val.endSide-val.startSide)||(0>newPos&&(newPos=newFrom),val.point&&(maxPoint=Math.max(maxPoint,newTo-newFrom)),value.push(val),from.push(newFrom-newPos),to.push(newTo-newPos))}return{mapped:value.length?new Chunk(from,to,value,maxPoint):null,pos:newPos}}}/// A range set stores a collection of [ranges](#rangeset.Range) in a
/// way that makes them efficient to [map](#rangeset.RangeSet.map) and
/// [update](#rangeset.RangeSet.update). This is an immutable data
/// structure.
class RangeSet{/// @internal
constructor(/// @internal
chunkPos,/// @internal
chunk,/// @internal
nextLayer=RangeSet.empty,/// @internal
maxPoint){this.chunkPos=chunkPos,this.chunk=chunk,this.nextLayer=nextLayer,this.maxPoint=maxPoint}/// @internal
get length(){let last=this.chunk.length-1;return 0>last?0:Math.max(this.chunkEnd(last),this.nextLayer.length)}/// The number of ranges in the set.
get size(){if(this.isEmpty)return 0;let size=this.nextLayer.size;for(let chunk of this.chunk)size+=chunk.value.length;return size}/// @internal
chunkEnd(index){return this.chunkPos[index]+this.chunk[index].length}/// Update the range set, optionally adding new ranges or filtering
/// out existing ones.
///
/// (The extra type parameter is just there as a kludge to work
/// around TypeScript variance issues that prevented `RangeSet<X>`
/// from being a subtype of `RangeSet<Y>` when `X` is a subtype of
/// `Y`.)
update(updateSpec){let{add=[],sort=!1,filterFrom=0,filterTo=this.length}=updateSpec,filter=updateSpec.filter;if(0==add.length&&!filter)return this;if(sort&&add.slice().sort(cmpRange),this.isEmpty)return add.length?RangeSet.of(add):this;let cur=new LayerCursor(this,null,-1).goto(0),i=0,spill=[],builder=new RangeSetBuilder;for(;cur.value||i<add.length;)if(i<add.length&&0<=(cur.from-add[i].from||cur.startSide-add[i].value.startSide)){let range=add[i++];builder.addInner(range.from,range.to,range.value)||spill.push(range)}else 1==cur.rangeIndex&&cur.chunkIndex<this.chunk.length&&(i==add.length||this.chunkEnd(cur.chunkIndex)<add[i].from)&&(!filter||filterFrom>this.chunkEnd(cur.chunkIndex)||filterTo<this.chunkPos[cur.chunkIndex])&&builder.addChunk(this.chunkPos[cur.chunkIndex],this.chunk[cur.chunkIndex])?cur.nextChunk():((!filter||filterFrom>cur.to||filterTo<cur.from||filter(cur.from,cur.to,cur.value))&&!builder.addInner(cur.from,cur.to,cur.value)&&spill.push(new Range(cur.from,cur.to,cur.value)),cur.next());return builder.finishInner(this.nextLayer.isEmpty&&!spill.length?RangeSet.empty:this.nextLayer.update({add:spill,filter,filterFrom,filterTo}))}/// Map this range set through a set of changes, return the new set.
map(changes){if(0==changes.length||this.isEmpty)return this;let chunks=[],chunkPos=[],maxPoint=-1;for(let i=0;i<this.chunk.length;i++){let start=this.chunkPos[i],chunk=this.chunk[i],touch=changes.touchesRange(start,start+chunk.length);if(!1===touch)maxPoint=Math.max(maxPoint,chunk.maxPoint),chunks.push(chunk),chunkPos.push(changes.mapPos(start));else if(!0===touch){let{mapped,pos}=chunk.map(start,changes);mapped&&(maxPoint=Math.max(maxPoint,mapped.maxPoint),chunks.push(mapped),chunkPos.push(pos))}}let next=this.nextLayer.map(changes);return 0==chunks.length?next:new RangeSet(chunkPos,chunks,next,maxPoint)}/// Iterate over the ranges that touch the region `from` to `to`,
/// calling `f` for each. There is no guarantee that the ranges will
/// be reported in any specific order. When the callback returns
/// `false`, iteration stops.
between(from,to,f){if(!this.isEmpty){for(let i=0;i<this.chunk.length;i++){let start=this.chunkPos[i],chunk=this.chunk[i];if(to>=start&&from<=start+chunk.length&&!1===chunk.between(start,from-start,to-start,f))return}this.nextLayer.between(from,to,f)}}/// Iterate over the ranges in this set, in order, including all
/// ranges that end at or after `from`.
iter(from=0){return HeapCursor.from([this]).goto(from)}/// @internal
get isEmpty(){return this.nextLayer==this}/// Iterate over the ranges in a collection of sets, in order,
/// starting from `from`.
static iter(sets,from=0){return HeapCursor.from(sets).goto(from)}/// Iterate over two groups of sets, calling methods on `comparator`
/// to notify it of possible differences.
static compare(oldSets,newSets,/// This indicates how the underlying data changed between these
/// ranges, and is needed to synchronize the iteration. `from` and
/// `to` are coordinates in the _new_ space, after these changes.
textDiff,comparator,/// Can be used to ignore all non-point ranges, and points below
/// the given size. When -1, all ranges are compared.
minPointSize=-1){let a=oldSets.filter(set=>0<set.maxPoint||!set.isEmpty&&set.maxPoint>=minPointSize),b=newSets.filter(set=>0<set.maxPoint||!set.isEmpty&&set.maxPoint>=minPointSize),sharedChunks=findSharedChunks(a,b,textDiff),sideA=new SpanCursor(a,sharedChunks,minPointSize),sideB=new SpanCursor(b,sharedChunks,minPointSize);textDiff.iterGaps((fromA,fromB,length)=>compare(sideA,fromA,sideB,fromB,length,comparator)),textDiff.empty&&0==textDiff.length&&compare(sideA,0,sideB,0,0,comparator)}/// Compare the contents of two groups of range sets, returning true
/// if they are equivalent in the given range.
static eq(oldSets,newSets,from=0,to){null==to&&(to=1e9/* Far */);let a=oldSets.filter(set=>!set.isEmpty&&0>newSets.indexOf(set)),b=newSets.filter(set=>!set.isEmpty&&0>oldSets.indexOf(set));if(a.length!=b.length)return!1;if(!a.length)return!0;let sharedChunks=findSharedChunks(a,b),sideA=new SpanCursor(a,sharedChunks,0).goto(from),sideB=new SpanCursor(b,sharedChunks,0).goto(from);for(;;){if(sideA.to!=sideB.to||!sameValues(sideA.active,sideB.active)||sideA.point&&(!sideB.point||!sideA.point.eq(sideB.point)))return!1;if(sideA.to>to)return!0;sideA.next(),sideB.next()}}/// Iterate over a group of range sets at the same time, notifying
/// the iterator about the ranges covering every given piece of
/// content. Returns the open count (see
/// [`SpanIterator.span`](#rangeset.SpanIterator.span)) at the end
/// of the iteration.
static spans(sets,from,to,iterator,/// When given and greater than -1, only points of at least this
/// size are taken into account.
minPointSize=-1){var _a;let cursor=new SpanCursor(sets,null,minPointSize,null===(_a=iterator.filterPoint)||void 0===_a?void 0:_a.bind(iterator)).goto(from),pos=from,open=cursor.openStart;for(;;){let curTo=Math.min(cursor.to,to);if(cursor.point?(iterator.point(pos,curTo,cursor.point,cursor.activeForPoint(cursor.to),open),open=cursor.openEnd(curTo)+(cursor.to>curTo?1:0)):curTo>pos&&(iterator.span(pos,curTo,cursor.active,open),open=cursor.openEnd(curTo)),cursor.to>to)break;pos=cursor.to,cursor.next()}return open}/// Create a range set for the given range or array of ranges. By
/// default, this expects the ranges to be _sorted_ (by start
/// position and, if two start at the same position,
/// `value.startSide`). You can pass `true` as second argument to
/// cause the method to sort them.
static of(ranges,sort=!1){let build=new RangeSetBuilder;for(let range of ranges instanceof Range?[ranges]:sort?lazySort(ranges):ranges)build.add(range.from,range.to,range.value);return build.finish()}}/// The empty set of ranges.
RangeSet.empty=new RangeSet([],[],null,-1),RangeSet.empty.nextLayer=RangeSet.empty;/// A range set builder is a data structure that helps build up a
/// [range set](#rangeset.RangeSet) directly, without first allocating
/// an array of [`Range`](#rangeset.Range) objects.
class RangeSetBuilder{/// Create an empty builder.
constructor(){this.chunks=[],this.chunkPos=[],this.chunkStart=-1,this.last=null,this.lastFrom=-1e9/* Far */,this.lastTo=-1e9/* Far */,this.from=[],this.to=[],this.value=[],this.maxPoint=-1,this.setMaxPoint=-1,this.nextLayer=null}finishChunk(newArrays){this.chunks.push(new Chunk(this.from,this.to,this.value,this.maxPoint)),this.chunkPos.push(this.chunkStart),this.chunkStart=-1,this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint),this.maxPoint=-1,newArrays&&(this.from=[],this.to=[],this.value=[])}/// Add a range. Ranges should be added in sorted (by `from` and
/// `value.startSide`) order.
add(from,to,value){this.addInner(from,to,value)||(this.nextLayer||(this.nextLayer=new RangeSetBuilder)).add(from,to,value)}/// @internal
addInner(from,to,value){let diff=from-this.lastTo||value.startSide-this.last.endSide;if(0>=diff&&0>(from-this.lastFrom||value.startSide-this.last.startSide))throw new Error("Ranges must be added sorted by `from` position and `startSide`");return!(0>diff)&&(250==this.from.length/* ChunkSize */&&this.finishChunk(!0),0>this.chunkStart&&(this.chunkStart=from),this.from.push(from-this.chunkStart),this.to.push(to-this.chunkStart),this.last=value,this.lastFrom=from,this.lastTo=to,this.value.push(value),value.point&&(this.maxPoint=Math.max(this.maxPoint,to-from)),!0)}/// @internal
addChunk(from,chunk){if(0>(from-this.lastTo||chunk.value[0].startSide-this.last.endSide))return!1;this.from.length&&this.finishChunk(!0),this.setMaxPoint=Math.max(this.setMaxPoint,chunk.maxPoint),this.chunks.push(chunk),this.chunkPos.push(from);let last=chunk.value.length-1;return this.last=chunk.value[last],this.lastFrom=chunk.from[last]+from,this.lastTo=chunk.to[last]+from,!0}/// Finish the range set. Returns the new set. The builder can't be
/// used anymore after this has been called.
finish(){return this.finishInner(RangeSet.empty)}/// @internal
finishInner(next){if(this.from.length&&this.finishChunk(!1),0==this.chunks.length)return next;let result=new RangeSet(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(next):next,this.setMaxPoint);// Make sure further `add` calls produce errors
return this.from=null,result}}class LayerCursor{constructor(layer,skip,minPoint,rank=0){this.layer=layer,this.skip=skip,this.minPoint=minPoint,this.rank=rank}get startSide(){return this.value?this.value.startSide:0}get endSide(){return this.value?this.value.endSide:0}goto(pos,side=-1e9/* Far */){return this.chunkIndex=this.rangeIndex=0,this.gotoInner(pos,side,!1),this}gotoInner(pos,side,forward){for(;this.chunkIndex<this.layer.chunk.length;){let next=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(next)||this.layer.chunkEnd(this.chunkIndex)<pos||next.maxPoint<this.minPoint))break;this.chunkIndex++,forward=!1}if(this.chunkIndex<this.layer.chunk.length){let rangeIndex=this.layer.chunk[this.chunkIndex].findIndex(pos-this.layer.chunkPos[this.chunkIndex],side,!0);(!forward||this.rangeIndex<rangeIndex)&&this.setRangeIndex(rangeIndex)}this.next()}forward(pos,side){0>(this.to-pos||this.endSide-side)&&this.gotoInner(pos,side,!0)}next(){for(;;)if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1e9/* Far */,this.value=null;break}else{let chunkPos=this.layer.chunkPos[this.chunkIndex],chunk=this.layer.chunk[this.chunkIndex],from=chunkPos+chunk.from[this.rangeIndex];if(this.from=from,this.to=chunkPos+chunk.to[this.rangeIndex],this.value=chunk.value[this.rangeIndex],this.setRangeIndex(this.rangeIndex+1),0>this.minPoint||this.value.point&&this.to-this.from>=this.minPoint)break}}setRangeIndex(index){if(index==this.layer.chunk[this.chunkIndex].value.length){if(this.chunkIndex++,this.skip)for(;this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++;this.rangeIndex=0}else this.rangeIndex=index}nextChunk(){this.chunkIndex++,this.rangeIndex=0,this.next()}compare(other){return this.from-other.from||this.startSide-other.startSide||this.to-other.to||this.endSide-other.endSide}}class HeapCursor{constructor(heap){this.heap=heap}static from(sets,skip=null,minPoint=-1){let heap=[];for(let i=0;i<sets.length;i++)for(let cur=sets[i];!cur.isEmpty;cur=cur.nextLayer)cur.maxPoint>=minPoint&&heap.push(new LayerCursor(cur,skip,minPoint,i));return 1==heap.length?heap[0]:new HeapCursor(heap)}get startSide(){return this.value?this.value.startSide:0}goto(pos,side=-1e9/* Far */){for(let cur of this.heap)cur.goto(pos,side);for(let i=this.heap.length>>1;0<=i;i--)heapBubble(this.heap,i);return this.next(),this}forward(pos,side){for(let cur of this.heap)cur.forward(pos,side);for(let i=this.heap.length>>1;0<=i;i--)heapBubble(this.heap,i);0>(this.to-pos||this.value.endSide-side)&&this.next()}next(){if(0==this.heap.length)this.from=this.to=1e9/* Far */,this.value=null,this.rank=-1;else{let top=this.heap[0];this.from=top.from,this.to=top.to,this.value=top.value,this.rank=top.rank,top.value&&top.next(),heapBubble(this.heap,0)}}}class SpanCursor{constructor(sets,skip,minPoint,filterPoint=()=>!0){this.minPoint=minPoint,this.filterPoint=filterPoint,this.active=[],this.activeTo=[],this.activeRank=[],this.minActive=-1,this.point=null,this.pointFrom=0,this.pointRank=0,this.to=-1e9/* Far */,this.endSide=0,this.openStart=-1,this.cursor=HeapCursor.from(sets,skip,minPoint)}goto(pos,side=-1e9/* Far */){return this.cursor.goto(pos,side),this.active.length=this.activeTo.length=this.activeRank.length=0,this.minActive=-1,this.to=pos,this.endSide=side,this.openStart=-1,this.next(),this}forward(pos,side){for(;-1<this.minActive&&0>(this.activeTo[this.minActive]-pos||this.active[this.minActive].endSide-side);)this.removeActive(this.minActive);this.cursor.forward(pos,side)}removeActive(index){remove(this.active,index),remove(this.activeTo,index),remove(this.activeRank,index),this.minActive=findMinIndex(this.active,this.activeTo)}addActive(trackOpen){let i=0,{value,to,rank}=this.cursor;for(;i<this.activeRank.length&&this.activeRank[i]<=rank;)i++;insert(this.active,i,value),insert(this.activeTo,i,to),insert(this.activeRank,i,rank),trackOpen&&insert(trackOpen,i,this.cursor.from),this.minActive=findMinIndex(this.active,this.activeTo)}// After calling this, if `this.point` != null, the next range is a
// point. Otherwise, it's a regular range, covered by `this.active`.
next(){let from=this.to,wasPoint=this.point;this.point=null;let trackOpen=0>this.openStart?[]:null,trackExtra=0;for(;;){let a=this.minActive;if(-1<a&&0>(this.activeTo[a]-this.cursor.from||this.active[a].endSide-this.cursor.startSide)){if(this.activeTo[a]>from){this.to=this.activeTo[a],this.endSide=this.active[a].endSide;break}this.removeActive(a),trackOpen&&remove(trackOpen,a)}else if(!this.cursor.value){this.to=this.endSide=1e9/* Far */;break}else if(this.cursor.from>from){this.to=this.cursor.from,this.endSide=this.cursor.startSide;break}else{let nextVal=this.cursor.value;if(!nextVal.point)this.addActive(trackOpen),this.cursor.next();else if(wasPoint&&this.cursor.to==this.to&&this.cursor.from<this.cursor.to)this.cursor.next();else if(!this.filterPoint(this.cursor.from,this.cursor.to,this.cursor.value,this.cursor.rank))this.cursor.next();else{this.point=nextVal,this.pointFrom=this.cursor.from,this.pointRank=this.cursor.rank,this.to=this.cursor.to,this.endSide=nextVal.endSide,this.cursor.from<from&&(trackExtra=1),this.cursor.next(),this.to>from&&this.forward(this.to,this.endSide);break}}}if(trackOpen){let openStart=0;for(;openStart<trackOpen.length&&trackOpen[openStart]<from;)openStart++;this.openStart=openStart+trackExtra}}activeForPoint(to){if(!this.active.length)return this.active;let active=[];for(let i=this.active.length-1;0<=i&&!(this.activeRank[i]<this.pointRank);i--)(this.activeTo[i]>to||this.activeTo[i]==to&&this.active[i].endSide>=this.point.endSide)&&active.push(this.active[i]);return active.reverse()}openEnd(to){let open=0;for(let i=this.activeTo.length-1;0<=i&&this.activeTo[i]>to;i--)open++;return open}}return exports.Range=Range,exports.RangeSet=RangeSet,exports.RangeSetBuilder=RangeSetBuilder,exports.RangeValue=RangeValue,exports}