async function moduleInitFunction(require,exports={}){function isExtendingChar(code){for(let i=1;i<extend.length;i+=2)if(extend[i]>code)return extend[i-1]<=code;return!1}function isRegionalIndicator(code){return 127462<=code&&127487>=code}/// Returns a next grapheme cluster break _after_ (not equal to)
/// `pos`, if `forward` is true, or before otherwise. Returns `pos`
/// itself if no further cluster break is available in the string.
/// Moves across surrogate pairs, extending characters, characters
/// joined with zero-width joiners, and flag emoji.
function findClusterBreak(str,pos,forward=!0){return(forward?nextClusterBreak:prevClusterBreak)(str,pos)}function nextClusterBreak(str,pos){if(pos==str.length)return pos;// If pos is in the middle of a surrogate pair, move to its start
pos&&surrogateLow(str.charCodeAt(pos))&&surrogateHigh(str.charCodeAt(pos-1))&&pos--;let prev=codePointAt(str,pos);for(pos+=codePointSize(prev);pos<str.length;){let next=codePointAt(str,pos);if(prev==ZWJ||next==ZWJ||isExtendingChar(next))pos+=codePointSize(next),prev=next;else if(isRegionalIndicator(next)){let countBefore=0,i=pos-2;for(;0<=i&&isRegionalIndicator(codePointAt(str,i));)countBefore++,i-=2;if(0==countBefore%2)break;else pos+=2}else break}return pos}function prevClusterBreak(str,pos){for(;0<pos;){let found=nextClusterBreak(str,pos-2);if(found<pos)return found;pos--}return 0}function surrogateLow(ch){return 56320<=ch&&57344>ch}function surrogateHigh(ch){return 55296<=ch&&56320>ch}/// Find the code point at the given position in a string (like the
/// [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)
/// string method).
function codePointAt(str,pos){let code0=str.charCodeAt(pos);if(!surrogateHigh(code0)||pos+1==str.length)return code0;let code1=str.charCodeAt(pos+1);return surrogateLow(code1)?(code0-55296<<10)+(code1-56320)+65536:code0}/// Given a Unicode codepoint, return the JavaScript string that
/// respresents it (like
/// [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).
/// The first character that takes up two positions in a JavaScript
/// string. It is often useful to compare with this after calling
/// `codePointAt`, to figure out whether your character takes up 1 or
/// 2 index positions.
function codePointSize(code){return 65536>code?1:2}/// Count the column position at the given offset into the string,
/// taking extending characters and tab size into account.
function textLength(text){let length=-1;for(let line of text)length+=line.length+1;return length}function appendText(text,target,from=0,to=1e9){for(let pos=0,i=0,first=!0;i<text.length&&pos<=to;i++){let line=text[i],end=pos+line.length;end>=from&&(end>to&&(line=line.slice(0,to-pos)),pos<from&&(line=line.slice(from-pos)),first?(target[target.length-1]+=line,first=!1):target.push(line)),pos=end+1}return target}function sliceText(text,from,to){return appendText(text,[""],from,to)}Object.defineProperty(exports,"__esModule",{value:!0});// Compressed representation of the Grapheme_Cluster_Break=Extend
// information from
// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.
// Each pair of elements represents a range, as an offet from the
// previous range and a length. Numbers are in base-36, with the empty
// string being a shorthand for 1.
let extend=["lc","34","7n","7","7b","19","","","","2","","2","","","20","b","1c","l","g","","2t","7","2","6","2","2","","4","z","","u","r","2j","b","1m","9","9","","o","4","","9","","3","","5","17","3","3b","f","","w","1j","","","","4","8","4","","3","7","a","2","t","","1m","","","","2","4","8","","9","","a","2","q","","2","2","1l","","4","2","4","2","2","3","3","","u","2","3","","b","2","1l","","4","5","","2","4","","k","2","m","6","","","1m","","","2","","4","8","","7","3","a","2","u","","1n","","","","c","","9","","14","","3","","1l","3","5","3","","4","7","2","b","2","t","","1m","","2","","2","","3","","5","2","7","2","b","2","s","2","1l","2","","","2","4","8","","9","","a","2","t","","20","","4","","2","3","","","8","","29","","2","7","c","8","2q","","2","9","b","6","22","2","r","","","","","","1j","e","","5","","2","5","b","","10","9","","2u","4","","6","","2","2","2","p","2","4","3","g","4","d","","2","2","6","","f","","jj","3","qa","3","t","3","t","2","u","2","1s","2","","7","8","","2","b","9","","19","3","3b","2","y","","3a","3","4","2","9","","6","3","63","2","2","","1m","","","7","","","","","2","8","6","a","2","","1c","h","1r","4","1c","7","","","5","","14","9","c","2","w","4","2","2","","3","1k","","","2","3","","","3","1m","8","2","2","48","3","","d","","7","4","","6","","3","2","5i","1m","","5","ek","","5f","x","2da","3","3x","","2o","w","fe","6","2x","2","n9w","4","","a","w","2","28","2","7k","","3","","4","","p","2","5","","47","2","q","i","d","","12","8","p","b","1a","3","1c","","2","4","2","2","13","","1v","6","2","2","2","2","c","","8","","1b","","1f","","","3","2","2","5","2","","","16","2","8","","6m","","2","","4","","fn4","","kh","g","g","g","a6","2","gt","","6a","","45","5","1ae","3","","2","5","4","14","3","4","","4l","2","fx","4","ar","2","49","b","4w","","1i","f","1k","3","1d","4","2","2","1x","3","10","5","","8","1q","","c","2","1g","9","a","4","2","","2n","3","2","","","2","6","","4g","","3","8","l","2","1l","2","","","","","m","","e","7","3","5","5f","8","2","3","","","n","","29","","2","6","","","2","","","2","","2","6j","","2","4","6","2","","2","r","2","2d","8","2","","","2","2y","","","","2","6","","","2t","3","2","4","","5","77","9","","2","6t","","a","2","","","4","","40","4","2","2","4","","w","a","14","6","2","4","8","","9","6","2","3","1a","d","","2","ba","7","","6","","","2a","m","2","7","","2","","2","3e","6","3","","","2","","7","","","20","2","3","","","","9n","2","f0b","5","1n","7","t4","","1r","4","29","","f5k","2","43q","","","3","4","5","8","8","2","7","u","4","44","3","1iz","1j","4","1e","8","","e","","m","5","","f","11s","7","","h","2","7","","2","","5","79","7","c5","4","15s","7","31","7","240","5","gx7k","2o","3k","6o"].map(s=>s?parseInt(s,36):1);// Convert offsets into absolute values
for(let i=1;i<extend.length;i++)extend[i]+=extend[i-1];const ZWJ=8205;/// The data structure for documents.
class Text{/// @internal
constructor(){}/// Get the line description around the given position.
lineAt(pos){if(0>pos||pos>this.length)throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);return this.lineInner(pos,!1,1,0)}/// Get the description for the given (1-based) line number.
line(n){if(1>n||n>this.lines)throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);return this.lineInner(n,!0,1,0)}/// Replace a range of the text with the given content.
replace(from,to,text){let parts=[];return this.decompose(0,from,parts,2/* To */),text.length&&text.decompose(0,text.length,parts,3/* To */),this.decompose(to,this.length,parts,1/* From */),TextNode.from(parts,this.length-(to-from)+text.length)}/// Append another document to this one.
append(other){return this.replace(this.length,this.length,other)}/// Retrieve the text between the given points.
slice(from,to=this.length){let parts=[];return this.decompose(from,to,parts,0),TextNode.from(parts,to-from)}/// Test whether this text is equal to another instance.
eq(other){if(other==this)return!0;if(other.length!=this.length||other.lines!=this.lines)return!1;let start=this.scanIdentical(other,1),end=this.length-this.scanIdentical(other,-1),a=new RawTextCursor(this),b=new RawTextCursor(other);for(let skip=start,pos=start;;){if(a.next(skip),b.next(skip),skip=0,a.lineBreak!=b.lineBreak||a.done!=b.done||a.value!=b.value)return!1;if(pos+=a.value.length,a.done||pos>=end)return!0}}/// Iterate over the text. When `dir` is `-1`, iteration happens
/// from end to start. This will return lines and the breaks between
/// them as separate strings, and for long lines, might split lines
/// themselves into multiple chunks as well.
iter(dir=1){return new RawTextCursor(this,dir)}/// Iterate over a range of the text. When `from` > `to`, the
/// iterator will run in reverse.
iterRange(from,to=this.length){return new PartialTextCursor(this,from,to)}/// Return a cursor that iterates over the given range of lines,
/// _without_ returning the line breaks between, and yielding empty
/// strings for empty lines.
///
/// When `from` and `to` are given, they should be 1-based line numbers.
iterLines(from,to){let inner;if(null==from)inner=this.iter();else{null==to&&(to=this.lines+1);let start=this.line(from).from;inner=this.iterRange(start,Math.max(start,to==this.lines+1?this.length:1>=to?0:this.line(to-1).to))}return new LineCursor(inner)}/// @internal
toString(){return this.sliceString(0)}/// Convert the document to an array of lines (which can be
/// deserialized again via [`Text.of`](#text.Text^of)).
toJSON(){let lines=[];return this.flatten(lines),lines}/// Create a `Text` instance for the given array of lines.
static of(text){if(0==text.length)throw new RangeError("A document must have at least one line");return 1!=text.length||text[0]?32>=text.length/* Branch */?new TextLeaf(text):TextNode.from(TextLeaf.split(text,[])):Text.empty}}// Leaves store an array of line strings. There are always line breaks
// between these strings. Leaves are limited in size and have to be
// contained in TextNode instances for bigger documents.
class TextLeaf extends Text{constructor(text,length=textLength(text)){super(),this.text=text,this.length=length}get lines(){return this.text.length}get children(){return null}lineInner(target,isLine,line,offset){for(let i=0;;i++){let string=this.text[i],end=offset+string.length;if((isLine?line:end)>=target)return new Line(offset,end,line,string);offset=end+1,line++}}decompose(from,to,target,open){let text=0>=from&&to>=this.length?this:new TextLeaf(sliceText(this.text,from,to),Math.min(to,this.length)-Math.max(0,from));if(1&open/* From */){let prev=target.pop(),joined=appendText(text.text,prev.text.slice(),0,text.length);if(32>=joined.length/* Branch */)target.push(new TextLeaf(joined,prev.length+text.length));else{let mid=joined.length>>1;target.push(new TextLeaf(joined.slice(0,mid)),new TextLeaf(joined.slice(mid)))}}else target.push(text)}replace(from,to,text){if(!(text instanceof TextLeaf))return super.replace(from,to,text);let lines=appendText(this.text,appendText(text.text,sliceText(this.text,0,from)),to),newLen=this.length+text.length-(to-from);return 32>=lines.length/* Branch */?new TextLeaf(lines,newLen):TextNode.from(TextLeaf.split(lines,[]),newLen)}sliceString(from,to=this.length,lineSep="\n"){let result="";for(let pos=0,i=0;pos<=to&&i<this.text.length;i++){let line=this.text[i],end=pos+line.length;pos>from&&i&&(result+=lineSep),from<end&&to>pos&&(result+=line.slice(Math.max(0,from-pos),to-pos)),pos=end+1}return result}flatten(target){for(let line of this.text)target.push(line)}scanIdentical(){return 0}static split(text,target){let part=[],len=-1;for(let line of text)part.push(line),len+=line.length+1,32==part.length/* Branch */&&(target.push(new TextLeaf(part,len)),part=[],len=-1);return-1<len&&target.push(new TextLeaf(part,len)),target}}// Nodes provide the tree structure of the `Text` type. They store a
// number of other nodes or leaves, taking care to balance themselves
// on changes. There are implied line breaks _between_ the children of
// a node (but not before the first or after the last child).
class TextNode extends Text{constructor(children,length){super(),this.children=children,this.length=length,this.lines=0;for(let child of children)this.lines+=child.lines}lineInner(target,isLine,line,offset){for(let i=0;;i++){let child=this.children[i],end=offset+child.length,endLine=line+child.lines-1;if((isLine?endLine:end)>=target)return child.lineInner(target,isLine,line,offset);offset=end+1,line=endLine+1}}decompose(from,to,target,open){for(let i=0,pos=0;pos<=to&&i<this.children.length;i++){let child=this.children[i],end=pos+child.length;if(from<=end&&to>=pos){let childOpen=open&((pos<=from?1/* From */:0)|(end>=to?2/* To */:0));pos>=from&&end<=to&&!childOpen?target.push(child):child.decompose(from-pos,to-pos,target,childOpen)}pos=end+1}}replace(from,to,text){if(text.lines<this.lines)for(let i=0,pos=0;i<this.children.length;i++){let child=this.children[i],end=pos+child.length;// Fast path: if the change only affects one child and the
// child's size remains in the acceptable range, only update
// that child
if(from>=pos&&to<=end){let updated=child.replace(from-pos,to-pos,text),totalLines=this.lines-child.lines+updated.lines;if(updated.lines<totalLines>>4&&updated.lines>totalLines>>6){let copy=this.children.slice();return copy[i]=updated,new TextNode(copy,this.length-(to-from)+text.length)}return super.replace(pos,end,updated)}pos=end+1}return super.replace(from,to,text)}sliceString(from,to=this.length,lineSep="\n"){let result="";for(let i=0,pos=0;i<this.children.length&&pos<=to;i++){let child=this.children[i],end=pos+child.length;pos>from&&i&&(result+=lineSep),from<end&&to>pos&&(result+=child.sliceString(from-pos,to-pos,lineSep)),pos=end+1}return result}flatten(target){for(let child of this.children)child.flatten(target)}scanIdentical(other,dir){if(!(other instanceof TextNode))return 0;let length=0,[iA,iB,eA,eB]=0<dir?[0,0,this.children.length,other.children.length]:[this.children.length-1,other.children.length-1,-1,-1];for(;;iA+=dir,iB+=dir){if(iA==eA||iB==eB)return length;let chA=this.children[iA],chB=other.children[iB];if(chA!=chB)return length+chA.scanIdentical(chB,dir);length+=chA.length+1}}static from(children,length=children.reduce((l,ch)=>l+ch.length+1,-1)){function add(child){let last;if(child.lines>maxChunk&&child instanceof TextNode)for(let node of child.children)add(node);else child.lines>minChunk&&(currentLines>minChunk||!currentLines)?(flush(),chunked.push(child)):child instanceof TextLeaf&&currentLines&&(last=currentChunk[currentChunk.length-1])instanceof TextLeaf&&32>=child.lines+last.lines/* Branch */?(currentLines+=child.lines,currentLen+=child.length+1,currentChunk[currentChunk.length-1]=new TextLeaf(last.text.concat(child.text),last.length+1+child.length)):(currentLines+child.lines>chunk&&flush(),currentLines+=child.lines,currentLen+=child.length+1,currentChunk.push(child))}function flush(){0==currentLines||(chunked.push(1==currentChunk.length?currentChunk[0]:TextNode.from(currentChunk,currentLen)),currentLen=-1,currentLines=currentChunk.length=0)}let lines=0;for(let ch of children)lines+=ch.lines;if(32>lines/* Branch */){let flat=[];for(let ch of children)ch.flatten(flat);return new TextLeaf(flat,length)}let chunk=Math.max(32/* Branch */,lines>>5/* BranchShift */),maxChunk=chunk<<1,minChunk=chunk>>1,chunked=[],currentLines=0,currentLen=-1,currentChunk=[];for(let child of children)add(child);return flush(),1==chunked.length?chunked[0]:new TextNode(chunked,length)}}Text.empty=new TextLeaf([""],0);class RawTextCursor{constructor(text,dir=1){this.dir=dir,this.done=!1,this.lineBreak=!1,this.value="",this.nodes=[text],this.offsets=[0<dir?1:(text instanceof TextLeaf?text.text.length:text.children.length)<<1]}nextInner(skip,dir){for(this.done=this.lineBreak=!1;;){let last=this.nodes.length-1,top=this.nodes[last],offsetValue=this.offsets[last],offset=offsetValue>>1,size=top instanceof TextLeaf?top.text.length:top.children.length;if(offset==(0<dir?size:0)){if(0==last)return this.done=!0,this.value="",this;0<dir&&this.offsets[last-1]++,this.nodes.pop(),this.offsets.pop()}else if((1&offsetValue)==(0<dir?0:1)){if(this.offsets[last]+=dir,0==skip)return this.lineBreak=!0,this.value="\n",this;skip--}else if(top instanceof TextLeaf){// Move to the next string
let next=top.text[offset+(0>dir?-1:0)];if(this.offsets[last]+=dir,next.length>Math.max(0,skip))return this.value=0==skip?next:0<dir?next.slice(skip):next.slice(0,next.length-skip),this;skip-=next.length}else{let next=top.children[offset+(0>dir?-1:0)];skip>next.length?(skip-=next.length,this.offsets[last]+=dir):(0>dir&&this.offsets[last]--,this.nodes.push(next),this.offsets.push(0<dir?1:(next instanceof TextLeaf?next.text.length:next.children.length)<<1))}}}next(skip=0){return 0>skip&&(this.nextInner(-skip,-this.dir),skip=this.value.length),this.nextInner(skip,this.dir)}}class PartialTextCursor{constructor(text,start,end){this.value="",this.done=!1,this.cursor=new RawTextCursor(text,start>end?-1:1),this.pos=start>end?text.length:0,this.from=Math.min(start,end),this.to=Math.max(start,end)}nextInner(skip,dir){if(0>dir?this.pos<=this.from:this.pos>=this.to)return this.value="",this.done=!0,this;skip+=Math.max(0,0>dir?this.pos-this.to:this.from-this.pos);let limit=0>dir?this.pos-this.from:this.to-this.pos;skip>limit&&(skip=limit),limit-=skip;let{value}=this.cursor.next(skip);return this.pos+=(value.length+skip)*dir,this.value=value.length<=limit?value:0>dir?value.slice(value.length-limit):value.slice(0,limit),this.done=!this.value,this}next(skip=0){return 0>skip?skip=Math.max(skip,this.from-this.pos):0<skip&&(skip=Math.min(skip,this.to-this.pos)),this.nextInner(skip,this.cursor.dir)}get lineBreak(){return this.cursor.lineBreak&&""!=this.value}}class LineCursor{constructor(inner){this.inner=inner,this.afterBreak=!0,this.value="",this.done=!1}next(skip=0){let{done,lineBreak,value}=this.inner.next(skip);return done?(this.done=!0,this.value=""):lineBreak?this.afterBreak?this.value="":(this.afterBreak=!0,this.next()):(this.value=value,this.afterBreak=!1),this}get lineBreak(){return!1}}"undefined"!=typeof Symbol&&(Text.prototype[Symbol.iterator]=function(){return this.iter()},RawTextCursor.prototype[Symbol.iterator]=PartialTextCursor.prototype[Symbol.iterator]=LineCursor.prototype[Symbol.iterator]=function(){return this});/// This type describes a line in the document. It is created
/// on-demand when lines are [queried](#text.Text.lineAt).
class Line{/// @internal
constructor(/// The position of the start of the line.
from,/// The position at the end of the line (_before_ the line break,
/// or at the end of document for the last line).
to,/// This line's line number (1-based).
number,/// The line's content.
text){this.from=from,this.to=to,this.number=number,this.text=text}/// The length of the line (not including any line break after it).
get length(){return this.to-this.from}}return exports.Line=Line,exports.Text=Text,exports.codePointAt=codePointAt,exports.codePointSize=codePointSize,exports.countColumn=function(string,tabSize,to=string.length){let n=0;for(let i=0;i<to;)9==string.charCodeAt(i)?(n+=tabSize-n%tabSize,i++):(n++,i=findClusterBreak(string,i));return n}/// Find the offset that corresponds to the given column position in a
/// string, taking extending characters and tab size into account. By
/// default, the string length is returned when it is too short to
/// reach the column. Pass `strict` true to make it return -1 in that
/// situation.
,exports.findClusterBreak=findClusterBreak,exports.findColumn=function(string,col,tabSize,strict){for(let i=0,n=0;;){if(n>=col)return i;if(i==string.length)break;n+=9==string.charCodeAt(i)?tabSize-n%tabSize:1,i=findClusterBreak(string,i)}return!0===strict?-1:string.length},exports.fromCodePoint=function(code){return 65535>=code?String.fromCharCode(code):(code-=65536,String.fromCharCode((code>>10)+55296,(1023&code)+56320))},exports}