async function moduleInitFunction(require,exports={}){// Counts the column offset in a string, taking tabs into account.
// Used mostly to find indentation.
function countCol(string,end,tabSize,startIndex=0,startValue=0){null==end&&(end=string.search(/[^\s\u00a0]/),-1==end&&(end=string.length));let n=startValue;for(let i=startIndex;i<end;i++)9==string.charCodeAt(i)?n+=tabSize-n%tabSize:n++;return n}/// Encapsulates a single line of input. Given to stream syntax code,
/// which uses it to tokenize the content.
function fullParser(spec){return{token:spec.token,blankLine:spec.blankLine||(()=>{}),startState:spec.startState||(()=>!0),copyState:spec.copyState||defaultCopyState,indent:spec.indent||(()=>null),languageData:spec.languageData||{}}}function defaultCopyState(state){if("object"!=typeof state)return state;let newState={};for(let prop in state){let val=state[prop];newState[prop]=val instanceof Array?val.slice():val}return newState}/// A [language](#language.Language) class based on a streaming
/// parser.
function findState(lang,tree,off,startPos,before){let state=off>=startPos&&off+tree.length<=before&&tree.prop(lang.stateAfter);if(state)return{state:lang.streamParser.copyState(state),pos:off+tree.length};for(let i=tree.children.length-1;0<=i;i--){let child=tree.children[i],pos=off+tree.positions[i],found=child instanceof common.Tree&&pos<before&&findState(lang,child,pos,startPos,before);if(found)return found}return null}function cutTree(lang,tree,from,to,inside){if(inside&&0>=from&&to>=tree.length)return tree;inside||tree.type!=lang.topNode||(inside=!0);for(let i=tree.children.length-1;0<=i;i--){let inner,pos=tree.positions[i]+from,child=tree.children[i];if(pos<to&&child instanceof common.Tree){if(!(inner=cutTree(lang,child,from-pos,to-pos,inside)))break;return inside?new common.Tree(tree.type,tree.children.slice(0,i).concat(inner),tree.positions.slice(0,i+1),pos+inner.length):inner}}return null}function findStartInFragments(lang,fragments,startPos,editorState){for(let f of fragments){let tree,from=f.from+(f.openStart?25:0),to=f.to-(f.openEnd?25:0),found=from<=startPos&&to>startPos&&findState(lang,f.tree,0-f.offset,startPos,to);if(found&&(tree=cutTree(lang,f.tree,startPos+f.offset,found.pos+f.offset,!1)))return{state:found.state,tree}}return{state:lang.streamParser.startState(editorState?language.getIndentUnit(editorState):4),tree:common.Tree.empty}}function readToken(token,stream,state){stream.start=stream.pos;for(let result,i=0;10>i;i++)if(result=token(stream,state),stream.pos>stream.start)return result;throw new Error("Stream parser failed to advance stream.")}function tokenID(tag){return tag?tokenTable[tag]||(tokenTable[tag]=createTokenType(tag)):0}function warnForPart(part,msg){-1<warned.indexOf(part)||(warned.push(part),console.warn(msg))}function createTokenType(tagStr){let tag=null;for(let part of tagStr.split(".")){let value=highlight.tags[part];value?"function"==typeof value?tag?tag=value(tag):warnForPart(part,`Modifier ${part} used at start of tag`):tag?warnForPart(part,`Tag ${part} used as modifier`):tag=value:warnForPart(part,`Unknown highlighting tag ${part}`)}if(!tag)return 0;let name=tagStr.replace(/ /g,"_"),type=common.NodeType.define({id:typeArray.length,name,props:[highlight.styleTags({[name]:tag})]});return typeArray.push(type),type.id}function docID(data){let type=common.NodeType.define({id:typeArray.length,name:"Document",props:[language.languageDataProp.add(()=>data)]});return typeArray.push(type),type}Object.defineProperty(exports,"__esModule",{value:!0});var common=await require("@lezer/common"),highlight=await require("@codemirror/highlight"),language=await require("@codemirror/language");class StringStream{/// @internal
constructor(/// The line.
string,tabSize,/// The current indent unit size.
indentUnit){this.string=string,this.tabSize=tabSize,this.indentUnit=indentUnit,this.pos=0,this.start=0,this.lastColumnPos=0,this.lastColumnValue=0}/// True if we are at the end of the line.
eol(){return this.pos>=this.string.length}/// True if we are at the start of the line.
sol(){return 0==this.pos}/// Get the next code unit after the current position, or undefined
/// if we're at the end of the line.
peek(){return this.string.charAt(this.pos)||void 0}/// Read the next code unit and advance `this.pos`.
next(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)}/// Match the next character against the given string, regular
/// expression, or predicate. Consume and return it if it matches.
eat(match){let ok,ch=this.string.charAt(this.pos);if(ok="string"==typeof match?ch==match:ch&&(match instanceof RegExp?match.test(ch):match(ch)),ok)return++this.pos,ch}/// Continue matching characters that match the given string,
/// regular expression, or predicate function. Return true if any
/// characters were consumed.
eatWhile(match){let start=this.pos;for(;this.eat(match););return this.pos>start}/// Consume whitespace ahead of `this.pos`. Return true if any was
/// found.
eatSpace(){let start=this.pos;for(;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>start}/// Move to the end of the line.
skipToEnd(){this.pos=this.string.length}/// Move to directly before the given character, if found on the
/// current line.
skipTo(ch){let found=this.string.indexOf(ch,this.pos);if(-1<found)return this.pos=found,!0}/// Move back `n` characters.
backUp(n){this.pos-=n}/// Get the column position at `this.pos`.
column(){return this.lastColumnPos<this.start&&(this.lastColumnValue=countCol(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue}/// Get the indentation column of the current line.
indentation(){return countCol(this.string,null,this.tabSize)}/// Match the input against the given string or regular expression
/// (which should start with a `^`). Return true or the regexp match
/// if it matches.
///
/// Unless `consume` is set to `false`, this will move `this.pos`
/// past the matched text.
///
/// When matching a string `caseInsensitive` can be set to true to
/// make the match case-insensitive.
match(pattern,consume,caseInsensitive){if("string"==typeof pattern){let cased=str=>caseInsensitive?str.toLowerCase():str,substr=this.string.substr(this.pos,pattern.length);return cased(substr)==cased(pattern)?(!1!==consume&&(this.pos+=pattern.length),!0):null}else{let match=this.string.slice(this.pos).match(pattern);return match&&0<match.index?null:(match&&!1!==consume&&(this.pos+=match[0].length),match)}}/// Get the current token.
current(){return this.string.slice(this.start,this.pos)}}class StreamLanguage extends language.Language{constructor(parser){let self,data=language.defineLanguageFacet(parser.languageData),p=fullParser(parser),impl=new class extends common.Parser{createParse(input,fragments,ranges){return new Parse(self,input,fragments,ranges)}};super(data,impl,docID(data),[language.indentService.of((cx,pos)=>this.getIndent(cx,pos))]),self=this,this.streamParser=p,this.stateAfter=new common.NodeProp({perNode:!0})}static define(spec){return new StreamLanguage(spec)}getIndent(cx,pos){let tree=language.syntaxTree(cx.state),at=tree.resolve(pos);for(;at&&at.type!=this.topNode;)at=at.parent;if(!at)return null;let statePos,state,start=findState(this,tree,0,at.from,pos);if(start?(state=start.state,statePos=start.pos+1):(state=this.streamParser.startState(cx.unit),statePos=0),1e4<pos-statePos/* MaxIndentScanDist */)return null;for(;statePos<pos;){let line=cx.state.doc.lineAt(statePos),end=Math.min(pos,line.to);if(line.length)for(let stream=new StringStream(line.text,cx.state.tabSize,cx.unit);stream.pos<end-line.from;)readToken(this.streamParser.token,stream,state);else this.streamParser.blankLine(state,cx.unit);if(end==pos)break;statePos=line.to+1}let{text}=cx.state.doc.lineAt(pos);return this.streamParser.indent(state,/^\s*(.*)/.exec(text)[1],cx)}get allowsNesting(){return!1}}class Parse{constructor(lang,input,fragments,ranges){this.lang=lang,this.input=input,this.fragments=fragments,this.ranges=ranges,this.stoppedAt=null,this.chunks=[],this.chunkPos=[],this.chunk=[],this.chunkReused=void 0,this.rangeIndex=0,this.to=ranges[ranges.length-1].to;let context=language.ParseContext.get(),from=ranges[0].from,{state,tree}=findStartInFragments(lang,fragments,from,null===context||void 0===context?void 0:context.state);this.state=state,this.parsedPos=this.chunkStart=from+tree.length,tree.length&&(this.chunks.push(tree),this.chunkPos.push(0)),context&&this.parsedPos<context.viewport.from-1e5/* MaxDistanceBeforeViewport */&&(this.state=this.lang.streamParser.startState(language.getIndentUnit(context.state)),context.skipUntilInView(this.parsedPos,context.viewport.from),this.parsedPos=context.viewport.from)}advance(){let context=language.ParseContext.get(),parseEnd=null==this.stoppedAt?this.to:this.stoppedAt,end=Math.min(parseEnd,this.chunkStart+2048/* ChunkSize */);for(context&&(end=Math.min(end,context.viewport.to));this.parsedPos<end;)this.parseLine(context);return this.chunkStart<this.parsedPos&&this.finishChunk(),this.parsedPos>=parseEnd?this.finish():context&&this.parsedPos>=context.viewport.to?(context.skipUntilInView(this.parsedPos,parseEnd),this.finish()):null}stopAt(pos){this.stoppedAt=pos}lineAfter(pos){let chunk=this.input.chunk(pos);if(!this.input.lineChunks){let eol=chunk.indexOf("\n");-1<eol&&(chunk=chunk.slice(0,eol))}else"\n"==chunk&&(chunk="");return pos+chunk.length<=this.to?chunk:chunk.slice(0,this.to-pos)}nextLine(){let from=this.parsedPos,line=this.lineAfter(from),end=from+line.length;for(let rangeEnd,index=this.rangeIndex;;){if(rangeEnd=this.ranges[index].to,rangeEnd>=end)break;if(line=line.slice(0,rangeEnd-(end-line.length)),index++,index==this.ranges.length)break;let rangeStart=this.ranges[index].from,after=this.lineAfter(rangeStart);line+=after,end=rangeStart+after.length}return{line,end}}skipGapsTo(pos,offset,side){for(;;){let end=this.ranges[this.rangeIndex].to,offPos=pos+offset;if(0<side?end>offPos:end>=offPos)break;let start=this.ranges[++this.rangeIndex].from;offset+=start-end}return offset}emitToken(id,from,to,size,offset){if(1<this.ranges.length){offset=this.skipGapsTo(from,offset,1),from+=offset;let len0=this.chunk.length;offset=this.skipGapsTo(to,offset,-1),to+=offset,size+=this.chunk.length-len0}return this.chunk.push(id,from,to,size),offset}parseLine(context){let{line,end}=this.nextLine(),offset=0,{streamParser}=this.lang,stream=new StringStream(line,context?context.state.tabSize:4,context?language.getIndentUnit(context.state):2);if(stream.eol())streamParser.blankLine(this.state,stream.indentUnit);else for(;!stream.eol();){let token=readToken(streamParser.token,stream,this.state);if(token&&(offset=this.emitToken(tokenID(token),this.parsedPos+stream.start,this.parsedPos+stream.pos,4,offset)),1e4<stream.start/* MaxLineLength */)break}this.parsedPos=end,this.parsedPos<this.to&&this.parsedPos++}finishChunk(){let tree=common.Tree.build({buffer:this.chunk,start:this.chunkStart,length:this.parsedPos-this.chunkStart,nodeSet,topID:0,maxBufferLength:2048/* ChunkSize */,reused:this.chunkReused});tree=new common.Tree(tree.type,tree.children,tree.positions,tree.length,[[this.lang.stateAfter,this.lang.streamParser.copyState(this.state)]]),this.chunks.push(tree),this.chunkPos.push(this.chunkStart-this.ranges[0].from),this.chunk=[],this.chunkReused=void 0,this.chunkStart=this.parsedPos}finish(){return new common.Tree(this.lang.topNode,this.chunks,this.chunkPos,this.parsedPos-this.ranges[0].from).balance()}}const tokenTable=Object.create(null),typeArray=[common.NodeType.none],nodeSet=new common.NodeSet(typeArray),warned=[];for(let[legacyName,name]of[["variable","variableName"],["variable-2","variableName.special"],["string-2","string.special"],["def","variableName.definition"],["tag","typeName"],["attribute","propertyName"],["type","typeName"],["builtin","variableName.standard"],["qualifier","modifier"],["error","invalid"],["header","heading"],["property","propertyName"]])tokenTable[legacyName]=tokenID(name);return exports.StreamLanguage=StreamLanguage,exports.StringStream=StringStream,exports}