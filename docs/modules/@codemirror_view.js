async function moduleInitFunction(require,exports={}){function getSelection(root){let target;// Browsers differ on whether shadow roots have a getSelection
// method. If it exists, use that, otherwise, call it on the
// document.
return target=11==root.nodeType?root.getSelection?root:root.ownerDocument:root,target.getSelection()}function contains(dom,node){return!!node&&dom.contains(1==node.nodeType?node:node.parentNode)}function deepActiveElement(){let elt=document.activeElement;for(;elt&&elt.shadowRoot;)elt=elt.shadowRoot.activeElement;return elt}function hasSelection(dom,selection){if(!selection.anchorNode)return!1;try{// Firefox will raise 'permission denied' errors when accessing
// properties of `sel.anchorNode` when it's in a generated CSS
// element.
return contains(dom,selection.anchorNode)}catch(_){return!1}}function clientRectsFor(dom){return 3==dom.nodeType?textRange(dom,0,dom.nodeValue.length).getClientRects():1==dom.nodeType?dom.getClientRects():[]}// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
function isEquivalentPosition(node,off,targetNode,targetOff){return!!targetNode&&(scanFor(node,off,targetNode,targetOff,-1)||scanFor(node,off,targetNode,targetOff,1))}function domIndex(node){for(var index=0;;index++)if(node=node.previousSibling,!node)return index}function scanFor(node,off,targetNode,targetOff,dir){for(;;){if(node==targetNode&&off==targetOff)return!0;if(off==(0>dir?0:maxOffset(node))){if("DIV"==node.nodeName)return!1;let parent=node.parentNode;if(!parent||1!=parent.nodeType)return!1;off=domIndex(node)+(0>dir?0:1),node=parent}else if(1==node.nodeType){if(node=node.childNodes[off+(0>dir?-1:0)],1==node.nodeType&&"false"==node.contentEditable)return!1;off=0>dir?maxOffset(node):0}else return!1}}function maxOffset(node){return 3==node.nodeType?node.nodeValue.length:node.childNodes.length}function flattenRect(rect,left){let x=left?rect.left:rect.right;return{left:x,right:x,top:rect.top,bottom:rect.bottom}}function windowRect(win){return{left:0,right:win.innerWidth,top:0,bottom:win.innerHeight}}function scrollRectIntoView(dom,rect,side,x,y,xMargin,yMargin,ltr){let doc=dom.ownerDocument,win=doc.defaultView;for(let cur=dom;cur;)if(1==cur.nodeType){// Element
let bounding,top=cur==doc.body;if(top)bounding=windowRect(win);else{if(cur.scrollHeight<=cur.clientHeight&&cur.scrollWidth<=cur.clientWidth){cur=cur.parentNode;continue}let rect=cur.getBoundingClientRect();// Make sure scrollbar width isn't included in the rectangle
bounding={left:rect.left,right:rect.left+cur.clientWidth,top:rect.top,bottom:rect.top+cur.clientHeight}}let moveX=0,moveY=0;if("nearest"==y)rect.top<bounding.top?(moveY=-(bounding.top-rect.top+yMargin),0<side&&rect.bottom>bounding.bottom+moveY&&(moveY=rect.bottom-bounding.bottom+moveY+yMargin)):rect.bottom>bounding.bottom&&(moveY=rect.bottom-bounding.bottom+yMargin,0>side&&rect.top-moveY<bounding.top&&(moveY=-(bounding.top+moveY-rect.top+yMargin)));else{let rectHeight=rect.bottom-rect.top,boundingHeight=bounding.bottom-bounding.top,targetTop="center"==y&&rectHeight<=boundingHeight?rect.top+rectHeight/2-boundingHeight/2:"start"==y||"center"==y&&0>side?rect.top-yMargin:rect.bottom-boundingHeight+yMargin;moveY=targetTop-bounding.top}if("nearest"==x)rect.left<bounding.left?(moveX=-(bounding.left-rect.left+xMargin),0<side&&rect.right>bounding.right+moveX&&(moveX=rect.right-bounding.right+moveX+xMargin)):rect.right>bounding.right&&(moveX=rect.right-bounding.right+xMargin,0>side&&rect.left<bounding.left+moveX&&(moveX=-(bounding.left+moveX-rect.left+xMargin)));else{let targetLeft="center"==x?rect.left+(rect.right-rect.left)/2-(bounding.right-bounding.left)/2:"start"==x==ltr?rect.left-xMargin:rect.right-(bounding.right-bounding.left)+xMargin;moveX=targetLeft-bounding.left}if(moveX||moveY)if(top)win.scrollBy(moveX,moveY);else{if(moveY){let start=cur.scrollTop;cur.scrollTop+=moveY,moveY=cur.scrollTop-start}if(moveX){let start=cur.scrollLeft;cur.scrollLeft+=moveX,moveX=cur.scrollLeft-start}rect={left:rect.left-moveX,top:rect.top-moveY,right:rect.right-moveX,bottom:rect.bottom-moveY}}if(top)break;cur=cur.assignedSlot||cur.parentNode,x=y="nearest"}else if(11==cur.nodeType)// A shadow root
cur=cur.host;else break}// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom){if(dom.setActive)return dom.setActive();// in IE
if(preventScrollSupported)return dom.focus(preventScrollSupported);let stack=[];for(let cur=dom;cur&&(stack.push(cur,cur.scrollTop,cur.scrollLeft),cur!=cur.ownerDocument);cur=cur.parentNode);if(dom.focus(null==preventScrollSupported?{get preventScroll(){return preventScrollSupported={preventScroll:!0},!0}}:void 0),!preventScrollSupported){preventScrollSupported=!1;for(let i=0;i<stack.length;){let elt=stack[i++],top=stack[i++],left=stack[i++];elt.scrollTop!=top&&(elt.scrollTop=top),elt.scrollLeft!=left&&(elt.scrollLeft=left)}}}function textRange(node,from,to=from){let range=scratchRange||(scratchRange=document.createRange());return range.setEnd(node,to),range.setStart(node,from),range}function dispatchKey(elt,name,code){let options={key:name,code:name,keyCode:code,which:code,cancelable:!0},down=new KeyboardEvent("keydown",options);down.synthetic=!0,elt.dispatchEvent(down);let up=new KeyboardEvent("keyup",options);return up.synthetic=!0,elt.dispatchEvent(up),down.defaultPrevented||up.defaultPrevented}function getRoot(node){for(;node;){if(node&&(9==node.nodeType||11==node.nodeType&&node.host))return node;node=node.assignedSlot||node.parentNode}return null}function clearAttributes(node){for(;node.attributes.length;)node.removeAttributeNode(node.attributes[0])}// Remove a DOM node and return its next sibling.
function rm(dom){let next=dom.nextSibling;return dom.parentNode.removeChild(dom),next}function replaceRange(parent,fromI,fromOff,toI,toOff,insert,breakAtStart,openStart,openEnd){let{children}=parent,before=children.length?children[fromI]:null,last=insert.length?insert[insert.length-1]:null,breakAtEnd=last?last.breakAfter:breakAtStart;// Change within a single child
if(!(fromI==toI&&before&&!breakAtStart&&!breakAtEnd&&2>insert.length&&before.merge(fromOff,toOff,insert.length?last:null,0==fromOff,openStart,openEnd))){if(toI<children.length){let after=children[toI];// Make sure the end of the child after the update is preserved in `after`
after&&toOff<after.length?(fromI==toI&&(after=after.split(toOff),toOff=0),!breakAtEnd&&last&&after.merge(0,toOff,last,!0,0,openEnd)?insert[insert.length-1]=after:(toOff&&after.merge(0,toOff,null,!1,0,openEnd),insert.push(after))):(null===after||void 0===after?void 0:after.breakAfter)&&(last?last.breakAfter=1:breakAtStart=1),toI++}// Try to merge widgets on the boundaries of the replacement
for(before&&(before.breakAfter=breakAtStart,0<fromOff&&(!breakAtStart&&insert.length&&before.merge(fromOff,before.length,insert[0],!1,openStart,0)?before.breakAfter=insert.shift().breakAfter:(fromOff<before.length||before.children.length&&0==before.children[before.children.length-1].length)&&before.merge(fromOff,before.length,null,!1,openStart,0),fromI++));fromI<toI&&insert.length;)if(children[toI-1].become(insert[insert.length-1]))toI--,insert.pop(),openEnd=insert.length?0:openStart;else if(children[fromI].become(insert[0]))fromI++,insert.shift(),openStart=insert.length?0:openEnd;else break;!insert.length&&fromI&&toI<children.length&&!children[fromI-1].breakAfter&&children[toI].merge(0,0,children[fromI-1],!1,openStart,openEnd)&&fromI--,(fromI<toI||insert.length)&&parent.replaceChildren(fromI,toI,insert)}}function mergeChildrenInto(parent,from,to,insert,openStart,openEnd){let cur=parent.childCursor(),{i:toI,off:toOff}=cur.findPos(to,1),{i:fromI,off:fromOff}=cur.findPos(from,-1),dLen=from-to;for(let view of insert)dLen+=view.length;parent.length+=dLen,replaceRange(parent,fromI,fromOff,toI,toOff,insert,0,openStart,openEnd)}function textCoords(text,pos,side){let length=text.nodeValue.length;pos>length&&(pos=length);let from=pos,to=pos,flatten=0;0==pos&&0>side||pos==length&&0<=side?!(browser.chrome||browser.gecko)&&(pos?(from--,flatten=1):(to++,flatten=-1)):0>side?from--:to++;let rects=textRange(text,from,to).getClientRects();if(!rects.length)return Rect0;let rect=rects[(flatten?0>flatten:0<=side)?0:rects.length-1];return browser.safari&&!flatten&&0==rect.width&&(rect=Array.prototype.find.call(rects,r=>r.width)||rect),flatten?flattenRect(rect,0>flatten):rect||null}// Also used for collapsed ranges that don't have a placeholder widget!
function inlineDOMAtPos(dom,children,pos){let i=0;for(let off=0;i<children.length;i++){let child=children[i],end=off+child.length;if(!(end==off&&0>=child.getSide())){if(pos>off&&pos<end&&child.dom.parentNode==dom)return child.domAtPos(pos-off);if(pos<=off)break;off=end}}for(;0<i;i--){let before=children[i-1].dom;if(before.parentNode==dom)return DOMPos.after(before)}return new DOMPos(dom,0)}// Assumes `view`, if a mark view, has precisely 1 child.
function joinInlineInto(parent,view,open){let last,{children}=parent;0<open&&view instanceof MarkView&&children.length&&(last=children[children.length-1])instanceof MarkView&&last.mark.eq(view.mark)?joinInlineInto(last,view.children[0],open-1):(children.push(view),view.setParent(parent)),parent.length+=view.length}function coordsInChildren(view,pos,side){for(let off=0,i=0;i<view.children.length;i++){let next,child=view.children[i],end=off+child.length;if((0>=side||end==view.length||0<child.getSide()?end>=pos:end>pos)&&(pos<end||i+1==view.children.length||(next=view.children[i+1]).length||0<next.getSide())){let flatten=0;if(end==off){if(0>=child.getSide())continue;flatten=side=-child.getSide()}let rect=child.coordsAt(pos-off,side);return flatten&&rect?flattenRect(rect,0>side):rect}off=end}let last=view.dom.lastChild;if(!last)return view.dom.getBoundingClientRect();let rects=clientRectsFor(last);return rects[rects.length-1]||null}function combineAttrs(source,target){for(let name in source)"class"==name&&target.class?target.class+=" "+source.class:"style"==name&&target.style?target.style+=";"+source.style:target[name]=source[name];return target}function attrsEq(a,b){if(a==b)return!0;if(!a||!b)return!1;let keysA=Object.keys(a),keysB=Object.keys(b);if(keysA.length!=keysB.length)return!1;for(let key of keysA)if(-1==keysB.indexOf(key)||a[key]!==b[key])return!1;return!0}function updateAttrs(dom,prev,attrs){if(prev)for(let name in prev)attrs&&name in attrs||dom.removeAttribute(name);if(attrs)for(let name in attrs)prev&&prev[name]==attrs[name]||dom.setAttribute(name,attrs[name])}/// Widgets added to the content are described by subclasses of this
/// class. Using a description object like that makes it possible to
/// delay creating of the DOM structure for a widget until it is
/// needed, and to avoid redrawing widgets even when the decorations
/// that define them are recreated.
function getInclusive(spec,block=!1){let{inclusiveStart:start,inclusiveEnd:end}=spec;return null==start&&(start=spec.inclusive),null==end&&(end=spec.inclusive),{start:null!==start&&void 0!==start?start:block,end:null!==end&&void 0!==end?end:block}}function widgetsEq(a,b){return a==b||!!(a&&b&&a.compare(b))}function addRange(from,to,ranges,margin=0){let last=ranges.length-1;0<=last&&ranges[last]+margin>from?ranges[last]=Math.max(ranges[last],to):ranges.push(from,to)}function wrapMarks(view,active){for(let mark of active)view=new MarkView(mark,[view],view.length);return view}/// Log or report an unhandled exception in client code. Should
/// probably only be used by extension code that allows client code to
/// provide functions, and calls those functions in a context where an
/// exception can't be propagated to calling code in a reasonable way
/// (for example when in an event handler).
///
/// Either calls a handler registered with
/// [`EditorView.exceptionSink`](#view.EditorView^exceptionSink),
/// `window.onerror`, if defined, or `console.error` (in which case
/// it'll pass `context`, when given, as first argument).
function logException(state,exception,context){let handler=state.facet(exceptionSink);handler.length?handler[0](exception):window.onerror?window.onerror(exception+"",context,void 0,void 0,exception):context?console.error(context+":",exception):console.error(exception)}// Decode a string with each type encoded as log2(type)
function dec(str){let result=[];for(let i=0;i<str.length;i++)result.push(1<<+str[i]);return result}// Character types for codepoints 0 to 0xf8
function charType(ch){return 247>=ch?LowTypes[ch]:1424<=ch&&1524>=ch?2/* R */:1536<=ch&&1785>=ch?ArabicTypes[ch-1536]:1774<=ch&&2220>=ch?4/* AL */:8192<=ch&&8203>=ch?256/* NI */:8204==ch?256/* NI */:1/* L */}function computeOrder(line,direction){let len=line.length,outerType=direction==LTR?1/* L */:2/* R */,oppositeType=direction==LTR?2/* R */:1/* L */;if(!line||1==outerType/* L */&&!BidiRE.test(line))return trivialOrder(len);// W1. Examine each non-spacing mark (NSM) in the level run, and
// change the type of the NSM to the type of the previous
// character. If the NSM is at the start of the level run, it will
// get the type of sor.
// W2. Search backwards from each instance of a European number
// until the first strong type (R, L, AL, or sor) is found. If an
// AL is found, change the type of the European number to Arabic
// number.
// W3. Change all ALs to R.
// (Left after this: L, R, EN, AN, ET, CS, NI)
for(let type,i=0,prev=outerType,prevStrong=outerType;i<len;i++)type=charType(line.charCodeAt(i)),512==type/* NSM */?type=prev:8==type/* EN */&&4==prevStrong/* AL */&&(type=16/* AN */),types[i]=4==type/* AL */?2/* R */:type,7&type/* Strong */&&(prevStrong=type),prev=type;// W5. A sequence of European terminators adjacent to European
// numbers changes to all European numbers.
// W6. Otherwise, separators and terminators change to Other
// Neutral.
// W7. Search backwards from each instance of a European number
// until the first strong type (R, L, or sor) is found. If an L is
// found, then change the type of the European number to L.
// (Left after this: L, R, EN+AN, NI)
for(let type,i=0,prev=outerType,prevStrong=outerType;i<len;i++){if(type=types[i],128==type/* CS */)i<len-1&&prev==types[i+1]&&24&prev/* Num */?type=types[i]=prev:types[i]=256/* NI */;else if(64==type/* ET */){let end=i+1;for(;end<len&&64==types[end]/* ET */;)end++;let replace=i&&8==prev/* EN */||end<len&&8==types[end]/* EN */?1==prevStrong/* L */?1/* L */:8/* EN */:256/* NI */;for(let j=i;j<end;j++)types[j]=replace;i=end-1}else 8==type/* EN */&&1==prevStrong/* L */&&(types[i]=1/* L */);prev=type,7&type/* Strong */&&(prevStrong=type)}// N0. Process bracket pairs in an isolating run sequence
// sequentially in the logical order of the text positions of the
// opening paired brackets using the logic given below. Within this
// scope, bidirectional types EN and AN are treated as R.
for(let ch,br,type,i=0,sI=0,context=0;i<len;i++)// Keeps [startIndex, type, strongSeen] triples for each open
// bracket on BracketStack.
if(br=Brackets[ch=line.charCodeAt(i)]){if(0>br){// Closing bracket
for(let sJ=sI-3;0<=sJ;sJ-=3)if(BracketStack[sJ+1]==-br){let flags=BracketStack[sJ+2],type=2&flags/* EmbedInside */?outerType:4&flags/* OppositeInside */?1&flags/* OppositeBefore */?oppositeType:outerType:0;type&&(types[i]=types[BracketStack[sJ]]=type),sI=sJ;break}}else if(189==BracketStack.length/* MaxDepth */)break;else BracketStack[sI++]=i,BracketStack[sI++]=ch,BracketStack[sI++]=context;}else if(2==(type=types[i])/* R */||1==type/* L */){let embed=type==outerType;context=embed?0:1/* OppositeBefore */;for(let cur,sJ=sI-3;0<=sJ&&(cur=BracketStack[sJ+2],!(2&cur/* EmbedInside */));sJ-=3)if(embed)BracketStack[sJ+2]|=2/* EmbedInside */;else{if(4&cur/* OppositeInside */)break;BracketStack[sJ+2]|=4/* OppositeInside */}}// N1. A sequence of neutrals takes the direction of the
// surrounding strong text if the text on both sides has the same
// direction. European and Arabic numbers act as if they were R in
// terms of their influence on neutrals. Start-of-level-run (sor)
// and end-of-level-run (eor) are used at level run boundaries.
// N2. Any remaining neutrals take the embedding direction.
// (Left after this: L, R, EN+AN)
for(let i=0;i<len;i++)if(256==types[i]/* NI */){let end=i+1;for(;end<len&&256==types[end]/* NI */;)end++;let beforeL=1==(i?types[i-1]:outerType)/* L */,afterL=1==(end<len?types[end]:outerType)/* L */,replace=beforeL==afterL?beforeL?1/* L */:2/* R */:outerType;for(let j=i;j<end;j++)types[j]=replace;i=end-1}// Here we depart from the documented algorithm, in order to avoid
// building up an actual levels array. Since there are only three
// levels (0, 1, 2) in an implementation that doesn't take
// explicit embedding into account, we can build up the order on
// the fly, without following the level-based algorithm.
let order=[];if(1==outerType/* L */)for(let i=0;i<len;){let start=i,rtl=1!=types[i++]/* L */;for(;i<len&&rtl==(1!=types[i]/* L */);)i++;if(rtl)for(let j=i;j>start;){let end=j,l=2!=types[--j]/* R */;for(;j>start&&l==(2!=types[j-1]/* R */);)j--;order.push(new BidiSpan(j,end,l?2:1))}else order.push(new BidiSpan(start,i,0))}else for(let i=0;i<len;){let start=i,rtl=2==types[i++]/* R */;for(;i<len&&rtl==(2==types[i]/* R */);)i++;order.push(new BidiSpan(start,i,rtl?1:2))}return order}function trivialOrder(length){return[new BidiSpan(0,length,0)]}function moveVisually(line,order,dir,start,forward){var _a;let startIndex=start.head-line.from,spanI=-1;if(0==startIndex){if(!forward||!line.length)return null;order[0].level!=dir&&(startIndex=order[0].side(!1,dir),spanI=0)}else if(startIndex==line.length){if(forward)return null;let last=order[order.length-1];last.level!=dir&&(startIndex=last.side(!0,dir),spanI=order.length-1)}0>spanI&&(spanI=BidiSpan.find(order,startIndex,null!==(_a=start.bidiLevel)&&void 0!==_a?_a:-1,start.assoc));let span=order[spanI];// End of span. (But not end of line--that was checked for above.)
startIndex==span.side(forward,dir)&&(span=order[spanI+=forward?1:-1],startIndex=span.side(!forward,dir));let indexForward=forward==(span.dir==dir),nextIndex=text.findClusterBreak(line.text,startIndex,indexForward);if(movedOver=line.text.slice(Math.min(startIndex,nextIndex),Math.max(startIndex,nextIndex)),nextIndex!=span.side(forward,dir))return state.EditorSelection.cursor(nextIndex+line.from,indexForward?-1:1,span.level);let nextSpan=spanI==(forward?order.length-1:0)?null:order[spanI+(forward?1:-1)];return nextSpan||span.level==dir?nextSpan&&nextSpan.level<span.level?state.EditorSelection.cursor(nextSpan.side(!forward,dir)+line.from,forward?1:-1,nextSpan.level):state.EditorSelection.cursor(nextIndex+line.from,forward?-1:1,span.level):state.EditorSelection.cursor(forward?line.to:line.from,forward?-1:1,dir)}function isBlockElement(node){return 1==node.nodeType&&/^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName)}function betweenUneditable(pos){return 1==pos.node.nodeType&&pos.node.firstChild&&(0==pos.offset||"false"==pos.node.childNodes[pos.offset-1].contentEditable)&&(pos.offset==pos.node.childNodes.length||"false"==pos.node.childNodes[pos.offset].contentEditable)}function compositionSurroundingNode(view){let sel=view.observer.selectionRange,textNode=sel.focusNode&&nearbyTextNode(sel.focusNode,sel.focusOffset,0);if(!textNode)return null;let cView=view.docView.nearest(textNode);if(!cView)return null;if(cView instanceof LineView){let topNode=textNode;for(;topNode.parentNode!=cView.dom;)topNode=topNode.parentNode;let prev=topNode.previousSibling;for(;prev&&!ContentView.get(prev);)prev=prev.previousSibling;let pos=prev?ContentView.get(prev).posAtEnd:cView.posAtStart;return{from:pos,to:pos,node:topNode,text:textNode}}else{for(;;){let{parent}=cView;if(!parent)return null;if(parent instanceof LineView)break;cView=parent}let from=cView.posAtStart;return{from,to:from+cView.length,node:cView.dom,text:textNode}}}function computeCompositionDeco(view,changes){let surrounding=compositionSurroundingNode(view);if(!surrounding)return Decoration.none;let{from,to,node,text:textNode}=surrounding,newFrom=changes.mapPos(from,1),newTo=Math.max(newFrom,changes.mapPos(to,-1)),{state}=view,text=3==node.nodeType?node.nodeValue:new DOMReader([],view).readRange(node.firstChild,null).text;if(newTo-newFrom<text.length){if(state.sliceDoc(newFrom,Math.min(state.doc.length,newFrom+text.length))==text)newTo=newFrom+text.length;else if(state.sliceDoc(Math.max(0,newTo-text.length),newTo)==text)newFrom=newTo-text.length;else return Decoration.none;}else if(state.sliceDoc(newFrom,newTo)!=text)return Decoration.none;return Decoration.set(Decoration.replace({widget:new CompositionWidget(node,textNode)}).range(newFrom,newTo))}function nearbyTextNode(node,offset,side){for(;;){if(3==node.nodeType)return node;if(1==node.nodeType&&0<offset&&0>=side)node=node.childNodes[offset-1],offset=maxOffset(node);else if(1==node.nodeType&&offset<node.childNodes.length&&0<=side)node=node.childNodes[offset],offset=0;else return null}}function nextToUneditable(node,offset){return 1==node.nodeType?(offset&&"false"==node.childNodes[offset-1].contentEditable?1/* Before */:0)|(offset<node.childNodes.length&&"false"==node.childNodes[offset].contentEditable?2/* After */:0):0}function findChangedDeco(a,b,diff){let comp=new DecorationComparator$1;return rangeset.RangeSet.compare(a,b,diff,comp),comp.changes}function inUneditable(node,inside){for(let cur=node;cur&&cur!=inside;cur=cur.assignedSlot||cur.parentNode)if(1==cur.nodeType&&"false"==cur.contentEditable)return!0;return!1}function groupAt(state$1,pos,bias=1){let categorize=state$1.charCategorizer(pos),line=state$1.doc.lineAt(pos),linePos=pos-line.from;if(0==line.length)return state.EditorSelection.cursor(pos);0==linePos?bias=1:linePos==line.length&&(bias=-1);let from=linePos,to=linePos;0>bias?from=text.findClusterBreak(line.text,linePos,!1):to=text.findClusterBreak(line.text,linePos);let cat=categorize(line.text.slice(from,to));for(;0<from;){let prev=text.findClusterBreak(line.text,from,!1);if(categorize(line.text.slice(prev,from))!=cat)break;from=prev}for(;to<line.length;){let next=text.findClusterBreak(line.text,to);if(categorize(line.text.slice(to,next))!=cat)break;to=next}return state.EditorSelection.range(from+line.from,to+line.from)}// Search the DOM for the {node, offset} position closest to the given
// coordinates. Very inefficient and crude, but can usually be avoided
// by calling caret(Position|Range)FromPoint instead.
function getdx(x,rect){return rect.left>x?rect.left-x:Math.max(0,x-rect.right)}function getdy(y,rect){return rect.top>y?rect.top-y:Math.max(0,y-rect.bottom)}function yOverlap(a,b){return a.top<b.bottom-1&&a.bottom>b.top+1}function upTop(rect,top){return top<rect.top?{top,left:rect.left,right:rect.right,bottom:rect.bottom}:rect}function upBot(rect,bottom){return bottom>rect.bottom?{top:rect.top,left:rect.left,right:rect.right,bottom}:rect}function domPosAtCoords(parent,x,y){let closest,closestRect,closestX,closestY,above,below,aboveRect,belowRect;for(let rects,child=parent.firstChild;child;child=child.nextSibling){rects=clientRectsFor(child);for(let rect,i=0;i<rects.length;i++){rect=rects[i],closestRect&&yOverlap(closestRect,rect)&&(rect=upTop(upBot(rect,closestRect.bottom),closestRect.top));let dx=getdx(x,rect),dy=getdy(y,rect);if(0==dx&&0==dy)return 3==child.nodeType?domPosInText(child,x,y):domPosAtCoords(child,x,y);(!closest||closestY>dy||closestY==dy&&closestX>dx)&&(closest=child,closestRect=rect,closestX=dx,closestY=dy),0==dx?y>rect.bottom&&(!aboveRect||aboveRect.bottom<rect.bottom)?(above=child,aboveRect=rect):y<rect.top&&(!belowRect||belowRect.top>rect.top)&&(below=child,belowRect=rect):aboveRect&&yOverlap(aboveRect,rect)?aboveRect=upBot(aboveRect,rect.bottom):belowRect&&yOverlap(belowRect,rect)&&(belowRect=upTop(belowRect,rect.top))}}if(aboveRect&&aboveRect.bottom>=y?(closest=above,closestRect=aboveRect):belowRect&&belowRect.top<=y&&(closest=below,closestRect=belowRect),!closest)return{node:parent,offset:0};let clipX=Math.max(closestRect.left,Math.min(closestRect.right,x));if(3==closest.nodeType)return domPosInText(closest,clipX,y);if(!closestX&&"true"==closest.contentEditable)return domPosAtCoords(closest,clipX,y);let offset=Array.prototype.indexOf.call(parent.childNodes,closest)+(x>=(closestRect.left+closestRect.right)/2?1:0);return{node:parent,offset}}function domPosInText(node,x,y){let len=node.nodeValue.length,closestOffset=-1,closestDY=1e9,generalSide=0;for(let rects,i=0;i<len;i++){rects=textRange(node,i,i+1).getClientRects();for(let rect,j=0;j<rects.length;j++){if(rect=rects[j],rect.top==rect.bottom)continue;generalSide||(generalSide=x-rect.left);let dy=(rect.top>y?rect.top-y:y-rect.bottom)-1;if(rect.left-1<=x&&rect.right+1>=x&&dy<closestDY){let right=x>=(rect.left+rect.right)/2,after=right;if(browser.chrome||browser.gecko){// Check for RTL on browsers that support getting client
// rects for empty ranges.
let rectBefore=textRange(node,i).getBoundingClientRect();rectBefore.left==rect.right&&(after=!right)}if(0>=dy)return{node,offset:i+(after?1:0)};closestOffset=i+(after?1:0),closestDY=dy}}}return{node,offset:-1<closestOffset?closestOffset:0<generalSide?node.nodeValue.length:0}}function posAtCoords(view,{x,y},precise,bias=-1){var _a;let block,content=view.contentDOM.getBoundingClientRect(),docTop=content.top+view.viewState.paddingTop,{docHeight}=view.viewState,yOffset=y-docTop;if(0>yOffset)return 0;if(yOffset>docHeight)return view.state.doc.length;// Scan for a text block near the queried y position
for(let halfLine=view.defaultLineHeight/2,bounced=!1;;){if(block=view.elementAtHeight(yOffset),block.type==exports.BlockType.Text)break;for(;;){if(yOffset=0<bias?block.bottom+halfLine:block.top-halfLine,0<=yOffset&&yOffset<=docHeight)break;// If the document consists entirely of replaced widgets, we
// won't find a text block, so return 0
if(bounced)return precise?null:0;bounced=!0,bias=-bias}}y=docTop+yOffset;let lineStart=block.from;// If this is outside of the rendered viewport, we can't determine a position
if(lineStart<view.viewport.from)return 0==view.viewport.from?0:precise?null:posAtCoordsImprecise(view,content,block,x,y);if(lineStart>view.viewport.to)return view.viewport.to==view.state.doc.length?view.state.doc.length:precise?null:posAtCoordsImprecise(view,content,block,x,y);// Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not
let doc=view.dom.ownerDocument,root=view.root.elementFromPoint?view.root:doc,element=root.elementFromPoint(x,y);element&&!view.contentDOM.contains(element)&&(element=null),element||(x=Math.max(content.left+1,Math.min(content.right-1,x)),element=root.elementFromPoint(x,y),element&&!view.contentDOM.contains(element)&&(element=null));// There's visible editor content under the point, so we can try
// using caret(Position|Range)FromPoint as a shortcut
let node,offset=-1;if(element&&!1!=(null===(_a=view.docView.nearest(element))||void 0===_a?void 0:_a.isEditable))if(doc.caretPositionFromPoint){let pos=doc.caretPositionFromPoint(x,y);pos&&({offsetNode:node,offset}=pos)}else if(doc.caretRangeFromPoint){let range=doc.caretRangeFromPoint(x,y);range&&(({startContainer:node,startOffset:offset}=range),browser.safari&&isSuspiciousCaretResult(node,offset,x)&&(node=void 0))}// No luck, do our own (potentially expensive) search
if(!node||!view.docView.dom.contains(node)){let line=LineView.find(view.docView,lineStart);if(!line)return yOffset>block.top+block.height/2?block.to:block.from;({node,offset}=domPosAtCoords(line.dom,x,y))}return view.docView.posFromDOM(node,offset)}function posAtCoordsImprecise(view,contentRect,block,x,y){let into=Math.round((x-contentRect.left)*view.defaultCharacterWidth);if(view.lineWrapping&&block.height>1.5*view.defaultLineHeight){let line=Math.floor((y-block.top)/view.defaultLineHeight);into+=line*view.viewState.heightOracle.lineLength}let content=view.state.sliceDoc(block.from,block.to);return block.from+text.findColumn(content,into,view.state.tabSize)}// In case of a high line height, Safari's caretRangeFromPoint treats
// the space between lines as belonging to the last character of the
// line before. This is used to detect such a result so that it can be
// ignored (issue #401).
function isSuspiciousCaretResult(node,offset,x){let len;if(3!=node.nodeType||offset!=(len=node.nodeValue.length))return!1;for(let next=node.nextSibling;next;next=next.nextSibling)if(1!=next.nodeType||"BR"!=next.nodeName)return!1;return textRange(node,len-1,len).getBoundingClientRect().left>x}function moveToLineBoundary(view,start,forward,includeWrap){let line=view.state.doc.lineAt(start.head),coords=includeWrap&&view.lineWrapping?view.coordsAtPos(0>start.assoc&&start.head>line.from?start.head-1:start.head):null;if(coords){let editorRect=view.dom.getBoundingClientRect(),pos=view.posAtCoords({x:forward==(view.textDirection==exports.Direction.LTR)?editorRect.right-1:editorRect.left+1,y:(coords.top+coords.bottom)/2});if(null!=pos)return state.EditorSelection.cursor(pos,forward?-1:1)}let lineView=LineView.find(view.docView,start.head),end=lineView?forward?lineView.posAtEnd:lineView.posAtStart:forward?line.to:line.from;return state.EditorSelection.cursor(end,forward?-1:1)}function moveByChar(view,start,forward,by){let line=view.state.doc.lineAt(start.head),spans=view.bidiSpans(line);for(let cur=start,check=null;;){let next=moveVisually(line,spans,view.textDirection,cur,forward),char=movedOver;if(!next){if(line.number==(forward?view.state.doc.lines:1))return cur;char="\n",line=view.state.doc.line(line.number+(forward?1:-1)),spans=view.bidiSpans(line),next=state.EditorSelection.cursor(forward?line.from:line.to)}if(!check){if(!by)return next;check=by(char)}else if(!check(char))return cur;cur=next}}function byGroup(view,pos,start){let categorize=view.state.charCategorizer(pos),cat=categorize(start);return next=>{let nextCat=categorize(next);return cat==state.CharCategory.Space&&(cat=nextCat),cat==nextCat}}function moveVertically(view,start,forward,distance){let startPos=start.head,dir=forward?1:-1;if(startPos==(forward?view.state.doc.length:0))return state.EditorSelection.cursor(startPos);let startY,goal=start.goalColumn,rect=view.contentDOM.getBoundingClientRect(),startCoords=view.coordsAtPos(startPos),docTop=view.documentTop;if(startCoords)null==goal&&(goal=startCoords.left-rect.left),startY=0>dir?startCoords.top:startCoords.bottom;else{let line=view.viewState.lineBlockAt(startPos-docTop);null==goal&&(goal=Math.min(rect.right-rect.left,view.defaultCharacterWidth*(startPos-line.from))),startY=(0>dir?line.top:line.bottom)+docTop}let resolvedGoal=rect.left+goal,dist=null!==distance&&void 0!==distance?distance:view.defaultLineHeight>>1;for(let extra=0;;extra+=10){let curY=startY+(dist+extra)*dir,pos=posAtCoords(view,{x:resolvedGoal,y:curY},!1,dir);if(curY<rect.top||curY>rect.bottom||(0>dir?pos<startPos:pos>startPos))return state.EditorSelection.cursor(pos,void 0,void 0,goal)}}function skipAtoms(view,oldPos,pos){for(let moved,atoms=view.pluginField(PluginField.atomicRanges);;){moved=!1;for(let set of atoms)set.between(pos.from-1,pos.from+1,(from,to)=>{pos.from>from&&pos.from<to&&(pos=oldPos.from>pos.from?state.EditorSelection.cursor(from,1):state.EditorSelection.cursor(to,-1),moved=!0)});if(!moved)return pos}}// This will also be where dragging info and such goes
function addsSelectionRange(view,event){let facet=view.state.facet(clickAddsSelectionRange);return facet.length?facet[0](event):browser.mac?event.metaKey:event.ctrlKey}function dragMovesSelection(view,event){let facet=view.state.facet(dragMovesSelection$1);return facet.length?facet[0](event):browser.mac?!event.altKey:!event.ctrlKey}function isInPrimarySelection(view,event){let{main}=view.state.selection;if(main.empty)return!1;// On boundary clicks, check whether the coordinates are inside the
// selection's client rectangles
let sel=getSelection(view.root);if(0==sel.rangeCount)return!0;let rects=sel.getRangeAt(0).getClientRects();for(let rect,i=0;i<rects.length;i++)if(rect=rects[i],rect.left<=event.clientX&&rect.right>=event.clientX&&rect.top<=event.clientY&&rect.bottom>=event.clientY)return!0;return!1}function eventBelongsToEditor(view,event){if(!event.bubbles)return!0;if(event.defaultPrevented)return!1;for(let cView,node=event.target;node!=view.contentDOM;node=node.parentNode)if(!node||11==node.nodeType||(cView=ContentView.get(node))&&cView.ignoreEvent(event))return!1;return!0}function capturePaste(view){let parent=view.dom.parentNode;if(!parent)return;let target=parent.appendChild(document.createElement("textarea"));target.style.cssText="position: fixed; left: -10000px; top: 10px",target.focus(),setTimeout(()=>{view.focus(),target.remove(),doPaste(view,target.value)},50)}function doPaste(view,input){let changes,{state:state$1}=view,i=1,text=state$1.toText(input),byLine=text.lines==state$1.selection.ranges.length,linewise=null!=lastLinewiseCopy&&state$1.selection.ranges.every(r=>r.empty)&&lastLinewiseCopy==text.toString();if(linewise){let lastLine=-1;changes=state$1.changeByRange(range=>{let line=state$1.doc.lineAt(range.from);if(line.from==lastLine)return{range};lastLine=line.from;let insert=state$1.toText((byLine?text.line(i++).text:input)+state$1.lineBreak);return{changes:{from:line.from,insert},range:state.EditorSelection.cursor(range.from+insert.length)}})}else changes=byLine?state$1.changeByRange(range=>{let line=text.line(i++);return{changes:{from:range.from,to:range.to,insert:line.text},range:state.EditorSelection.cursor(range.from+line.length)}}):state$1.replaceSelection(text);view.dispatch(changes,{userEvent:"input.paste",scrollIntoView:!0})}function rangeForClick(view,pos,bias,type){if(1==type)// Single click
return state.EditorSelection.cursor(pos,bias);if(2==type)// Double click
return groupAt(view.state,pos,bias);else{// Triple click
let visual=LineView.find(view.docView,pos),line=view.state.doc.lineAt(visual?visual.posAtEnd:pos),from=visual?visual.posAtStart:line.from,to=visual?visual.posAtEnd:line.to;return to<view.state.doc.length&&to==line.to&&to++,state.EditorSelection.range(from,to)}}// Try to determine, for the given coordinates, associated with the
// given position, whether they are related to the element before or
// the element after the position.
function findPositionSide(view,pos,x,y){let line=LineView.find(view.docView,pos);if(!line)return 1;let off=pos-line.posAtStart;// Line boundaries point into the line
if(0==off)return 1;if(off==line.length)return-1;// Positions on top of an element point at that element
let before=line.coordsAt(off,-1);if(before&&inside(x,y,before))return-1;let after=line.coordsAt(off,1);return after&&inside(x,y,after)?1:before&&insideY(y,before)?-1:1;// This is probably a line wrap point. Pick before if the point is
// beside it.
}function queryPos(view,event){let pos=view.posAtCoords({x:event.clientX,y:event.clientY},!1);return{pos,bias:findPositionSide(view,pos,event.clientX,event.clientY)}}function getClickType(event){if(!BadMouseDetail)return event.detail;let last=lastMouseDown,lastTime=lastMouseDownTime;return lastMouseDown=event,lastMouseDownTime=Date.now(),lastMouseDownCount=!last||lastTime>Date.now()-400&&2>Math.abs(last.clientX-event.clientX)&&2>Math.abs(last.clientY-event.clientY)?(lastMouseDownCount+1)%3:1}function basicMouseSelection(view,event){let start=queryPos(view,event),type=getClickType(event),startSel=view.state.selection,last=start,lastEvent=event;return{update(update){update.docChanged&&(start&&(start.pos=update.changes.mapPos(start.pos)),startSel=startSel.map(update.changes),lastEvent=null)},get(event,extend,multiple){let cur;if(lastEvent&&event.clientX==lastEvent.clientX&&event.clientY==lastEvent.clientY?cur=last:(cur=last=queryPos(view,event),lastEvent=event),!cur||!start)return startSel;let range=rangeForClick(view,cur.pos,cur.bias,type);if(start.pos!=cur.pos&&!extend){let startRange=rangeForClick(view,start.pos,start.bias,type),from=Math.min(startRange.from,range.from),to=Math.max(startRange.to,range.to);range=from<range.from?state.EditorSelection.range(from,to):state.EditorSelection.range(to,from)}return extend?startSel.replaceRange(startSel.main.extend(range.from,range.to)):multiple?startSel.addRange(range):state.EditorSelection.create([range])}}}function dropText(view,event,text,direct){if(!text)return;let dropPos=view.posAtCoords({x:event.clientX,y:event.clientY},!1);event.preventDefault();let{mouseSelection}=view.inputState,del=direct&&mouseSelection&&mouseSelection.dragging&&mouseSelection.dragMove?{from:mouseSelection.dragging.from,to:mouseSelection.dragging.to}:null,ins={from:dropPos,insert:text},changes=view.state.changes(del?[del,ins]:ins);view.focus(),view.dispatch({changes,selection:{anchor:changes.mapPos(dropPos,-1),head:changes.mapPos(dropPos,1)},userEvent:del?"move.drop":"input.drop"})}function captureCopy(view,text){// The extra wrapper is somehow necessary on IE/Edge to prevent the
// content from being mangled when it is put onto the clipboard
let parent=view.dom.parentNode;if(!parent)return;let target=parent.appendChild(document.createElement("textarea"));target.style.cssText="position: fixed; left: -10000px; top: 10px",target.value=text,target.focus(),target.selectionEnd=text.length,target.selectionStart=0,setTimeout(()=>{target.remove(),view.focus()},50)}function copiedRange(state){let content=[],ranges=[],linewise=!1;for(let range of state.selection.ranges)range.empty||(content.push(state.sliceDoc(range.from,range.to)),ranges.push(range));if(!content.length){// Nothing selected, do a line-wise copy
let upto=-1;for(let{from}of state.selection.ranges){let line=state.doc.lineAt(from);line.number>upto&&(content.push(line.text),ranges.push({from:line.from,to:Math.min(state.doc.length,line.to+1)})),upto=line.number}linewise=!0}return{text:content.join(state.lineBreak),ranges,linewise}}function forceClearComposition(view,rapid){if(view.docView.compositionDeco.size){view.inputState.rapidCompositionStart=rapid;try{view.update([])}finally{view.inputState.rapidCompositionStart=!1}}}function mergeGaps(nodes,around){let before,after;null==nodes[around]&&(before=nodes[around-1])instanceof HeightMapGap&&(after=nodes[around+1])instanceof HeightMapGap&&nodes.splice(around-1,3,new HeightMapGap(before.length+1+after.length))}function heightRelevantDecoChanges(a,b,diff){let comp=new DecorationComparator;return rangeset.RangeSet.compare(a,b,diff,comp,0),comp.changes}function visiblePixelRange(dom,paddingTop){let rect=dom.getBoundingClientRect(),left=Math.max(0,rect.left),right=Math.min(innerWidth,rect.right),top=Math.max(0,rect.top),bottom=Math.min(innerHeight,rect.bottom),body=dom.ownerDocument.body;for(let parent=dom.parentNode;parent&&parent!=body;)if(1==parent.nodeType){let elt=parent,style=window.getComputedStyle(elt);if((elt.scrollHeight>elt.clientHeight||elt.scrollWidth>elt.clientWidth)&&"visible"!=style.overflow){let parentRect=elt.getBoundingClientRect();left=Math.max(left,parentRect.left),right=Math.min(right,parentRect.right),top=Math.max(top,parentRect.top),bottom=Math.min(bottom,parentRect.bottom)}parent="absolute"==style.position||"fixed"==style.position?elt.offsetParent:elt.parentNode}else if(11==parent.nodeType)// Shadow root
parent=parent.host;else break;return{left:left-rect.left,right:Math.max(left,right)-rect.left,top:top-(rect.top+paddingTop),bottom:Math.max(top,bottom)-(rect.top+paddingTop)}}// Line gaps are placeholder widgets used to hide pieces of overlong
// lines within the viewport, as a kludge to keep the editor
// responsive when a ridiculously long line is loaded into it.
function lineStructure(from,to,state){let ranges=[],pos=from,total=0;return rangeset.RangeSet.spans(state.facet(decorations),from,to,{span(){},point(from,to){from>pos&&(ranges.push({from:pos,to:from}),total+=from-pos),pos=to}},20),pos<to&&(ranges.push({from:pos,to}),total+=to-pos),{total,ranges}}function findPosition({total,ranges},ratio){if(0>=ratio)return ranges[0].from;if(1<=ratio)return ranges[ranges.length-1].to;let dist=Math.floor(total*ratio);for(let i=0;;i++){let{from,to}=ranges[i],size=to-from;if(dist<=size)return from+dist;dist-=size}}function findFraction(structure,pos){let counted=0;for(let{from,to}of structure.ranges){if(pos<=to){counted+=pos-from;break}counted+=to-from}return counted/structure.total}function cutRange(ranges,from,to){for(let r,i=0;i<ranges.length;i++)if(r=ranges[i],r.from<to&&r.to>from){let pieces=[];r.from<from&&pieces.push({from:r.from,to:from}),r.to>to&&pieces.push({from:to,to:r.to}),ranges.splice(i,1,...pieces),i+=pieces.length-1}}function find(array,f){for(let val of array)if(f(val))return val}// Don't scale when the document height is within the range of what
// the DOM can handle.
function scaleBlock(block,scaler){if(1==scaler.scale)return block;let bTop=scaler.toDOM(block.top),bBottom=scaler.toDOM(block.bottom);return new BlockInfo(block.from,block.length,bTop,bBottom-bTop,Array.isArray(block.type)?block.type.map(b=>scaleBlock(b,scaler)):block.type)}function buildTheme(main,spec,scopes){return new styleMod.StyleModule(spec,{finish(sel){return /&/.test(sel)?sel.replace(/&\w*/,m=>{if("&"==m)return main;if(!scopes||!scopes[m])throw new RangeError(`Unsupported selector: ${m}`);return scopes[m]}):main+" "+sel}})}function findChild(cView,dom,dir){for(;dom;){let curView=ContentView.get(dom);if(curView&&curView.parent==cView)return curView;let parent=dom.parentNode;dom=parent==cView.dom?0<dir?dom.nextSibling:dom.previousSibling:parent}return null}// Used to work around a Safari Selection/shadow DOM bug (#414)
function safariSelectionRangeHack(view){// Because Safari (at least in 2018-2021) doesn't provide regular
// access to the selection inside a shadowroot, we have to perform a
// ridiculous hack to get at it—using `execCommand` to trigger a
// `beforeInput` event so that we can read the target range from the
// event.
function read(event){event.preventDefault(),event.stopImmediatePropagation(),found=event.getTargetRanges()[0]}let found=null;if(view.contentDOM.addEventListener("beforeinput",read,!0),document.execCommand("indent"),view.contentDOM.removeEventListener("beforeinput",read,!0),!found)return null;let anchorNode=found.startContainer,anchorOffset=found.startOffset,focusNode=found.endContainer,focusOffset=found.endOffset,curAnchor=view.docView.domAtPos(view.state.selection.main.anchor);return isEquivalentPosition(curAnchor.node,curAnchor.offset,focusNode,focusOffset)&&([anchorNode,anchorOffset,focusNode,focusOffset]=[focusNode,focusOffset,anchorNode,anchorOffset]),{anchorNode,anchorOffset,focusNode,focusOffset}}function applyDOMChange(view,start,end,typeOver){let change,newSel,sel=view.state.selection.main;if(-1<start){let bounds=view.docView.domBoundsAround(start,end,0);if(!bounds||view.state.readOnly)return;let{from,to}=bounds,selPoints=view.docView.impreciseHead||view.docView.impreciseAnchor?[]:selectionPoints(view),reader=new DOMReader(selPoints,view);reader.readRange(bounds.startDOM,bounds.endDOM),newSel=selectionFromPoints(selPoints,from);let preferredPos=sel.from,preferredSide=null;// Prefer anchoring to end when Backspace is pressed (or, on
// Android, when something was deleted)
(8===view.inputState.lastKeyCode&&view.inputState.lastKeyTime>Date.now()-100||browser.android&&reader.text.length<to-from)&&(preferredPos=sel.to,preferredSide="end");let diff=findDiff(view.state.sliceDoc(from,to),reader.text,preferredPos-from,preferredSide);diff&&(change={from:from+diff.from,to:from+diff.toA,insert:view.state.toText(reader.text.slice(diff.from,diff.toB))})}else if(view.hasFocus||!view.state.facet(editable)){let domSel=view.observer.selectionRange,{impreciseHead:iHead,impreciseAnchor:iAnchor}=view.docView,head=iHead&&iHead.node==domSel.focusNode&&iHead.offset==domSel.focusOffset||!contains(view.contentDOM,domSel.focusNode)?view.state.selection.main.head:view.docView.posFromDOM(domSel.focusNode,domSel.focusOffset),anchor=iAnchor&&iAnchor.node==domSel.anchorNode&&iAnchor.offset==domSel.anchorOffset||!contains(view.contentDOM,domSel.anchorNode)?view.state.selection.main.anchor:view.docView.posFromDOM(domSel.anchorNode,domSel.anchorOffset);(head!=sel.head||anchor!=sel.anchor)&&(newSel=state.EditorSelection.single(anchor,head))}if(change||newSel)if(!change&&typeOver&&!sel.empty&&newSel&&newSel.main.empty?change={from:sel.from,to:sel.to,insert:view.state.doc.slice(sel.from,sel.to)}:change&&change.from>=sel.from&&change.to<=sel.to&&(change.from!=sel.from||change.to!=sel.to)&&4>=sel.to-sel.from-(change.to-change.from)&&(change={from:sel.from,to:sel.to,insert:view.state.doc.slice(sel.from,change.from).append(change.insert).append(view.state.doc.slice(change.to,sel.to))}),change){let startState=view.state;if(browser.ios&&view.inputState.flushIOSKey(view))return;// Android browsers don't fire reasonable key events for enter,
// backspace, or delete. So this detects changes that look like
// they're caused by those keys, and reinterprets them as key
// events. (Some of these keys are also handled by beforeinput
// events and the pendingAndroidKey mechanism, but that's not
// reliable in all situations.)
if(browser.android&&(change.from==sel.from&&change.to==sel.to&&1==change.insert.length&&2==change.insert.lines&&dispatchKey(view.contentDOM,"Enter",13)||change.from==sel.from-1&&change.to==sel.to&&0==change.insert.length&&dispatchKey(view.contentDOM,"Backspace",8)||change.from==sel.from&&change.to==sel.to+1&&0==change.insert.length&&dispatchKey(view.contentDOM,"Delete",46)))return;let text=change.insert.toString();if(view.state.facet(inputHandler).some(h=>h(view,change.from,change.to,text)))return;0<=view.inputState.composing&&view.inputState.composing++;let tr;if(change.from>=sel.from&&change.to<=sel.to&&change.to-change.from>=(sel.to-sel.from)/3&&(!newSel||newSel.main.empty&&newSel.main.from==change.from+change.insert.length)&&0>view.inputState.composing){let before=sel.from<change.from?startState.sliceDoc(sel.from,change.from):"",after=sel.to>change.to?startState.sliceDoc(change.to,sel.to):"";tr=startState.replaceSelection(view.state.toText(before+change.insert.sliceString(0,void 0,view.state.lineBreak)+after))}else{let changes=startState.changes(change),mainSel=newSel&&!startState.selection.main.eq(newSel.main)&&newSel.main.to<=changes.newLength?newSel.main:void 0;// Try to apply a composition change to all cursors
if(1<startState.selection.ranges.length&&0<=view.inputState.composing&&change.to<=sel.to&&change.to>=sel.to-10){let replaced=view.state.sliceDoc(change.from,change.to),compositionRange=compositionSurroundingNode(view)||view.state.doc.lineAt(sel.head),offset=sel.to-change.to,size=sel.to-sel.from;tr=startState.changeByRange(range=>{if(range.from==sel.from&&range.to==sel.to)return{changes,range:mainSel||range.map(changes)};let to=range.to-offset,from=to-replaced.length;if(range.to-range.from!=size||view.state.sliceDoc(from,to)!=replaced||// Unfortunately, there's no way to make multiple
// changes in the same node work without aborting
// composition, so cursors in the composition range are
// ignored.
compositionRange&&range.to>=compositionRange.from&&range.from<=compositionRange.to)return{range};let rangeChanges=startState.changes({from,to,insert:change.insert}),selOff=range.to-sel.to;return{changes:rangeChanges,range:mainSel?state.EditorSelection.range(Math.max(0,mainSel.anchor+selOff),Math.max(0,mainSel.head+selOff)):range.map(rangeChanges)}})}else tr={changes,selection:mainSel&&startState.selection.replaceRange(mainSel)}}let userEvent="input.type";view.composing&&(userEvent+=".compose",view.inputState.compositionFirstChange&&(userEvent+=".start",view.inputState.compositionFirstChange=!1)),view.dispatch(tr,{scrollIntoView:!0,userEvent})}else if(newSel&&!newSel.main.eq(sel)){let scrollIntoView=!1,userEvent="select";view.inputState.lastSelectionTime>Date.now()-50&&("select"==view.inputState.lastSelectionOrigin&&(scrollIntoView=!0),userEvent=view.inputState.lastSelectionOrigin),view.dispatch({selection:newSel,scrollIntoView,userEvent})}// Heuristic to notice typing over a selected character
}function findDiff(a,b,preferredPos,preferredSide){let minLen=Math.min(a.length,b.length),from=0;for(;from<minLen&&a.charCodeAt(from)==b.charCodeAt(from);)from++;if(from==minLen&&a.length==b.length)return null;let toA=a.length,toB=b.length;for(;0<toA&&0<toB&&a.charCodeAt(toA-1)==b.charCodeAt(toB-1);)toA--,toB--;if("end"==preferredSide){let adjust=Math.max(0,from-Math.min(toA,toB));preferredPos-=toA+adjust-from}if(toA<from&&a.length<b.length){let move=preferredPos<=from&&preferredPos>=toA?from-preferredPos:0;from-=move,toB=from+(toB-toA),toA=from}else if(toB<from){let move=preferredPos<=from&&preferredPos>=toB?from-preferredPos:0;from-=move,toA=from+(toA-toB),toB=from}return{from,toA,toB}}function selectionPoints(view){let result=[];if(view.root.activeElement!=view.contentDOM)return result;let{anchorNode,anchorOffset,focusNode,focusOffset}=view.observer.selectionRange;return anchorNode&&(result.push(new DOMPoint(anchorNode,anchorOffset)),(focusNode!=anchorNode||focusOffset!=anchorOffset)&&result.push(new DOMPoint(focusNode,focusOffset))),result}function selectionFromPoints(points,base){if(0==points.length)return null;let anchor=points[0].pos,head=2==points.length?points[1].pos:anchor;return-1<anchor&&-1<head?state.EditorSelection.single(anchor+base,head+base):null}// The editor's update state machine looks something like this:
//
//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle
//                                         ↑      ↓
//                                         Updating (measure)
//
// The difference between 'Idle' and 'Idle (unchecked)' lies in
// whether a layout check has been scheduled. A regular update through
// the `update` method updates the DOM in a write-only fashion, and
// relies on a check (scheduled with `requestAnimationFrame`) to make
// sure everything is where it should be and the viewport covers the
// visible code. That check continues to measure and then optionally
// update until it reaches a coherent state.
/// An editor view represents the editor's user interface. It holds
/// the editable DOM surface, and possibly other elements such as the
/// line number gutter. It handles events and dispatches state
/// transactions for editing actions.
// FIXME remove this and its callers on next breaking release
function ensureTop(given,view){return(null==given?view.contentDOM.getBoundingClientRect().top:given)+view.viewState.paddingTop}function ensureGlobalHandler(){window.addEventListener("resize",()=>{-1==resizeDebounce&&(resizeDebounce=setTimeout(handleResize,50))})}function handleResize(){resizeDebounce=-1;let found=document.querySelectorAll(".cm-content");for(let docView,i=0;i<found.length;i++)docView=ContentView.get(found[i]),docView&&docView.editorView.requestMeasure()}function attrsFromFacet(view,facet,base){for(let sources=view.state.facet(facet),i=sources.length-1;0<=i;i--){let source=sources[i],value="function"==typeof source?source(view):source;value&&combineAttrs(value,base)}return base}function normalizeKeyName(name,platform){const parts=name.split(/-(?!$)/);let result=parts[parts.length-1];"Space"==result&&(result=" ");let alt,ctrl,shift,meta;for(let i=0;i<parts.length-1;++i){const mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod))meta=!0;else if(/^a(lt)?$/i.test(mod))alt=!0;else if(/^(c|ctrl|control)$/i.test(mod))ctrl=!0;else if(/^s(hift)?$/i.test(mod))shift=!0;else if(/^mod$/i.test(mod))"mac"==platform?meta=!0:ctrl=!0;else throw new Error("Unrecognized modifier name: "+mod)}return alt&&(result="Alt-"+result),ctrl&&(result="Ctrl-"+result),meta&&(result="Meta-"+result),shift&&(result="Shift-"+result),result}function modifiers(name,event,shift){return event.altKey&&(name="Alt-"+name),event.ctrlKey&&(name="Ctrl-"+name),event.metaKey&&(name="Meta-"+name),!1!==shift&&event.shiftKey&&(name="Shift-"+name),name}// This is hidden behind an indirection, rather than directly computed
// by the facet, to keep internal types out of the facet's type.
function getKeymap(state){let bindings=state.facet(keymap),map=Keymaps.get(bindings);return map||Keymaps.set(bindings,map=buildKeymap(bindings.reduce((a,b)=>a.concat(b),[]))),map}/// Run the key handlers registered for a given scope. The event
/// object should be `"keydown"` event. Returns true if any of the
/// handlers handled it.
function buildKeymap(bindings,platform=currentPlatform){let bound=Object.create(null),isPrefix=Object.create(null),checkPrefix=(name,is)=>{let current=isPrefix[name];if(null==current)isPrefix[name]=is;else if(current!=is)throw new Error("Key binding "+name+" is used both as a regular binding and as a multi-stroke prefix")},add=(scope,key,command,preventDefault)=>{let scopeObj=bound[scope]||(bound[scope]=Object.create(null)),parts=key.split(/ (?!$)/).map(k=>normalizeKeyName(k,platform));for(let prefix,i=1;i<parts.length;i++)prefix=parts.slice(0,i).join(" "),checkPrefix(prefix,!0),scopeObj[prefix]||(scopeObj[prefix]={preventDefault:!0,commands:[view=>{let ourObj=storedPrefix={view,prefix,scope};return setTimeout(()=>{storedPrefix==ourObj&&(storedPrefix=null)},PrefixTimeout),!0}]});let full=parts.join(" ");checkPrefix(full,!1);let binding=scopeObj[full]||(scopeObj[full]={preventDefault:!1,commands:[]});binding.commands.push(command),preventDefault&&(binding.preventDefault=!0)};for(let b of bindings){let name=b[platform]||b.key;if(name)for(let scope of b.scope?b.scope.split(" "):["editor"])add(scope,name,b.run,b.preventDefault),b.shift&&add(scope,"Shift-"+name,b.shift,b.preventDefault)}return bound}function runHandlers(map,event,view,scope){let name=w3cKeyname.keyName(event),isChar=1==name.length&&" "!=name,prefix="",fallthrough=!1;storedPrefix&&storedPrefix.view==view&&storedPrefix.scope==scope&&(prefix=storedPrefix.prefix+" ",(fallthrough=0>modifierCodes.indexOf(event.keyCode))&&(storedPrefix=null));let baseName,runFor=binding=>{if(binding){for(let cmd of binding.commands)if(cmd(view))return!0;binding.preventDefault&&(fallthrough=!0)}return!1},scopeObj=map[scope];if(scopeObj){if(runFor(scopeObj[prefix+modifiers(name,event,!isChar)]))return!0;if(isChar&&(event.shiftKey||event.altKey||event.metaKey)&&(baseName=w3cKeyname.base[event.keyCode])&&baseName!=name){if(runFor(scopeObj[prefix+modifiers(baseName,event,!0)]))return!0;}else if(isChar&&event.shiftKey&&runFor(scopeObj[prefix+modifiers(name,event,!0)]))return!0}return fallthrough}function getBase(view){let rect=view.scrollDOM.getBoundingClientRect(),left=view.textDirection==exports.Direction.LTR?rect.left:rect.right-view.scrollDOM.clientWidth;return{left:left-view.scrollDOM.scrollLeft,top:rect.top-view.scrollDOM.scrollTop}}function wrappedLine(view,pos,inside){let range=state.EditorSelection.cursor(pos);return{from:Math.max(inside.from,view.moveToLineBoundary(range,!1,!0).from),to:Math.min(inside.to,view.moveToLineBoundary(range,!0,!0).from),type:exports.BlockType.Text}}function blockAt(view,pos){let line=view.lineBlockAt(pos);if(Array.isArray(line.type))for(let l of line.type)if(l.to>pos||l.to==pos&&(l.to==line.to||l.type==exports.BlockType.Text))return l;return line}function measureRange(view,range){function piece(left,top,right,bottom){return new Piece(left-base.left,top-base.top,right-left,bottom-top,"cm-selectionBackground")}function pieces({top,bottom,horizontal}){let pieces=[];for(let i=0;i<horizontal.length;i+=2)pieces.push(piece(horizontal[i],top,horizontal[i+1],bottom));return pieces}// Gets passed from/to in line-local positions
function drawForLine(from,to,line){function addSpan(from,fromOpen,to,toOpen,dir){// Passing 2/-2 is a kludge to force the view to return
// coordinates on the proper side of block widgets, since
// normalizing the side there, though appropriate for most
// coordsAtPos queries, would break selection drawing.
let fromCoords=view.coordsAtPos(from,from==line.to?-2:2),toCoords=view.coordsAtPos(to,to==line.from?2:-2);top=Math.min(fromCoords.top,toCoords.top,top),bottom=Math.max(fromCoords.bottom,toCoords.bottom,bottom),dir==exports.Direction.LTR?horizontal.push(ltr&&fromOpen?leftSide:fromCoords.left,ltr&&toOpen?rightSide:toCoords.right):horizontal.push(!ltr&&toOpen?leftSide:toCoords.left,!ltr&&fromOpen?rightSide:fromCoords.right)}let top=1e9,bottom=-1e9,horizontal=[],start=null!==from&&void 0!==from?from:line.from,end=null!==to&&void 0!==to?to:line.to;// Split the range by visible range and document line
for(let r of view.visibleRanges)if(r.to>start&&r.from<end)for(let docLine,pos=Math.max(r.from,start),endPos=Math.min(r.to,end);;){docLine=view.state.doc.lineAt(pos);for(let span of view.bidiSpans(docLine)){let spanFrom=span.from+docLine.from,spanTo=span.to+docLine.from;if(spanFrom>=endPos)break;spanTo>pos&&addSpan(Math.max(spanFrom,pos),null==from&&spanFrom<=start,Math.min(spanTo,endPos),null==to&&spanTo>=end,span.dir)}if(pos=docLine.to+1,pos>=endPos)break}return 0==horizontal.length&&addSpan(start,null==from,end,null==to,view.textDirection),{top,bottom,horizontal}}function drawForWidget(block,top){let y=contentRect.top+(top?block.top:block.bottom);return{top:y,bottom:y,horizontal:[]}}if(range.to<=view.viewport.from||range.from>=view.viewport.to)return[];let from=Math.max(range.from,view.viewport.from),to=Math.min(range.to,view.viewport.to),ltr=view.textDirection==exports.Direction.LTR,content=view.contentDOM,contentRect=content.getBoundingClientRect(),base=getBase(view),lineStyle=window.getComputedStyle(content.firstChild),leftSide=contentRect.left+parseInt(lineStyle.paddingLeft)+Math.min(0,parseInt(lineStyle.textIndent)),rightSide=contentRect.right-parseInt(lineStyle.paddingRight),startBlock=blockAt(view,from),endBlock=blockAt(view,to),visualStart=startBlock.type==exports.BlockType.Text?startBlock:null,visualEnd=endBlock.type==exports.BlockType.Text?endBlock:null;if(view.lineWrapping&&(visualStart&&(visualStart=wrappedLine(view,from,visualStart)),visualEnd&&(visualEnd=wrappedLine(view,to,visualEnd))),visualStart&&visualEnd&&visualStart.from==visualEnd.from)return pieces(drawForLine(range.from,range.to,visualStart));else{let top=visualStart?drawForLine(range.from,null,visualStart):drawForWidget(startBlock,!1),bottom=visualEnd?drawForLine(null,range.to,visualEnd):drawForWidget(endBlock,!0),between=[];return(visualStart||startBlock).to<(visualEnd||endBlock).from-1?between.push(piece(leftSide,top.bottom,rightSide,bottom.top)):top.bottom<bottom.top&&view.elementAtHeight((top.bottom+bottom.top)/2).type==exports.BlockType.Text&&(top.bottom=bottom.top=(top.bottom+bottom.top)/2),pieces(top).concat(between).concat(pieces(bottom))}}function measureCursor(view,cursor,primary){let pos=view.coordsAtPos(cursor.head,cursor.assoc||1);if(!pos)return null;let base=getBase(view);return new Piece(pos.left-base.left,pos.top-base.top,-1,pos.bottom-pos.top,primary?"cm-cursor cm-cursor-primary":"cm-cursor cm-cursor-secondary")}function iterMatches(doc,re,from,to,f){re.lastIndex=0;for(let m,cursor=doc.iterRange(from,to),pos=from;!cursor.next().done;pos+=cursor.value.length)if(!cursor.lineBreak)for(;m=re.exec(cursor.value);)f(pos+m.index,pos+m.index+m[0].length,m)}function matchRanges(view,maxLength){let visible=view.visibleRanges;if(1==visible.length&&visible[0].from==view.viewport.from&&visible[0].to==view.viewport.to)return visible;let result=[];for(let{from,to}of visible)from=Math.max(view.state.doc.lineAt(from).from,from-maxLength),to=Math.min(view.state.doc.lineAt(to).to,to+maxLength),result.length&&result[result.length-1].to>=from?result[result.length-1].to=to:result.push({from,to});return result}/// Helper class used to make it easier to maintain decorations on
/// visible code that matches a given regular expression. To be used
/// in a [view plugin](#view.ViewPlugin). Instances of this object
/// represent a matching configuration.
function supportsTabSize(){var _a;if(null==_supportsTabSize&&"undefined"!=typeof document&&document.body){let styles=document.body.style;_supportsTabSize=null!=(null!==(_a=styles.tabSize)&&void 0!==_a?_a:styles.MozTabSize)}return _supportsTabSize||!1}function specialCharPlugin(){return _plugin||(_plugin=ViewPlugin.fromClass(class{constructor(view){this.view=view,this.decorations=Decoration.none,this.decorationCache=Object.create(null),this.decorator=this.makeDecorator(view.state.facet(specialCharConfig)),this.decorations=this.decorator.createDeco(view)}makeDecorator(conf){return new MatchDecorator({regexp:conf.specialChars,decoration:(m,view,pos)=>{let{doc}=view.state,code=text.codePointAt(m[0],0);if(9==code){let line=doc.lineAt(pos),size=view.state.tabSize,col=text.countColumn(line.text,size,pos-line.from);return Decoration.replace({widget:new TabWidget((size-col%size)*this.view.defaultCharacterWidth)})}return this.decorationCache[code]||(this.decorationCache[code]=Decoration.replace({widget:new SpecialCharWidget(conf,code)}))},boundary:conf.replaceTabs?void 0:/[^]/})}update(update){let conf=update.state.facet(specialCharConfig);update.startState.facet(specialCharConfig)==conf?this.decorations=this.decorator.updateDeco(update,this.decorations):(this.decorator=this.makeDecorator(conf),this.decorations=this.decorator.createDeco(update.view))}},{decorations:v=>v.decorations}))}// Assigns placeholder characters from the Control Pictures block to
// ASCII control characters
function placeholder$1(code){return 32<=code?"\u2022":10==code?"\u2424":String.fromCharCode(9216+code)}Object.defineProperty(exports,"__esModule",{value:!0});var state=await require("@codemirror/state"),styleMod=await require("style-mod"),rangeset=await require("@codemirror/rangeset"),text=await require("@codemirror/text"),w3cKeyname=await require("w3c-keyname");const Rect0={left:0,right:0,top:0,bottom:0};class DOMSelectionState{constructor(){this.anchorNode=null,this.anchorOffset=0,this.focusNode=null,this.focusOffset=0}eq(domSel){return this.anchorNode==domSel.anchorNode&&this.anchorOffset==domSel.anchorOffset&&this.focusNode==domSel.focusNode&&this.focusOffset==domSel.focusOffset}setRange(range){this.set(range.anchorNode,range.anchorOffset,range.focusNode,range.focusOffset)}set(anchorNode,anchorOffset,focusNode,focusOffset){this.anchorNode=anchorNode,this.anchorOffset=anchorOffset,this.focusNode=focusNode,this.focusOffset=focusOffset}}let scratchRange,preventScrollSupported=null;class DOMPos{constructor(node,offset,precise=!0){this.node=node,this.offset=offset,this.precise=precise}static before(dom,precise){return new DOMPos(dom.parentNode,domIndex(dom),precise)}static after(dom,precise){return new DOMPos(dom.parentNode,domIndex(dom)+1,precise)}}const noChildren=[];class ContentView{constructor(){this.parent=null,this.dom=null,this.dirty=2/* Node */}get editorView(){if(!this.parent)throw new Error("Accessing view in orphan content view");return this.parent.editorView}get overrideDOMText(){return null}get posAtStart(){return this.parent?this.parent.posBefore(this):0}get posAtEnd(){return this.posAtStart+this.length}posBefore(view){let pos=this.posAtStart;for(let child of this.children){if(child==view)return pos;pos+=child.length+child.breakAfter}throw new RangeError("Invalid child in posBefore")}posAfter(view){return this.posBefore(view)+view.length}// Will return a rectangle directly before (when side < 0), after
// (side > 0) or directly on (when the browser supports it) the
// given position.
coordsAt(){return null}sync(track){if(2&this.dirty/* Node */){let parent=this.dom,pos=parent.firstChild;for(let child of this.children){if(child.dirty){if(!child.dom&&pos){let contentView=ContentView.get(pos);contentView&&(contentView.parent||contentView.constructor!=child.constructor)||child.reuseDOM(pos)}child.sync(track),child.dirty=0/* Not */}if(track&&!track.written&&track.node==parent&&pos!=child.dom&&(track.written=!0),child.dom.parentNode==parent){for(;pos&&pos!=child.dom;)pos=rm(pos);pos=child.dom.nextSibling}else parent.insertBefore(child.dom,pos)}for(pos&&track&&track.node==parent&&(track.written=!0);pos;)pos=rm(pos)}else if(1&this.dirty/* Child */)for(let child of this.children)child.dirty&&(child.sync(track),child.dirty=0/* Not */)}reuseDOM(){}localPosFromDOM(node,offset){let after;if(node==this.dom)after=this.dom.childNodes[offset];else{let bias=0==maxOffset(node)?0:0==offset?-1:1;for(;;){let parent=node.parentNode;if(parent==this.dom)break;0==bias&&parent.firstChild!=parent.lastChild&&(node==parent.firstChild?bias=-1:bias=1),node=parent}after=0>bias?node:node.nextSibling}if(after==this.dom.firstChild)return 0;for(;after&&!ContentView.get(after);)after=after.nextSibling;if(!after)return this.length;for(let child,i=0,pos=0;;i++){if(child=this.children[i],child.dom==after)return pos;pos+=child.length+child.breakAfter}}domBoundsAround(from,to,offset=0){let fromI=-1,fromStart=-1,toI=-1,toEnd=-1;for(let i=0,pos=offset,prevEnd=offset;i<this.children.length;i++){let child=this.children[i],end=pos+child.length;if(pos<from&&end>to)return child.domBoundsAround(from,to,pos);if(end>=from&&-1==fromI&&(fromI=i,fromStart=pos),pos>to&&child.dom.parentNode==this.dom){toI=i,toEnd=prevEnd;break}prevEnd=end,pos=end+child.breakAfter}return{from:fromStart,to:0>toEnd?offset+this.length:toEnd,startDOM:(fromI?this.children[fromI-1].dom.nextSibling:null)||this.dom.firstChild,endDOM:toI<this.children.length&&0<=toI?this.children[toI].dom:null}}markDirty(andParent=!1){this.dirty|=2/* Node */,this.markParentsDirty(andParent)}markParentsDirty(childList){for(let parent=this.parent;parent;parent=parent.parent){if(childList&&(parent.dirty|=2/* Node */),1&parent.dirty/* Child */)return;parent.dirty|=1/* Child */,childList=!1}}setParent(parent){this.parent!=parent&&(this.parent=parent,this.dirty&&this.markParentsDirty(!0))}setDOM(dom){this.dom&&(this.dom.cmView=null),this.dom=dom,dom.cmView=this}get rootView(){for(let parent,v=this;;){if(parent=v.parent,!parent)return v;v=parent}}replaceChildren(from,to,children=noChildren){this.markDirty();for(let child,i=from;i<to;i++)child=this.children[i],child.parent==this&&child.destroy();this.children.splice(from,to-from,...children);for(let i=0;i<children.length;i++)children[i].setParent(this)}ignoreMutation(){return!1}ignoreEvent(){return!1}childCursor(pos=this.length){return new ChildCursor(this.children,pos,this.children.length)}childPos(pos,bias=1){return this.childCursor().findPos(pos,bias)}toString(){let name=this.constructor.name.replace("View","");return name+(this.children.length?"("+this.children.join()+")":this.length?"["+("Text"==name?this.text:this.length)+"]":"")+(this.breakAfter?"#":"")}static get(node){return node.cmView}get isEditable(){return!0}merge(){return!1}become(){return!1}// When this is a zero-length view with a side, this should return a
// number <= 0 to indicate it is before its position, or a
// number > 0 when after its position.
getSide(){return 0}destroy(){this.parent=null}}ContentView.prototype.breakAfter=0;class ChildCursor{constructor(children,pos,i){this.children=children,this.pos=pos,this.i=i,this.off=0}findPos(pos,bias=1){for(;;){if(pos>this.pos||pos==this.pos&&(0<bias||0==this.i||this.children[this.i-1].breakAfter))return this.off=pos-this.pos,this;let next=this.children[--this.i];this.pos-=next.length+next.breakAfter}}}let[nav,doc]="undefined"==typeof navigator?[{userAgent:"",vendor:"",platform:""},{documentElement:{style:{}}}]:[navigator,document];const ie_edge=/Edge\/(\d+)/.exec(nav.userAgent),ie_upto10=/MSIE \d/.test(nav.userAgent),ie_11up=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent),ie=!!(ie_upto10||ie_11up||ie_edge),gecko=!ie&&/gecko\/(\d+)/i.test(nav.userAgent),chrome=!ie&&/Chrome\/(\d+)/.exec(nav.userAgent),webkit=("webkitFontSmoothing"in doc.documentElement.style),safari=!ie&&/Apple Computer/.test(nav.vendor),ios=safari&&(/Mobile\/\w+/.test(nav.userAgent)||2<nav.maxTouchPoints);var browser={mac:ios||/Mac/.test(nav.platform),windows:/Win/.test(nav.platform),linux:/Linux|X11/.test(nav.platform),ie,ie_version:ie_upto10?doc.documentMode||6:ie_11up?+ie_11up[1]:ie_edge?+ie_edge[1]:0,gecko,gecko_version:gecko?+(/Firefox\/(\d+)/.exec(nav.userAgent)||[0,0])[1]:0,chrome:!!chrome,chrome_version:chrome?+chrome[1]:0,ios,android:/Android\b/.test(nav.userAgent),webkit,safari,webkit_version:webkit?+(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent)||[0,0])[1]:0,tabSize:null==doc.documentElement.style.tabSize?"-moz-tab-size":"tab-size"};class TextView extends ContentView{constructor(text){super(),this.text=text}get length(){return this.text.length}createDOM(textDOM){this.setDOM(textDOM||document.createTextNode(this.text))}sync(track){this.dom||this.createDOM(),this.dom.nodeValue!=this.text&&(track&&track.node==this.dom&&(track.written=!0),this.dom.nodeValue=this.text)}reuseDOM(dom){3==dom.nodeType&&this.createDOM(dom)}merge(from,to,source){return!(source&&(!(source instanceof TextView)||this.length-(to-from)+source.length>256))&&(this.text=this.text.slice(0,from)+(source?source.text:"")+this.text.slice(to),this.markDirty(),!0)}split(from){let result=new TextView(this.text.slice(from));return this.text=this.text.slice(0,from),this.markDirty(),result}localPosFromDOM(node,offset){return node==this.dom?offset:offset?this.text.length:0}domAtPos(pos){return new DOMPos(this.dom,pos)}domBoundsAround(_from,_to,offset){return{from:offset,to:offset+this.length,startDOM:this.dom,endDOM:this.dom.nextSibling}}coordsAt(pos,side){return textCoords(this.dom,pos,side)}}class MarkView extends ContentView{constructor(mark,children=[],length=0){super(),this.mark=mark,this.children=children,this.length=length;for(let ch of children)ch.setParent(this)}setAttrs(dom){if(clearAttributes(dom),this.mark.class&&(dom.className=this.mark.class),this.mark.attrs)for(let name in this.mark.attrs)dom.setAttribute(name,this.mark.attrs[name]);return dom}reuseDOM(node){node.nodeName==this.mark.tagName.toUpperCase()&&(this.setDOM(node),this.dirty|=6/* Node */)}sync(track){this.dom?4&this.dirty/* Attrs */&&this.setAttrs(this.dom):this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))),super.sync(track)}merge(from,to,source,_hasStart,openStart,openEnd){return!(source&&(!(source instanceof MarkView&&source.mark.eq(this.mark))||from&&0>=openStart||to<this.length&&0>=openEnd))&&(mergeChildrenInto(this,from,to,source?source.children:[],openStart-1,openEnd-1),this.markDirty(),!0)}split(from){let result=[],off=0,detachFrom=-1,i=0;for(let elt of this.children){let end=off+elt.length;end>from&&result.push(off<from?elt.split(from-off):elt),0>detachFrom&&off>=from&&(detachFrom=i),off=end,i++}let length=this.length-from;return this.length=from,-1<detachFrom&&(this.children.length=detachFrom,this.markDirty()),new MarkView(this.mark,result,length)}domAtPos(pos){return inlineDOMAtPos(this.dom,this.children,pos)}coordsAt(pos,side){return coordsInChildren(this,pos,side)}}class WidgetView extends ContentView{constructor(widget,length,side){super(),this.widget=widget,this.length=length,this.side=side}static create(widget,length,side){return new(widget.customView||WidgetView)(widget,length,side)}split(from){let result=WidgetView.create(this.widget,this.length-from,this.side);return this.length-=from,result}sync(){this.dom&&this.widget.updateDOM(this.dom)||(this.setDOM(this.widget.toDOM(this.editorView)),this.dom.contentEditable="false")}getSide(){return this.side}merge(from,to,source,hasStart,openStart,openEnd){return!(source&&(!(source instanceof WidgetView)||!this.widget.compare(source.widget)||0<from&&0>=openStart||to<this.length&&0>=openEnd))&&(this.length=from+(source?source.length:0)+(this.length-to),!0)}become(other){return!!(other.length==this.length&&other instanceof WidgetView&&other.side==this.side&&this.widget.constructor==other.widget.constructor)&&(this.widget.eq(other.widget)||this.markDirty(!0),this.widget=other.widget,!0)}ignoreMutation(){return!0}ignoreEvent(event){return this.widget.ignoreEvent(event)}get overrideDOMText(){if(0==this.length)return text.Text.empty;let top=this;for(;top.parent;)top=top.parent;let view=top.editorView,text$1=view&&view.state.doc,start=this.posAtStart;return text$1?text$1.slice(start,start+this.length):text.Text.empty}domAtPos(pos){return 0==pos?DOMPos.before(this.dom):DOMPos.after(this.dom,pos==this.length)}domBoundsAround(){return null}coordsAt(pos,side){let rects=this.dom.getClientRects(),rect=null;if(!rects.length)return Rect0;for(let i=0<pos?rects.length-1:0;;i+=0<pos?-1:1)if(rect=rects[i],0<pos?0==i:i==rects.length-1||rect.top<rect.bottom)break;return 0==pos&&0<side||pos==this.length&&0>=side?rect:flattenRect(rect,0==pos)}get isEditable(){return!1}destroy(){super.destroy(),this.dom&&this.widget.destroy(this.dom)}}class CompositionView extends WidgetView{domAtPos(pos){return new DOMPos(this.widget.text,pos)}sync(){this.setDOM(this.widget.toDOM())}localPosFromDOM(node,offset){return offset?3==node.nodeType?Math.min(offset,this.length):this.length:0}ignoreMutation(){return!1}get overrideDOMText(){return null}coordsAt(pos,side){return textCoords(this.widget.text,pos,side)}get isEditable(){return!0}}// Use two characters on Android, to prevent Chrome from closing the
// virtual keyboard when backspacing after a widget (#602).
const ZeroWidthSpace=browser.android?"\u200B\u200B":"\u200B";// These are drawn around uneditable widgets to avoid a number of
// browser bugs that show up when the cursor is directly next to
// uneditable inline content.
class WidgetBufferView extends ContentView{constructor(side){super(),this.side=side}get length(){return 0}merge(){return!1}become(other){return other instanceof WidgetBufferView&&other.side==this.side}split(){return new WidgetBufferView(this.side)}sync(){this.dom?this.dirty&&this.dom.nodeValue!=ZeroWidthSpace&&(this.dom.nodeValue=ZeroWidthSpace):this.setDOM(document.createTextNode(ZeroWidthSpace))}getSide(){return this.side}domAtPos(){return DOMPos.before(this.dom)}localPosFromDOM(){return 0}domBoundsAround(){return null}coordsAt(){let rects=clientRectsFor(this.dom);return rects[rects.length-1]||null}get overrideDOMText(){return text.Text.of([this.dom.nodeValue.replace(/\u200b/g,"")])}}TextView.prototype.children=WidgetView.prototype.children=WidgetBufferView.prototype.children=noChildren;class WidgetType{/// Compare this instance to another instance of the same type.
/// (TypeScript can't express this, but only instances of the same
/// specific class will be passed to this method.) This is used to
/// avoid redrawing widgets when they are replaced by a new
/// decoration of the same type. The default implementation just
/// returns `false`, which will cause new instances of the widget to
/// always be redrawn.
eq(){return!1}/// Update a DOM element created by a widget of the same type (but
/// different, non-`eq` content) to reflect this widget. May return
/// true to indicate that it could update, false to indicate it
/// couldn't (in which case the widget will be redrawn). The default
/// implementation just returns false.
updateDOM(){return!1}/// @internal
compare(other){return this==other||this.constructor==other.constructor&&this.eq(other)}/// The estimated height this widget will have, to be used when
/// estimating the height of content that hasn't been drawn. May
/// return -1 to indicate you don't know. The default implementation
/// returns -1.
get estimatedHeight(){return-1}/// Can be used to configure which kinds of events inside the widget
/// should be ignored by the editor. The default is to ignore all
/// events.
ignoreEvent(){return!0}/// @internal
get customView(){return null}/// This is called when the an instance of the widget is removed
/// from the editor view.
destroy(){}}/// The different types of blocks that can occur in an editor view.
exports.BlockType=void 0,function(BlockType){BlockType[BlockType.Text=0]="Text",BlockType[BlockType.WidgetBefore=1]="WidgetBefore",BlockType[BlockType.WidgetAfter=2]="WidgetAfter",BlockType[BlockType.WidgetRange=3]="WidgetRange"}(exports.BlockType||(exports.BlockType={}));/// A decoration provides information on how to draw or style a piece
/// of content. You'll usually use it wrapped in a
/// [`Range`](#rangeset.Range), which adds a start and end position.
class Decoration extends rangeset.RangeValue{/// @internal
constructor(/// @internal
startSide,/// @internal
endSide,/// @internal
widget,/// The config object used to create this decoration. You can
/// include additional properties in there to store metadata about
/// your decoration.
spec){super(),this.startSide=startSide,this.endSide=endSide,this.widget=widget,this.spec=spec}/// @internal
get heightRelevant(){return!1}/// Create a mark decoration, which influences the styling of the
/// content in its range. Nested mark decorations will cause nested
/// DOM elements to be created. Nesting order is determined by
/// precedence of the [facet](#view.EditorView^decorations) or
/// (below the facet-provided decorations) [view
/// plugin](#view.PluginSpec.decorations). Such elements are split
/// on line boundaries and on the boundaries of higher-precedence
/// decorations.
static mark(spec){return new MarkDecoration(spec)}/// Create a widget decoration, which adds an element at the given
/// position.
static widget(spec){let side=spec.side||0,block=!!spec.block;return side+=block?0<side?3e8/* BlockAfter */:-4e8/* BlockBefore */:0<side?1e8/* InlineAfter */:-1e8/* InlineBefore */,new PointDecoration(spec,side,side,block,spec.widget||null,!1)}/// Create a replace decoration which replaces the given range with
/// a widget, or simply hides it.
static replace(spec){let block=!!spec.block,{start,end}=getInclusive(spec,block),startSide=block?start?-3e8/* BlockIncStart */:-1/* InlineIncStart */:4e8/* NonIncStart */,endSide=block?end?2e8/* BlockIncEnd */:1/* InlineIncEnd */:-5e8/* NonIncEnd */;return new PointDecoration(spec,startSide,endSide,block,spec.widget||null,!0)}/// Create a line decoration, which can add DOM attributes to the
/// line starting at the given position.
static line(spec){return new LineDecoration(spec)}/// Build a [`DecorationSet`](#view.DecorationSet) from the given
/// decorated range or ranges. If the ranges aren't already sorted,
/// pass `true` for `sort` to make the library sort them for you.
static set(of,sort=!1){return rangeset.RangeSet.of(of,sort)}/// @internal
hasHeight(){return!!this.widget&&-1<this.widget.estimatedHeight}}/// The empty set of decorations.
Decoration.none=rangeset.RangeSet.empty;class MarkDecoration extends Decoration{constructor(spec){let{start,end}=getInclusive(spec);super(start?-1/* InlineIncStart */:4e8/* NonIncStart */,end?1/* InlineIncEnd */:-5e8/* NonIncEnd */,null,spec),this.tagName=spec.tagName||"span",this.class=spec.class||"",this.attrs=spec.attributes||null}eq(other){return this==other||other instanceof MarkDecoration&&this.tagName==other.tagName&&this.class==other.class&&attrsEq(this.attrs,other.attrs)}range(from,to=from){if(from>=to)throw new RangeError("Mark decorations may not be empty");return super.range(from,to)}}MarkDecoration.prototype.point=!1;class LineDecoration extends Decoration{constructor(spec){super(-2e8/* Line */,-2e8/* Line */,null,spec)}eq(other){return other instanceof LineDecoration&&attrsEq(this.spec.attributes,other.spec.attributes)}range(from,to=from){if(to!=from)throw new RangeError("Line decoration ranges must be zero-length");return super.range(from,to)}}LineDecoration.prototype.mapMode=state.MapMode.TrackBefore,LineDecoration.prototype.point=!0;class PointDecoration extends Decoration{constructor(spec,startSide,endSide,block,widget,isReplace){super(startSide,endSide,widget,spec),this.block=block,this.isReplace=isReplace,this.mapMode=block?0>=startSide?state.MapMode.TrackBefore:state.MapMode.TrackAfter:state.MapMode.TrackDel}// Only relevant when this.block == true
get type(){return this.startSide<this.endSide?exports.BlockType.WidgetRange:0>=this.startSide?exports.BlockType.WidgetBefore:exports.BlockType.WidgetAfter}get heightRelevant(){return this.block||!!this.widget&&5<=this.widget.estimatedHeight}eq(other){return other instanceof PointDecoration&&widgetsEq(this.widget,other.widget)&&this.block==other.block&&this.startSide==other.startSide&&this.endSide==other.endSide}range(from,to=from){if(this.isReplace&&(from>to||from==to&&0<this.startSide&&0>=this.endSide))throw new RangeError("Invalid range for replacement decoration");if(!this.isReplace&&to!=from)throw new RangeError("Widget decorations can only have zero-length ranges");return super.range(from,to)}}PointDecoration.prototype.point=!0;class LineView extends ContentView{constructor(){super(...arguments),this.children=[],this.length=0,this.prevAttrs=void 0,this.attrs=null,this.breakAfter=0}// Consumes source
merge(from,to,source,hasStart,openStart,openEnd){if(source){if(!(source instanceof LineView))return!1;this.dom||source.transferDOM(this)}return hasStart&&this.setDeco(source?source.attrs:null),mergeChildrenInto(this,from,to,source?source.children:[],openStart,openEnd),!0}split(at){let end=new LineView;if(end.breakAfter=this.breakAfter,0==this.length)return end;let{i,off}=this.childPos(at);off&&(end.append(this.children[i].split(off),0),this.children[i].merge(off,this.children[i].length,null,!1,0,0),i++);for(let j=i;j<this.children.length;j++)end.append(this.children[j],0);for(;0<i&&0==this.children[i-1].length;)this.children[--i].destroy();return this.children.length=i,this.markDirty(),this.length=at,end}transferDOM(other){this.dom&&(other.setDOM(this.dom),other.prevAttrs=void 0===this.prevAttrs?this.attrs:this.prevAttrs,this.prevAttrs=void 0,this.dom=null)}setDeco(attrs){attrsEq(this.attrs,attrs)||(this.dom&&(this.prevAttrs=this.attrs,this.markDirty()),this.attrs=attrs)}append(child,openStart){joinInlineInto(this,child,openStart)}// Only called when building a line view in ContentBuilder
addLineDeco(deco){let attrs=deco.spec.attributes,cls=deco.spec.class;attrs&&(this.attrs=combineAttrs(attrs,this.attrs||{})),cls&&(this.attrs=combineAttrs({class:cls},this.attrs||{}))}domAtPos(pos){return inlineDOMAtPos(this.dom,this.children,pos)}reuseDOM(node){"DIV"==node.nodeName&&(this.setDOM(node),this.dirty|=6/* Node */)}sync(track){var _a;this.dom?4&this.dirty/* Attrs */&&(clearAttributes(this.dom),this.dom.className="cm-line",this.prevAttrs=this.attrs?null:void 0):(this.setDOM(document.createElement("div")),this.dom.className="cm-line",this.prevAttrs=this.attrs?null:void 0),void 0!==this.prevAttrs&&(updateAttrs(this.dom,this.prevAttrs,this.attrs),this.dom.classList.add("cm-line"),this.prevAttrs=void 0),super.sync(track);let last=this.dom.lastChild;for(;last&&ContentView.get(last)instanceof MarkView;)last=last.lastChild;if(!last||"BR"!=last.nodeName&&!1==(null===(_a=ContentView.get(last))||void 0===_a?void 0:_a.isEditable)&&(!browser.ios||!this.children.some(ch=>ch instanceof TextView))){let hack=document.createElement("BR");hack.cmIgnore=!0,this.dom.appendChild(hack)}}measureTextSize(){if(0==this.children.length||20<this.length)return null;let totalWidth=0;for(let child of this.children){if(!(child instanceof TextView))return null;let rects=clientRectsFor(child.dom);if(1!=rects.length)return null;totalWidth+=rects[0].width}return{lineHeight:this.dom.getBoundingClientRect().height,charWidth:totalWidth/this.length}}coordsAt(pos,side){return coordsInChildren(this,pos,side)}become(){return!1}get type(){return exports.BlockType.Text}static find(docView,pos){for(let i=0,off=0;i<docView.children.length;i++){let block=docView.children[i],end=off+block.length;if(end>=pos){if(block instanceof LineView)return block;if(end>pos)break}off=end+block.breakAfter}return null}}class BlockWidgetView extends ContentView{constructor(widget,length,type){super(),this.widget=widget,this.length=length,this.type=type,this.breakAfter=0}merge(from,to,source,_takeDeco,openStart,openEnd){return!(source&&(!(source instanceof BlockWidgetView)||!this.widget.compare(source.widget)||0<from&&0>=openStart||to<this.length&&0>=openEnd))&&(this.length=from+(source?source.length:0)+(this.length-to),!0)}domAtPos(pos){return 0==pos?DOMPos.before(this.dom):DOMPos.after(this.dom,pos==this.length)}split(at){let len=this.length-at;this.length=at;let end=new BlockWidgetView(this.widget,len,this.type);return end.breakAfter=this.breakAfter,end}get children(){return noChildren}sync(){this.dom&&this.widget.updateDOM(this.dom)||(this.setDOM(this.widget.toDOM(this.editorView)),this.dom.contentEditable="false")}get overrideDOMText(){return this.parent?this.parent.view.state.doc.slice(this.posAtStart,this.posAtEnd):state.Text.empty}domBoundsAround(){return null}become(other){return!!(other instanceof BlockWidgetView&&other.type==this.type&&other.widget.constructor==this.widget.constructor)&&(other.widget.eq(this.widget)||this.markDirty(!0),this.widget=other.widget,this.length=other.length,this.breakAfter=other.breakAfter,!0)}ignoreMutation(){return!0}ignoreEvent(event){return this.widget.ignoreEvent(event)}destroy(){super.destroy(),this.dom&&this.widget.destroy(this.dom)}}class ContentBuilder{constructor(doc,pos,end,disallowBlockEffectsBelow){this.doc=doc,this.pos=pos,this.end=end,this.disallowBlockEffectsBelow=disallowBlockEffectsBelow,this.content=[],this.curLine=null,this.breakAtStart=0,this.pendingBuffer=0/* No */,this.atCursorPos=!0,this.openStart=-1,this.openEnd=-1,this.text="",this.textOff=0,this.cursor=doc.iter(),this.skip=pos}posCovered(){if(0==this.content.length)return!this.breakAtStart&&this.doc.lineAt(this.pos).from!=this.pos;let last=this.content[this.content.length-1];return!last.breakAfter&&!(last instanceof BlockWidgetView&&last.type==exports.BlockType.WidgetBefore)}getLine(){return this.curLine||(this.content.push(this.curLine=new LineView),this.atCursorPos=!0),this.curLine}flushBuffer(active){this.pendingBuffer&&(this.curLine.append(wrapMarks(new WidgetBufferView(-1),active),active.length),this.pendingBuffer=0/* No */)}addBlockWidget(view){this.flushBuffer([]),this.curLine=null,this.content.push(view)}finish(openEnd){openEnd?this.pendingBuffer=0/* No */:this.flushBuffer([]),this.posCovered()||this.getLine()}buildText(length,active,openStart){for(;0<length;){if(this.textOff==this.text.length){let{value,lineBreak,done}=this.cursor.next(this.skip);if(this.skip=0,done)throw new Error("Ran out of text content when drawing inline views");if(lineBreak){this.posCovered()||this.getLine(),this.content.length?this.content[this.content.length-1].breakAfter=1:this.breakAtStart=1,this.flushBuffer([]),this.curLine=null,length--;continue}else this.text=value,this.textOff=0}let take=Math.min(this.text.length-this.textOff,length,512/* Chunk */);this.flushBuffer(active),this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff,this.textOff+take)),active),openStart),this.atCursorPos=!0,this.textOff+=take,length-=take,openStart=0}}span(from,to,active,openStart){this.buildText(to-from,active,openStart),this.pos=to,0>this.openStart&&(this.openStart=openStart)}point(from,to,deco,active,openStart){let len=to-from;if(!(deco instanceof PointDecoration))this.doc.lineAt(this.pos).from==this.pos&&// Line decoration
this.getLine().addLineDeco(deco);else if(deco.block){let{type}=deco;type!=exports.BlockType.WidgetAfter||this.posCovered()||this.getLine(),this.addBlockWidget(new BlockWidgetView(deco.widget||new NullWidget("div"),len,type))}else{let view=WidgetView.create(deco.widget||new NullWidget("span"),len,deco.startSide),cursorBefore=this.atCursorPos&&!view.isEditable&&openStart<=active.length&&(from<to||0<deco.startSide),cursorAfter=!view.isEditable&&(from<to||0>=deco.startSide),line=this.getLine();2!=this.pendingBuffer/* IfCursor */||cursorBefore||(this.pendingBuffer=0/* No */),this.flushBuffer(active),cursorBefore&&(line.append(wrapMarks(new WidgetBufferView(1),active),openStart),openStart=active.length+Math.max(0,openStart-active.length)),line.append(wrapMarks(view,active),openStart),this.atCursorPos=cursorAfter,this.pendingBuffer=cursorAfter?from<to?1/* Yes */:2:0/* No */ /* IfCursor */}len&&(this.textOff+len<=this.text.length?this.textOff+=len:(this.skip+=len-(this.text.length-this.textOff),this.text="",this.textOff=0),this.pos=to),0>this.openStart&&(this.openStart=openStart)}filterPoint(from,to,value,index){if(index>=this.disallowBlockEffectsBelow||!(value instanceof PointDecoration))return!0;if(value.block)throw new RangeError("Block decorations may not be specified via plugins");return to<=this.doc.lineAt(this.pos).to}static build(text,from,to,decorations,pluginDecorationLength){let builder=new ContentBuilder(text,from,to,pluginDecorationLength);return builder.openEnd=rangeset.RangeSet.spans(decorations,from,to,builder),0>builder.openStart&&(builder.openStart=builder.openEnd),builder.finish(builder.openEnd),builder}}class NullWidget extends WidgetType{constructor(tag){super(),this.tag=tag}eq(other){return other.tag==this.tag}toDOM(){return document.createElement(this.tag)}updateDOM(elt){return elt.nodeName.toLowerCase()==this.tag}}const none=[],clickAddsSelectionRange=state.Facet.define(),dragMovesSelection$1=state.Facet.define(),mouseSelectionStyle=state.Facet.define(),exceptionSink=state.Facet.define(),updateListener=state.Facet.define(),inputHandler=state.Facet.define(),scrollTo=state.StateEffect.define({map:(range,changes)=>range.map(changes)}),centerOn=state.StateEffect.define({map:(range,changes)=>range.map(changes)});class ScrollTarget{constructor(range,y="nearest",x="nearest",yMargin=5,xMargin=5){this.range=range,this.y=y,this.x=x,this.yMargin=yMargin,this.xMargin=xMargin}map(changes){return changes.empty?this:new ScrollTarget(this.range.map(changes),this.y,this.x,this.yMargin,this.xMargin)}}const scrollIntoView=state.StateEffect.define({map:(t,ch)=>t.map(ch)}),editable=state.Facet.define({combine:values=>!values.length||values[0]});/// Used to [declare](#view.PluginSpec.provide) which
/// [fields](#view.PluginValue) a [view plugin](#view.ViewPlugin)
/// provides.
class PluginFieldProvider{/// @internal
constructor(/// @internal
field,/// @internal
get){this.field=field,this.get=get}}/// Plugin fields are a mechanism for allowing plugins to provide
/// values that can be retrieved through the
/// [`pluginField`](#view.EditorView.pluginField) view method.
class PluginField{/// Create a [provider](#view.PluginFieldProvider) for this field,
/// to use with a plugin's [provide](#view.PluginSpec.provide)
/// option.
from(get){return new PluginFieldProvider(this,get)}/// Define a new plugin field.
static define(){return new PluginField}}/// This field can be used by plugins to provide
/// [decorations](#view.Decoration).
///
/// **Note**: For reasons of data flow (plugins are only updated
/// after the viewport is computed), decorations produced by plugins
/// are _not_ taken into account when predicting the vertical layout
/// structure of the editor. They **must not** introduce block
/// widgets (that will raise an error) or replacing decorations that
/// cover line breaks (these will be ignored if they occur). Such
/// decorations, or others that cause a large amount of vertical
/// size shift compared to the undecorated content, should be
/// provided through the state-level [`decorations`
/// facet](#view.EditorView^decorations) instead.
PluginField.decorations=PluginField.define(),PluginField.atomicRanges=PluginField.define(),PluginField.scrollMargins=PluginField.define();let nextPluginID=0;const viewPlugin=state.Facet.define();/// View plugins associate stateful values with a view. They can
/// influence the way the content is drawn, and are notified of things
/// that happen in the view.
class ViewPlugin{constructor(/// @internal
id,/// @internal
create,/// @internal
fields){this.id=id,this.create=create,this.fields=fields,this.extension=viewPlugin.of(this)}/// Define a plugin from a constructor function that creates the
/// plugin's value, given an editor view.
static define(create,spec){let{eventHandlers,provide,decorations}=spec||{},fields=[];if(provide)for(let provider of Array.isArray(provide)?provide:[provide])fields.push(provider);return eventHandlers&&fields.push(domEventHandlers.from(value=>({plugin:value,handlers:eventHandlers}))),decorations&&fields.push(PluginField.decorations.from(decorations)),new ViewPlugin(nextPluginID++,create,fields)}/// Create a plugin for a class whose constructor takes a single
/// editor view as argument.
static fromClass(cls,spec){return ViewPlugin.define(view=>new cls(view),spec)}}const domEventHandlers=PluginField.define();class PluginInstance{constructor(spec){this.spec=spec,this.mustUpdate=null,this.value=null}takeField(type,target){if(this.spec)for(let{field,get}of this.spec.fields)field==type&&target.push(get(this.value))}update(view){if(!this.value){if(this.spec)try{this.value=this.spec.create(view)}catch(e){logException(view.state,e,"CodeMirror plugin crashed"),this.deactivate()}}else if(this.mustUpdate){let update=this.mustUpdate;if(this.mustUpdate=null,this.value.update)try{this.value.update(update)}catch(e){if(logException(update.state,e,"CodeMirror plugin crashed"),this.value.destroy)try{this.value.destroy()}catch(_){}this.deactivate()}}return this}destroy(view){var _a;if(null===(_a=this.value)||void 0===_a?void 0:_a.destroy)try{this.value.destroy()}catch(e){logException(view.state,e,"CodeMirror plugin crashed")}}deactivate(){this.spec=this.value=null}}const editorAttributes=state.Facet.define(),contentAttributes=state.Facet.define(),decorations=state.Facet.define(),styleModule=state.Facet.define();class ChangedRange{constructor(fromA,toA,fromB,toB){this.fromA=fromA,this.toA=toA,this.fromB=fromB,this.toB=toB}join(other){return new ChangedRange(Math.min(this.fromA,other.fromA),Math.max(this.toA,other.toA),Math.min(this.fromB,other.fromB),Math.max(this.toB,other.toB))}addToSet(set){let i=set.length,me=this;for(;0<i;i--){let range=set[i-1];if(!(range.fromA>me.toA)){if(range.toA<me.fromA)break;me=me.join(range),set.splice(i-1,1)}}return set.splice(i,0,me),set}static extendWithRanges(diff,ranges){if(0==ranges.length)return diff;let result=[];for(let dI=0,rI=0,posA=0,posB=0;;dI++){let next=dI==diff.length?null:diff[dI],off=posA-posB,end=next?next.fromB:1e9;for(;rI<ranges.length&&ranges[rI]<end;){let from=ranges[rI],to=ranges[rI+1],fromB=Math.max(posB,from),toB=Math.min(end,to);if(fromB<=toB&&new ChangedRange(fromB+off,toB+off,fromB,toB).addToSet(result),to>end)break;else rI+=2}if(!next)return result;new ChangedRange(next.fromA,next.toA,next.fromB,next.toB).addToSet(result),posA=next.toA,posB=next.toB}}}/// View [plugins](#view.ViewPlugin) are given instances of this
/// class, which describe what happened, whenever the view is updated.
class ViewUpdate{/// @internal
constructor(/// The editor view that the update is associated with.
view,/// The new editor state.
state$1,/// The transactions involved in the update. May be empty.
transactions=none){this.view=view,this.state=state$1,this.transactions=transactions,this.flags=0,this.startState=view.state,this.changes=state.ChangeSet.empty(this.startState.doc.length);for(let tr of transactions)this.changes=this.changes.compose(tr.changes);let changedRanges=[];this.changes.iterChangedRanges((fromA,toA,fromB,toB)=>changedRanges.push(new ChangedRange(fromA,toA,fromB,toB))),this.changedRanges=changedRanges;let focus=view.hasFocus;focus!=view.inputState.notifiedFocused&&(view.inputState.notifiedFocused=focus,this.flags|=1/* Focus */)}/// Tells you whether the [viewport](#view.EditorView.viewport) or
/// [visible ranges](#view.EditorView.visibleRanges) changed in this
/// update.
get viewportChanged(){return 0<(4&this.flags/* Viewport */)}/// Indicates whether the height of an element in the editor changed
/// in this update.
get heightChanged(){return 0<(2&this.flags/* Height */)}/// Returns true when the document was modified or the size of the
/// editor, or elements within the editor, changed.
get geometryChanged(){return this.docChanged||0<(10/* Height */&this.flags)}/// True when this update indicates a focus change.
get focusChanged(){return 0<(1&this.flags/* Focus */)}/// Whether the document changed in this update.
get docChanged(){return!this.changes.empty}/// Whether the selection was explicitly set in this update.
get selectionSet(){return this.transactions.some(tr=>tr.selection)}/// @internal
get empty(){return 0==this.flags&&0==this.transactions.length}}/// Used to indicate [text direction](#view.EditorView.textDirection).
exports.Direction=void 0,function(Direction){Direction[Direction.LTR=0]="LTR",Direction[Direction.RTL=1]="RTL"}(exports.Direction||(exports.Direction={}));const LTR=exports.Direction.LTR,RTL=exports.Direction.RTL,LowTypes=dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"),ArabicTypes=dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"),Brackets=Object.create(null),BracketStack=[];// There's a lot more in
// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,
// which are left out to keep code size down.
for(let p of["()","[]","{}"]){let l=p.charCodeAt(0),r=p.charCodeAt(1);Brackets[l]=r,Brackets[r]=-l}const BidiRE=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;/// Represents a contiguous range of text that has a single direction
/// (as in left-to-right or right-to-left).
class BidiSpan{/// @internal
constructor(/// The start of the span (relative to the start of the line).
from,/// The end of the span.
to,/// The ["bidi
/// level"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)
/// of the span (in this context, 0 means
/// left-to-right, 1 means right-to-left, 2 means left-to-right
/// number inside right-to-left text).
level){this.from=from,this.to=to,this.level=level}/// The direction of this span.
get dir(){return this.level%2?RTL:LTR}/// @internal
side(end,dir){return this.dir==dir==end?this.to:this.from}/// @internal
static find(order,index,level,assoc){let maybe=-1;for(let span,i=0;i<order.length;i++)if(span=order[i],span.from<=index&&span.to>=index){if(span.level==level)return i;// When multiple spans match, if assoc != 0, take the one that
// covers that side, otherwise take the one with the minimum
// level.
(0>maybe||(0==assoc?order[maybe].level>span.level:0>assoc?span.from<index:span.to>index))&&(maybe=i)}if(0>maybe)throw new RangeError("Index out of range");return maybe}}// Reused array of character types
const types=[];let movedOver="";class DOMReader{constructor(points,view){this.points=points,this.view=view,this.text="",this.lineBreak=view.state.lineBreak}readRange(start,end){if(!start)return this;let parent=start.parentNode;for(let cur=start;;){this.findPointBefore(parent,cur),this.readNode(cur);let next=cur.nextSibling;if(next==end)break;let view=ContentView.get(cur),nextView=ContentView.get(next);(view&&nextView?view.breakAfter:(view?view.breakAfter:isBlockElement(cur))||isBlockElement(next)&&("BR"!=cur.nodeName||cur.cmIgnore))&&(this.text+=this.lineBreak),cur=next}return this.findPointBefore(parent,end),this}readNode(node){if(node.cmIgnore)return;let text,view=ContentView.get(node),fromView=view&&view.overrideDOMText;null==fromView?3==node.nodeType?text=node.nodeValue:"BR"==node.nodeName?text=node.nextSibling?this.lineBreak:"":1==node.nodeType&&this.readRange(node.firstChild,null):text=fromView.sliceString(0,void 0,this.lineBreak),null!=text&&(this.findPointIn(node,text.length),this.text+=text,browser.chrome&&13==this.view.inputState.lastKeyCode&&!node.nextSibling&&/\n\n$/.test(this.text)&&(this.text=this.text.slice(0,-1)))}findPointBefore(node,next){for(let point of this.points)point.node==node&&node.childNodes[point.offset]==next&&(point.pos=this.text.length)}findPointIn(node,maxLen){for(let point of this.points)point.node==node&&(point.pos=this.text.length+Math.min(point.offset,maxLen))}}class DOMPoint{constructor(node,offset){this.node=node,this.offset=offset,this.pos=-1}}class DocView extends ContentView{constructor(view){super(),this.view=view,this.compositionDeco=Decoration.none,this.decorations=[],this.pluginDecorationLength=0,this.minWidth=0,this.minWidthFrom=0,this.minWidthTo=0,this.impreciseAnchor=null,this.impreciseHead=null,this.forceSelection=!1,this.lastUpdate=Date.now(),this.setDOM(view.contentDOM),this.children=[new LineView],this.children[0].setParent(this),this.updateDeco(),this.updateInner([new ChangedRange(0,0,0,view.state.doc.length)],0)}get root(){return this.view.root}get editorView(){return this.view}get length(){return this.view.state.doc.length}// Update the document view to a given state. scrollIntoView can be
// used as a hint to compute a new viewport that includes that
// position, if we know the editor is going to scroll that position
// into view.
update(update){let changedRanges=update.changedRanges;0<this.minWidth&&changedRanges.length&&(changedRanges.every(({fromA,toA})=>toA<this.minWidthFrom||fromA>this.minWidthTo)?(this.minWidthFrom=update.changes.mapPos(this.minWidthFrom,1),this.minWidthTo=update.changes.mapPos(this.minWidthTo,1)):this.minWidth=this.minWidthFrom=this.minWidthTo=0),0>this.view.inputState.composing?this.compositionDeco=Decoration.none:(update.transactions.length||this.dirty)&&(this.compositionDeco=computeCompositionDeco(this.view,update.changes)),(browser.ie||browser.chrome)&&!this.compositionDeco.size&&update&&update.state.doc.lines!=update.startState.doc.lines&&(this.forceSelection=!0);let prevDeco=this.decorations,deco=this.updateDeco(),decoDiff=findChangedDeco(prevDeco,deco,update.changes);return changedRanges=ChangedRange.extendWithRanges(changedRanges,decoDiff),(0!=this.dirty/* Not */||0!=changedRanges.length)&&(this.updateInner(changedRanges,update.startState.doc.length),update.transactions.length&&(this.lastUpdate=Date.now()),!0)}// Used by update and the constructor do perform the actual DOM
// update
updateInner(changes,oldLength){this.view.viewState.mustMeasureContent=!0,this.updateChildren(changes,oldLength);let{observer}=this.view;observer.ignore(()=>{this.dom.style.height=this.view.viewState.contentHeight+"px",this.dom.style.minWidth=this.minWidth?this.minWidth+"px":"";// Chrome will sometimes, when DOM mutations occur directly
// around the selection, get confused and report a different
// selection from the one it displays (issue #218). This tries
// to detect that situation.
let track=browser.chrome||browser.ios?{node:observer.selectionRange.focusNode,written:!1}:void 0;this.sync(track),this.dirty=0/* Not */,track&&(track.written||observer.selectionRange.focusNode!=track.node)&&(this.forceSelection=!0),this.dom.style.height=""});let gaps=[];if(this.view.viewport.from||this.view.viewport.to<this.view.state.doc.length)for(let child of this.children)child instanceof BlockWidgetView&&child.widget instanceof BlockGapWidget&&gaps.push(child.dom);observer.updateGaps(gaps)}updateChildren(changes,oldLength){let cursor=this.childCursor(oldLength);for(let next,i=changes.length-1;;i--){if(next=0<=i?changes[i]:null,!next)break;let{fromA,toA,fromB,toB}=next,{content,breakAtStart,openStart,openEnd}=ContentBuilder.build(this.view.state.doc,fromB,toB,this.decorations,this.pluginDecorationLength),{i:toI,off:toOff}=cursor.findPos(toA,1),{i:fromI,off:fromOff}=cursor.findPos(fromA,-1);replaceRange(this,fromI,fromOff,toI,toOff,content,breakAtStart,openStart,openEnd)}}// Sync the DOM selection to this.state.selection
updateSelection(mustRead=!1,fromPointer=!1){if(mustRead&&this.view.observer.readSelectionRange(),!(fromPointer||this.mayControlSelection())||browser.ios&&this.view.inputState.rapidCompositionStart)return;let force=this.forceSelection;this.forceSelection=!1;let main=this.view.state.selection.main,anchor=this.domAtPos(main.anchor),head=main.empty?anchor:this.domAtPos(main.head);// FIXME need to handle the case where the selection falls inside a block range
// Always reset on Firefox when next to an uneditable node to
// avoid invisible cursor bugs (#111)
if(browser.gecko&&main.empty&&betweenUneditable(anchor)){let dummy=document.createTextNode("");this.view.observer.ignore(()=>anchor.node.insertBefore(dummy,anchor.node.childNodes[anchor.offset]||null)),anchor=head=new DOMPos(dummy,0),force=!0}let domSel=this.view.observer.selectionRange;// If the selection is already here, or in an equivalent position, don't touch it
!force&&domSel.focusNode&&isEquivalentPosition(anchor.node,anchor.offset,domSel.anchorNode,domSel.anchorOffset)&&isEquivalentPosition(head.node,head.offset,domSel.focusNode,domSel.focusOffset)||(this.view.observer.ignore(()=>{browser.android&&browser.chrome&&this.dom.contains(domSel.focusNode)&&inUneditable(domSel.focusNode,this.dom)&&(this.dom.blur(),this.dom.focus({preventScroll:!0}));let rawSel=getSelection(this.root);if(main.empty){// Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076
if(browser.gecko){let nextTo=nextToUneditable(anchor.node,anchor.offset);if(nextTo&&3/* After */!=nextTo){let text=nearbyTextNode(anchor.node,anchor.offset,1==nextTo/* Before */?1:-1);text&&(anchor=new DOMPos(text,1==nextTo/* Before */?0:text.nodeValue.length))}}rawSel.collapse(anchor.node,anchor.offset),null!=main.bidiLevel&&null!=domSel.cursorBidiLevel&&(domSel.cursorBidiLevel=main.bidiLevel)}else if(rawSel.extend)// Selection.extend can be used to create an 'inverted' selection
// (one where the focus is before the anchor), but not all
// browsers support it yet.
rawSel.collapse(anchor.node,anchor.offset),rawSel.extend(head.node,head.offset);else{// Primitive (IE) way
let range=document.createRange();main.anchor>main.head&&([anchor,head]=[head,anchor]),range.setEnd(head.node,head.offset),range.setStart(anchor.node,anchor.offset),rawSel.removeAllRanges(),rawSel.addRange(range)}}),this.view.observer.setSelectionRange(anchor,head)),this.impreciseAnchor=anchor.precise?null:new DOMPos(domSel.anchorNode,domSel.anchorOffset),this.impreciseHead=head.precise?null:new DOMPos(domSel.focusNode,domSel.focusOffset)}enforceCursorAssoc(){if(this.compositionDeco.size)return;let cursor=this.view.state.selection.main,sel=getSelection(this.root);if(cursor.empty&&cursor.assoc&&sel.modify){let line=LineView.find(this,cursor.head);if(line){let lineStart=line.posAtStart;if(cursor.head!=lineStart&&cursor.head!=lineStart+line.length){let before=this.coordsAt(cursor.head,-1),after=this.coordsAt(cursor.head,1);if(before&&after&&!(before.bottom>after.top)){let dom=this.domAtPos(cursor.head+cursor.assoc);sel.collapse(dom.node,dom.offset),sel.modify("move",0>cursor.assoc?"forward":"backward","lineboundary")}}}}}mayControlSelection(){return this.view.state.facet(editable)?this.root.activeElement==this.dom:hasSelection(this.dom,this.view.observer.selectionRange)}nearest(dom){for(let domView,cur=dom;cur;){if(domView=ContentView.get(cur),domView&&domView.rootView==this)return domView;cur=cur.parentNode}return null}posFromDOM(node,offset){let view=this.nearest(node);if(!view)throw new RangeError("Trying to find position for a DOM position outside of the document");return view.localPosFromDOM(node,offset)+view.posAtStart}domAtPos(pos){let{i,off}=this.childCursor().findPos(pos,-1);for(;i<this.children.length-1;){let child=this.children[i];if(off<child.length||child instanceof LineView)break;i++,off=0}return this.children[i].domAtPos(off)}coordsAt(pos,side){for(let off=this.length,i=this.children.length-1;;i--){let child=this.children[i],start=off-child.breakAfter-child.length;if(pos>start||pos==start&&child.type!=exports.BlockType.WidgetBefore&&child.type!=exports.BlockType.WidgetAfter&&(!i||2==side||this.children[i-1].breakAfter||this.children[i-1].type==exports.BlockType.WidgetBefore&&-2<side))return child.coordsAt(pos-start,side);off=start}}measureVisibleLineHeights(){let result=[],{from,to}=this.view.viewState.viewport,contentWidth=this.view.contentDOM.clientWidth,isWider=contentWidth>Math.max(this.view.scrollDOM.clientWidth,this.minWidth)+1,widest=-1;for(let pos=0,i=0;i<this.children.length;i++){let child=this.children[i],end=pos+child.length;if(end>to)break;if(pos>=from){let childRect=child.dom.getBoundingClientRect();if(result.push(childRect.height),isWider){let last=child.dom.lastChild,rects=last?clientRectsFor(last):[];if(rects.length){let rect=rects[rects.length-1],width=this.view.textDirection==exports.Direction.LTR?rect.right-childRect.left:childRect.right-rect.left;width>widest&&(widest=width,this.minWidth=contentWidth,this.minWidthFrom=pos,this.minWidthTo=end)}}}pos=end+child.breakAfter}return result}measureTextSize(){for(let child of this.children)if(child instanceof LineView){let measure=child.measureTextSize();if(measure)return measure}// If no workable line exists, force a layout of a measurable element
let lineHeight,charWidth,dummy=document.createElement("div");return dummy.className="cm-line",dummy.textContent="abc def ghi jkl mno pqr stu",this.view.observer.ignore(()=>{this.dom.appendChild(dummy);let rect=clientRectsFor(dummy.firstChild)[0];lineHeight=dummy.getBoundingClientRect().height,charWidth=rect?rect.width/27:7,dummy.remove()}),{lineHeight,charWidth}}childCursor(pos=this.length){// Move back to start of last element when possible, so that
// `ChildCursor.findPos` doesn't have to deal with the edge case
// of being after the last element.
let i=this.children.length;return i&&(pos-=this.children[--i].length),new ChildCursor(this.children,pos,i)}computeBlockGapDeco(){let deco=[],vs=this.view.viewState;for(let pos=0,i=0;;i++){let next=i==vs.viewports.length?null:vs.viewports[i],end=next?next.from-1:this.length;if(end>pos){let height=vs.lineBlockAt(end).bottom-vs.lineBlockAt(pos).top;deco.push(Decoration.replace({widget:new BlockGapWidget(height),block:!0,inclusive:!0}).range(pos,end))}if(!next)break;pos=next.to+1}return Decoration.set(deco)}updateDeco(){let pluginDecorations=this.view.pluginField(PluginField.decorations);return this.pluginDecorationLength=pluginDecorations.length,this.decorations=[...pluginDecorations,...this.view.state.facet(decorations),this.compositionDeco,this.computeBlockGapDeco(),this.view.viewState.lineGapDeco]}scrollIntoView(target){let other,{range}=target,rect=this.coordsAt(range.head,range.empty?range.assoc:range.head>range.anchor?-1:1);if(!rect)return;!range.empty&&(other=this.coordsAt(range.anchor,range.anchor>range.head?-1:1))&&(rect={left:Math.min(rect.left,other.left),top:Math.min(rect.top,other.top),right:Math.max(rect.right,other.right),bottom:Math.max(rect.bottom,other.bottom)});let mLeft=0,mRight=0,mTop=0,mBottom=0;for(let margins of this.view.pluginField(PluginField.scrollMargins))if(margins){let{left,right,top,bottom}=margins;null!=left&&(mLeft=Math.max(mLeft,left)),null!=right&&(mRight=Math.max(mRight,right)),null!=top&&(mTop=Math.max(mTop,top)),null!=bottom&&(mBottom=Math.max(mBottom,bottom))}let targetRect={left:rect.left-mLeft,top:rect.top-mTop,right:rect.right+mRight,bottom:rect.bottom+mBottom};scrollRectIntoView(this.view.scrollDOM,targetRect,range.head<range.anchor?-1:1,target.x,target.y,target.xMargin,target.yMargin,this.view.textDirection==exports.Direction.LTR)}}class BlockGapWidget extends WidgetType{constructor(height){super(),this.height=height}toDOM(){let elt=document.createElement("div");return this.updateDOM(elt),elt}eq(other){return other.height==this.height}updateDOM(elt){return elt.style.height=this.height+"px",!0}get estimatedHeight(){return this.height}}class CompositionWidget extends WidgetType{constructor(top,text){super(),this.top=top,this.text=text}eq(other){return this.top==other.top&&this.text==other.text}toDOM(){return this.top}ignoreEvent(){return!1}get customView(){return CompositionView}}class DecorationComparator$1{constructor(){this.changes=[]}compareRange(from,to){addRange(from,to,this.changes)}comparePoint(from,to){addRange(from,to,this.changes)}}class InputState{constructor(view){for(let type in this.lastKeyCode=0,this.lastKeyTime=0,this.pendingIOSKey=void 0,this.lastSelectionOrigin=null,this.lastSelectionTime=0,this.lastEscPress=0,this.lastContextMenu=0,this.scrollHandlers=[],this.registeredEvents=[],this.customHandlers=[],this.composing=-1,this.compositionFirstChange=null,this.compositionEndedAt=0,this.rapidCompositionStart=!1,this.mouseSelection=null,handlers){let handler=handlers[type];view.contentDOM.addEventListener(type,event=>{"keydown"==type&&this.keydown(view,event)||!eventBelongsToEditor(view,event)||this.ignoreDuringComposition(event)||(this.mustFlushObserver(event)&&view.observer.forceFlush(),this.runCustomHandlers(type,view,event)?event.preventDefault():handler(view,event))}),this.registeredEvents.push(type)}this.notifiedFocused=view.hasFocus,this.ensureHandlers(view),browser.safari&&view.contentDOM.addEventListener("input",()=>null)}setSelectionOrigin(origin){this.lastSelectionOrigin=origin,this.lastSelectionTime=Date.now()}ensureHandlers(view){let handlers=this.customHandlers=view.pluginField(domEventHandlers);for(let set of handlers)for(let type in set.handlers)0>this.registeredEvents.indexOf(type)&&"scroll"!=type&&(this.registeredEvents.push(type),view.contentDOM.addEventListener(type,event=>{!eventBelongsToEditor(view,event)||this.runCustomHandlers(type,view,event)&&event.preventDefault()}))}runCustomHandlers(type,view,event){for(let set of this.customHandlers){let handler=set.handlers[type];if(handler)try{if(handler.call(set.plugin,event,view)||event.defaultPrevented)return!0}catch(e){logException(view.state,e)}}return!1}runScrollHandlers(view,event){for(let set of this.customHandlers){let handler=set.handlers.scroll;if(handler)try{handler.call(set.plugin,event,view)}catch(e){logException(view.state,e)}}}keydown(view,event){if(this.lastKeyCode=event.keyCode,this.lastKeyTime=Date.now(),this.screenKeyEvent(view,event))return!0;// Chrome for Android usually doesn't fire proper key events, but
// occasionally does, usually surrounded by a bunch of complicated
// composition changes. When an enter or backspace key event is
// seen, hold off on handling DOM events for a bit, and then
// dispatch it.
if(browser.android&&browser.chrome&&!event.synthetic&&(13==event.keyCode||8==event.keyCode))return view.observer.delayAndroidKey(event.key,event.keyCode),!0;// Prevent the default behavior of Enter on iOS makes the
// virtual keyboard get stuck in the wrong (lowercase)
// state. So we let it go through, and then, in
// applyDOMChange, notify key handlers of it and reset to
// the state they produce.
let pending;return!(!browser.ios||!(pending=PendingKeys.find(key=>key.keyCode==event.keyCode))||event.ctrlKey||event.altKey||event.metaKey||event.synthetic)&&(this.pendingIOSKey=pending,setTimeout(()=>this.flushIOSKey(view),250),!0)}flushIOSKey(view){let key=this.pendingIOSKey;return!!key&&(this.pendingIOSKey=void 0,dispatchKey(view.contentDOM,key.key,key.keyCode))}ignoreDuringComposition(event){return!!/^key/.test(event.type)&&(!!(0<this.composing)||!!(browser.safari&&500>Date.now()-this.compositionEndedAt)&&(this.compositionEndedAt=0,!0));// See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
// On some input method editors (IMEs), the Enter key is used to
// confirm character selection. On Safari, when Enter is pressed,
// compositionend and keydown events are sometimes emitted in the
// wrong order. The key event should still be ignored, even when
// it happens after the compositionend event.
}screenKeyEvent(view,event){let protectedTab=9==event.keyCode&&Date.now()<this.lastEscPress+2e3;return 27==event.keyCode?this.lastEscPress=Date.now():0>modifierCodes.indexOf(event.keyCode)&&(this.lastEscPress=0),protectedTab}mustFlushObserver(event){return"keydown"==event.type&&229!=event.keyCode||"compositionend"==event.type&&!browser.ios}startMouseSelection(mouseSelection){this.mouseSelection&&this.mouseSelection.destroy(),this.mouseSelection=mouseSelection}update(update){this.mouseSelection&&this.mouseSelection.update(update),update.transactions.length&&(this.lastKeyCode=this.lastSelectionTime=0)}destroy(){this.mouseSelection&&this.mouseSelection.destroy()}}const PendingKeys=[{key:"Backspace",keyCode:8,inputType:"deleteContentBackward"},{key:"Enter",keyCode:13,inputType:"insertParagraph"},{key:"Delete",keyCode:46,inputType:"deleteContentForward"}],modifierCodes=[16,17,18,20,91,92,224,225];// Key codes for modifier keys
class MouseSelection{constructor(view,startEvent,style,mustSelect){this.view=view,this.style=style,this.mustSelect=mustSelect,this.lastEvent=startEvent;let doc=view.contentDOM.ownerDocument;doc.addEventListener("mousemove",this.move=this.move.bind(this)),doc.addEventListener("mouseup",this.up=this.up.bind(this)),this.extend=startEvent.shiftKey,this.multiple=view.state.facet(state.EditorState.allowMultipleSelections)&&addsSelectionRange(view,startEvent),this.dragMove=dragMovesSelection(view,startEvent),this.dragging=!!(isInPrimarySelection(view,startEvent)&&1==getClickType(startEvent))&&null,!1===this.dragging&&(startEvent.preventDefault(),this.select(startEvent))}move(event){return 0==event.buttons?this.destroy():void(!1!==this.dragging||this.select(this.lastEvent=event))}up(event){null==this.dragging&&this.select(this.lastEvent),this.dragging||event.preventDefault(),this.destroy()}destroy(){let doc=this.view.contentDOM.ownerDocument;doc.removeEventListener("mousemove",this.move),doc.removeEventListener("mouseup",this.up),this.view.inputState.mouseSelection=null}select(event){let selection=this.style.get(event,this.extend,this.multiple);(this.mustSelect||!selection.eq(this.view.state.selection)||selection.main.assoc!=this.view.state.selection.main.assoc)&&this.view.dispatch({selection,userEvent:"select.pointer",scrollIntoView:!0}),this.mustSelect=!1}update(update){update.docChanged&&this.dragging&&(this.dragging=this.dragging.map(update.changes)),this.style.update(update)&&setTimeout(()=>this.select(this.lastEvent),20)}}const handlers=Object.create(null),brokenClipboardAPI=browser.ie&&15>browser.ie_version||browser.ios&&604>browser.webkit_version;// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
handlers.keydown=view=>{view.inputState.setSelectionOrigin("select")};let lastTouch=0;handlers.touchstart=view=>{lastTouch=Date.now(),view.inputState.setSelectionOrigin("select.pointer")},handlers.touchmove=view=>{view.inputState.setSelectionOrigin("select.pointer")},handlers.mousedown=(view,event)=>{if(view.observer.flush(),lastTouch>Date.now()-2e3&&1==getClickType(event))return;// Ignore touch interaction
let style=null;for(let makeStyle of view.state.facet(mouseSelectionStyle))if(style=makeStyle(view,event),style)break;if(style||0!=event.button||(style=basicMouseSelection(view,event)),style){let mustFocus=view.root.activeElement!=view.contentDOM;mustFocus&&view.observer.ignore(()=>focusPreventScroll(view.contentDOM)),view.inputState.startMouseSelection(new MouseSelection(view,event,style,mustFocus))}};let insideY=(y,rect)=>y>=rect.top&&y<=rect.bottom,inside=(x,y,rect)=>insideY(y,rect)&&x>=rect.left&&x<=rect.right;const BadMouseDetail=browser.ie&&11>=browser.ie_version;let lastMouseDown=null,lastMouseDownCount=0,lastMouseDownTime=0;handlers.dragstart=(view,event)=>{let{selection:{main}}=view.state,{mouseSelection}=view.inputState;mouseSelection&&(mouseSelection.dragging=main),event.dataTransfer&&(event.dataTransfer.setData("Text",view.state.sliceDoc(main.from,main.to)),event.dataTransfer.effectAllowed="copyMove")},handlers.drop=(view,event)=>{if(!event.dataTransfer)return;if(view.state.readOnly)return event.preventDefault();let files=event.dataTransfer.files;if(files&&files.length){event.preventDefault();let text=Array(files.length),read=0,finishFile=()=>{++read==files.length&&dropText(view,event,text.filter(s=>null!=s).join(view.state.lineBreak),!1)};for(let reader,i=0;i<files.length;i++)reader=new FileReader,reader.onerror=finishFile,reader.onload=()=>{/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result)||(text[i]=reader.result),finishFile()},reader.readAsText(files[i])}else dropText(view,event,event.dataTransfer.getData("Text"),!0)},handlers.paste=(view,event)=>{if(view.state.readOnly)return event.preventDefault();view.observer.flush();let data=brokenClipboardAPI?null:event.clipboardData;data?(doPaste(view,data.getData("text/plain")),event.preventDefault()):capturePaste(view)};let lastLinewiseCopy=null;handlers.copy=handlers.cut=(view,event)=>{let{text,ranges,linewise}=copiedRange(view.state);if(text||linewise){lastLinewiseCopy=linewise?text:null;let data=brokenClipboardAPI?null:event.clipboardData;data?(event.preventDefault(),data.clearData(),data.setData("text/plain",text)):captureCopy(view,text),"cut"!=event.type||view.state.readOnly||view.dispatch({changes:ranges,scrollIntoView:!0,userEvent:"delete.cut"})}},handlers.focus=handlers.blur=view=>{setTimeout(()=>{view.hasFocus!=view.inputState.notifiedFocused&&view.update([])},10)},handlers.beforeprint=view=>{view.viewState.printing=!0,view.requestMeasure(),setTimeout(()=>{view.viewState.printing=!1,view.requestMeasure()},2e3)},handlers.compositionstart=handlers.compositionupdate=view=>{null==view.inputState.compositionFirstChange&&(view.inputState.compositionFirstChange=!0),0>view.inputState.composing&&(view.inputState.composing=0,view.docView.compositionDeco.size&&(view.observer.flush(),forceClearComposition(view,!0)))},handlers.compositionend=view=>{view.inputState.composing=-1,view.inputState.compositionEndedAt=Date.now(),view.inputState.compositionFirstChange=null,setTimeout(()=>{0>view.inputState.composing&&forceClearComposition(view,!1)},50)},handlers.contextmenu=view=>{view.inputState.lastContextMenu=Date.now()},handlers.beforeinput=(view,event)=>{var _a;// Because Chrome Android doesn't fire useful key events, use
// beforeinput to detect backspace (and possibly enter and delete,
// but those usually don't even seem to fire beforeinput events at
// the moment) and fake a key event for it.
//
// (preventDefault on beforeinput, though supported in the spec,
// seems to do nothing at all on Chrome).
let pending;if(browser.chrome&&browser.android&&(pending=PendingKeys.find(key=>key.inputType==event.inputType))&&(view.observer.delayAndroidKey(pending.key,pending.keyCode),"Backspace"==pending.key||"Delete"==pending.key)){let startViewHeight=(null===(_a=window.visualViewport)||void 0===_a?void 0:_a.height)||0;setTimeout(()=>{var _a;// Backspacing near uneditable nodes on Chrome Android sometimes
// closes the virtual keyboard. This tries to crudely detect
// that and refocus to get it back.
((null===(_a=window.visualViewport)||void 0===_a?void 0:_a.height)||0)>startViewHeight+10&&view.hasFocus&&(view.contentDOM.blur(),view.focus())},100)}};const wrappingWhiteSpace=["pre-wrap","normal","pre-line","break-spaces"];class HeightOracle{constructor(){this.doc=text.Text.empty,this.lineWrapping=!1,this.direction=exports.Direction.LTR,this.heightSamples={},this.lineHeight=14,this.charWidth=7,this.lineLength=30,this.heightChanged=!1}heightForGap(from,to){let lines=this.doc.lineAt(to).number-this.doc.lineAt(from).number+1;return this.lineWrapping&&(lines+=Math.ceil((to-from-.5*(lines*this.lineLength))/this.lineLength)),this.lineHeight*lines}heightForLine(length){if(!this.lineWrapping)return this.lineHeight;let lines=1+Math.max(0,Math.ceil((length-this.lineLength)/(this.lineLength-5)));return lines*this.lineHeight}setDoc(doc){return this.doc=doc,this}mustRefreshForStyle(whiteSpace,direction){return-1<wrappingWhiteSpace.indexOf(whiteSpace)!=this.lineWrapping||this.direction!=direction}mustRefreshForHeights(lineHeights){let newHeight=!1;for(let h,i=0;i<lineHeights.length;i++)h=lineHeights[i],0>h?i++:!this.heightSamples[Math.floor(10*h)]&&(newHeight=!0,this.heightSamples[Math.floor(10*h)]=!0);return newHeight}refresh(whiteSpace,direction,lineHeight,charWidth,lineLength,knownHeights){let lineWrapping=-1<wrappingWhiteSpace.indexOf(whiteSpace),changed=Math.round(lineHeight)!=Math.round(this.lineHeight)||this.lineWrapping!=lineWrapping||this.direction!=direction;if(this.lineWrapping=lineWrapping,this.direction=direction,this.lineHeight=lineHeight,this.charWidth=charWidth,this.lineLength=lineLength,changed){this.heightSamples={};for(let h,i=0;i<knownHeights.length;i++)h=knownHeights[i],0>h?i++:this.heightSamples[Math.floor(10*h)]=!0}return changed}}// This object is used by `updateHeight` to make DOM measurements
// arrive at the right nides. The `heights` array is a sequence of
// block heights, starting from position `from`.
class MeasuredHeights{constructor(from,heights){this.from=from,this.heights=heights,this.index=0}get more(){return this.index<this.heights.length}}/// Record used to represent information about a block-level element
/// in the editor view.
class BlockInfo{/// @internal
constructor(/// The start of the element in the document.
from,/// The length of the element.
length,/// The top position of the element (relative to the top of the
/// document).
top,/// Its height.
height,/// The type of element this is. When querying lines, this may be
/// an array of all the blocks that make up the line.
type){this.from=from,this.length=length,this.top=top,this.height=height,this.type=type}/// The end of the element as a document position.
get to(){return this.from+this.length}/// The bottom position of the element.
get bottom(){return this.top+this.height}/// @internal
join(other){let detail=(Array.isArray(this.type)?this.type:[this]).concat(Array.isArray(other.type)?other.type:[other]);return new BlockInfo(this.from,this.length+other.length,this.top,this.height+other.height,detail)}/// FIXME remove on next breaking release @internal
moveY(offset){return offset?new BlockInfo(this.from,this.length,this.top+offset,this.height,Array.isArray(this.type)?this.type.map(b=>b.moveY(offset)):this.type):this}}var QueryType;(function(QueryType){QueryType[QueryType.ByPos=0]="ByPos",QueryType[QueryType.ByHeight=1]="ByHeight",QueryType[QueryType.ByPosNoHeight=2]="ByPosNoHeight"})(QueryType||(QueryType={}));const Epsilon=1e-3;class HeightMap{constructor(length,// The number of characters covered
height,// Height of this part of the document
flags=2/* Outdated */){this.length=length,this.height=height,this.flags=flags}get outdated(){return 0<(2&this.flags/* Outdated */)}set outdated(value){this.flags=(value?2/* Outdated */:0)|-3&this.flags/* Outdated */}setHeight(oracle,height){this.height!=height&&(Math.abs(this.height-height)>Epsilon&&(oracle.heightChanged=!0),this.height=height)}// Base case is to replace a leaf node, which simply builds a tree
// from the new nodes and returns that (HeightMapBranch and
// HeightMapGap override this to actually use from/to)
replace(_from,_to,nodes){return HeightMap.of(nodes)}// Again, these are base cases, and are overridden for branch and gap nodes.
decomposeLeft(_to,result){result.push(this)}decomposeRight(_from,result){result.push(this)}applyChanges(decorations,oldDoc,oracle,changes){let me=this;for(let i=changes.length-1;0<=i;i--){let{fromA,toA,fromB,toB}=changes[i],start=me.lineAt(fromA,QueryType.ByPosNoHeight,oldDoc,0,0),end=start.to>=toA?start:me.lineAt(toA,QueryType.ByPosNoHeight,oldDoc,0,0);for(toB+=end.to-toA,toA=end.to;0<i&&start.from<=changes[i-1].toA;)fromA=changes[i-1].fromA,fromB=changes[i-1].fromB,i--,fromA<start.from&&(start=me.lineAt(fromA,QueryType.ByPosNoHeight,oldDoc,0,0));fromB+=start.from-fromA,fromA=start.from;let nodes=NodeBuilder.build(oracle,decorations,fromB,toB);me=me.replace(fromA,toA,nodes)}return me.updateHeight(oracle,0)}static empty(){return new HeightMapText(0,0)}// nodes uses null values to indicate the position of line breaks.
// There are never line breaks at the start or end of the array, or
// two line breaks next to each other, and the array isn't allowed
// to be empty (same restrictions as return value from the builder).
static of(nodes){if(1==nodes.length)return nodes[0];let i=0,j=nodes.length,before=0,after=0;for(;;)if(i==j){if(before>2*after){let split=nodes[i-1];split.break?nodes.splice(--i,1,split.left,null,split.right):nodes.splice(--i,1,split.left,split.right),j+=1+split.break,before-=split.size}else if(after>2*before){let split=nodes[j];split.break?nodes.splice(j,1,split.left,null,split.right):nodes.splice(j,1,split.left,split.right),j+=2+split.break,after-=split.size}else break;}else if(before<after){let next=nodes[i++];next&&(before+=next.size)}else{let next=nodes[--j];next&&(after+=next.size)}let brk=0;return null==nodes[i-1]?(brk=1,i--):null==nodes[i]&&(brk=1,j++),new HeightMapBranch(HeightMap.of(nodes.slice(0,i)),brk,HeightMap.of(nodes.slice(j)))}}HeightMap.prototype.size=1;class HeightMapBlock extends HeightMap{constructor(length,height,type){super(length,height),this.type=type}blockAt(_height,_doc,top,offset){return new BlockInfo(offset,this.length,top,this.height,this.type)}lineAt(_value,_type,doc,top,offset){return this.blockAt(0,doc,top,offset)}forEachLine(_from,_to,doc,top,offset,f){f(this.blockAt(0,doc,top,offset))}updateHeight(oracle,offset=0,_force=!1,measured){return measured&&measured.from<=offset&&measured.more&&this.setHeight(oracle,measured.heights[measured.index++]),this.outdated=!1,this}toString(){return`block(${this.length})`}}class HeightMapText extends HeightMapBlock{constructor(length,height){super(length,height,exports.BlockType.Text),this.collapsed=0,this.widgetHeight=0}replace(_from,_to,nodes){let node=nodes[0];return 1==nodes.length&&(node instanceof HeightMapText||node instanceof HeightMapGap&&4&node.flags/* SingleLine */)&&10>Math.abs(this.length-node.length)?(node instanceof HeightMapGap?node=new HeightMapText(node.length,this.height):node.height=this.height,this.outdated||(node.outdated=!1),node):HeightMap.of(nodes)}updateHeight(oracle,offset=0,force=!1,measured){return measured&&measured.from<=offset&&measured.more?this.setHeight(oracle,measured.heights[measured.index++]):(force||this.outdated)&&this.setHeight(oracle,Math.max(this.widgetHeight,oracle.heightForLine(this.length-this.collapsed))),this.outdated=!1,this}toString(){return`line(${this.length}${this.collapsed?-this.collapsed:""}${this.widgetHeight?":"+this.widgetHeight:""})`}}class HeightMapGap extends HeightMap{constructor(length){super(length,0)}lines(doc,offset){let firstLine=doc.lineAt(offset).number,lastLine=doc.lineAt(offset+this.length).number;return{firstLine,lastLine,lineHeight:this.height/(lastLine-firstLine+1)}}blockAt(height,doc,top,offset){let{firstLine,lastLine,lineHeight}=this.lines(doc,offset),line=Math.max(0,Math.min(lastLine-firstLine,Math.floor((height-top)/lineHeight))),{from,length}=doc.line(firstLine+line);return new BlockInfo(from,length,top+lineHeight*line,lineHeight,exports.BlockType.Text)}lineAt(value,type,doc,top,offset){if(type==QueryType.ByHeight)return this.blockAt(value,doc,top,offset);if(type==QueryType.ByPosNoHeight){let{from,to}=doc.lineAt(value);return new BlockInfo(from,to-from,0,0,exports.BlockType.Text)}let{firstLine,lineHeight}=this.lines(doc,offset),{from,length,number}=doc.lineAt(value);return new BlockInfo(from,length,top+lineHeight*(number-firstLine),lineHeight,exports.BlockType.Text)}forEachLine(from,to,doc,top,offset,f){let{firstLine,lineHeight}=this.lines(doc,offset);for(let line,pos=Math.max(from,offset),end=Math.min(offset+this.length,to);pos<=end;)line=doc.lineAt(pos),pos==from&&(top+=lineHeight*(line.number-firstLine)),f(new BlockInfo(line.from,line.length,top,lineHeight,exports.BlockType.Text)),top+=lineHeight,pos=line.to+1}replace(from,to,nodes){let after=this.length-to;if(0<after){let last=nodes[nodes.length-1];last instanceof HeightMapGap?nodes[nodes.length-1]=new HeightMapGap(last.length+after):nodes.push(null,new HeightMapGap(after-1))}if(0<from){let first=nodes[0];first instanceof HeightMapGap?nodes[0]=new HeightMapGap(from+first.length):nodes.unshift(new HeightMapGap(from-1),null)}return HeightMap.of(nodes)}decomposeLeft(to,result){result.push(new HeightMapGap(to-1),null)}decomposeRight(from,result){result.push(null,new HeightMapGap(this.length-from-1))}updateHeight(oracle,offset=0,force=!1,measured){let end=offset+this.length;if(measured&&measured.from<=offset+this.length&&measured.more){// Fill in part of this gap with measured lines. We know there
// can't be widgets or collapsed ranges in those lines, because
// they would already have been added to the heightmap (gaps
// only contain plain text).
let nodes=[],pos=Math.max(offset,measured.from),singleHeight=-1,wasChanged=oracle.heightChanged;for(measured.from>offset&&nodes.push(new HeightMapGap(measured.from-offset-1).updateHeight(oracle,offset));pos<=end&&measured.more;){let len=oracle.doc.lineAt(pos).length;nodes.length&&nodes.push(null);let height=measured.heights[measured.index++];-1==singleHeight?singleHeight=height:Math.abs(height-singleHeight)>=Epsilon&&(singleHeight=-2);let line=new HeightMapText(len,height);line.outdated=!1,nodes.push(line),pos+=len+1}pos<=end&&nodes.push(null,new HeightMapGap(end-pos).updateHeight(oracle,pos));let result=HeightMap.of(nodes);return oracle.heightChanged=wasChanged||0>singleHeight||Math.abs(result.height-this.height)>=Epsilon||Math.abs(singleHeight-this.lines(oracle.doc,offset).lineHeight)>=Epsilon,result}return(force||this.outdated)&&(this.setHeight(oracle,oracle.heightForGap(offset,offset+this.length)),this.outdated=!1),this}toString(){return`gap(${this.length})`}}class HeightMapBranch extends HeightMap{constructor(left,brk,right){super(left.length+brk+right.length,left.height+right.height,brk|(left.outdated||right.outdated?2/* Outdated */:0)),this.left=left,this.right=right,this.size=left.size+right.size}get break(){return 1&this.flags/* Break */}blockAt(height,doc,top,offset){let mid=top+this.left.height;return height<mid?this.left.blockAt(height,doc,top,offset):this.right.blockAt(height,doc,mid,offset+this.left.length+this.break)}lineAt(value,type,doc,top,offset){let rightTop=top+this.left.height,rightOffset=offset+this.left.length+this.break,left=type==QueryType.ByHeight?value<rightTop:value<rightOffset,base=left?this.left.lineAt(value,type,doc,top,offset):this.right.lineAt(value,type,doc,rightTop,rightOffset);if(this.break||(left?base.to<rightOffset:base.from>rightOffset))return base;let subQuery=type==QueryType.ByPosNoHeight?QueryType.ByPosNoHeight:QueryType.ByPos;return left?base.join(this.right.lineAt(rightOffset,subQuery,doc,rightTop,rightOffset)):this.left.lineAt(rightOffset,subQuery,doc,top,offset).join(base)}forEachLine(from,to,doc,top,offset,f){let rightTop=top+this.left.height,rightOffset=offset+this.left.length+this.break;if(this.break)from<rightOffset&&this.left.forEachLine(from,to,doc,top,offset,f),to>=rightOffset&&this.right.forEachLine(from,to,doc,rightTop,rightOffset,f);else{let mid=this.lineAt(rightOffset,QueryType.ByPos,doc,top,offset);from<mid.from&&this.left.forEachLine(from,mid.from-1,doc,top,offset,f),mid.to>=from&&mid.from<=to&&f(mid),to>mid.to&&this.right.forEachLine(mid.to+1,to,doc,rightTop,rightOffset,f)}}replace(from,to,nodes){let rightStart=this.left.length+this.break;if(to<rightStart)return this.balanced(this.left.replace(from,to,nodes),this.right);if(from>this.left.length)return this.balanced(this.left,this.right.replace(from-rightStart,to-rightStart,nodes));let result=[];0<from&&this.decomposeLeft(from,result);let left=result.length;for(let node of nodes)result.push(node);if(0<from&&mergeGaps(result,left-1),to<this.length){let right=result.length;this.decomposeRight(to,result),mergeGaps(result,right)}return HeightMap.of(result)}decomposeLeft(to,result){let left=this.left.length;return to<=left?this.left.decomposeLeft(to,result):void(result.push(this.left),this.break&&(left++,to>=left&&result.push(null)),to>left&&this.right.decomposeLeft(to-left,result))}decomposeRight(from,result){let left=this.left.length,right=left+this.break;return from>=right?this.right.decomposeRight(from-right,result):void(from<left&&this.left.decomposeRight(from,result),this.break&&from<right&&result.push(null),result.push(this.right))}balanced(left,right){return left.size>2*right.size||right.size>2*left.size?HeightMap.of(this.break?[left,null,right]:[left,right]):(this.left=left,this.right=right,this.height=left.height+right.height,this.outdated=left.outdated||right.outdated,this.size=left.size+right.size,this.length=left.length+this.break+right.length,this)}updateHeight(oracle,offset=0,force=!1,measured){let{left,right}=this,rightStart=offset+left.length+this.break,rebalance=null;return(measured&&measured.from<=offset+left.length&&measured.more?rebalance=left=left.updateHeight(oracle,offset,force,measured):left.updateHeight(oracle,offset,force),measured&&measured.from<=rightStart+right.length&&measured.more?rebalance=right=right.updateHeight(oracle,rightStart,force,measured):right.updateHeight(oracle,rightStart,force),rebalance)?this.balanced(left,right):(this.height=this.left.height+this.right.height,this.outdated=!1,this)}toString(){return this.left+(this.break?" ":"-")+this.right}}class NodeBuilder{constructor(pos,oracle){this.pos=pos,this.oracle=oracle,this.nodes=[],this.lineStart=-1,this.lineEnd=-1,this.covering=null,this.writtenTo=pos}get isCovered(){return this.covering&&this.nodes[this.nodes.length-1]==this.covering}span(_from,to){if(-1<this.lineStart){let end=Math.min(to,this.lineEnd),last=this.nodes[this.nodes.length-1];last instanceof HeightMapText?last.length+=end-this.pos:(end>this.pos||!this.isCovered)&&this.nodes.push(new HeightMapText(end-this.pos,-1)),this.writtenTo=end,to>end&&(this.nodes.push(null),this.writtenTo++,this.lineStart=-1)}this.pos=to}point(from,to,deco){if(from<to||deco.heightRelevant){let height=deco.widget?deco.widget.estimatedHeight:0;0>height&&(height=this.oracle.lineHeight);let len=to-from;deco.block?this.addBlock(new HeightMapBlock(len,height,deco.type)):(len||height>=5)&&this.addLineDeco(height,len)}else to>from&&this.span(from,to);-1<this.lineEnd&&this.lineEnd<this.pos&&(this.lineEnd=this.oracle.doc.lineAt(this.pos).to)}enterLine(){if(!(-1<this.lineStart)){let{from,to}=this.oracle.doc.lineAt(this.pos);this.lineStart=from,this.lineEnd=to,this.writtenTo<from&&((this.writtenTo<from-1||null==this.nodes[this.nodes.length-1])&&this.nodes.push(this.blankContent(this.writtenTo,from-1)),this.nodes.push(null)),this.pos>from&&this.nodes.push(new HeightMapText(this.pos-from,-1)),this.writtenTo=this.pos}}blankContent(from,to){let gap=new HeightMapGap(to-from);return this.oracle.doc.lineAt(from).to==to&&(gap.flags|=4/* SingleLine */),gap}ensureLine(){this.enterLine();let last=this.nodes.length?this.nodes[this.nodes.length-1]:null;if(last instanceof HeightMapText)return last;let line=new HeightMapText(0,-1);return this.nodes.push(line),line}addBlock(block){this.enterLine(),block.type!=exports.BlockType.WidgetAfter||this.isCovered||this.ensureLine(),this.nodes.push(block),this.writtenTo=this.pos+=block.length,block.type!=exports.BlockType.WidgetBefore&&(this.covering=block)}addLineDeco(height,length){let line=this.ensureLine();line.length+=length,line.collapsed+=length,line.widgetHeight=Math.max(line.widgetHeight,height),this.writtenTo=this.pos+=length}finish(from){let last=0==this.nodes.length?null:this.nodes[this.nodes.length-1];!(-1<this.lineStart)||last instanceof HeightMapText||this.isCovered?(this.writtenTo<this.pos||null==last)&&this.nodes.push(this.blankContent(this.writtenTo,this.pos)):this.nodes.push(new HeightMapText(0,-1));let pos=from;for(let node of this.nodes)node instanceof HeightMapText&&node.updateHeight(this.oracle,pos),pos+=node?node.length:1;return this.nodes}// Always called with a region that on both sides either stretches
// to a line break or the end of the document.
// The returned array uses null to indicate line breaks, but never
// starts or ends in a line break, or has multiple line breaks next
// to each other.
static build(oracle,decorations,from,to){let builder=new NodeBuilder(from,oracle);return rangeset.RangeSet.spans(decorations,from,to,builder,0),builder.finish(from)}}class DecorationComparator{constructor(){this.changes=[]}compareRange(){}comparePoint(from,to,a,b){(from<to||a&&a.heightRelevant||b&&b.heightRelevant)&&addRange(from,to,this.changes,5)}}class LineGap{constructor(from,to,size){this.from=from,this.to=to,this.size=size}static same(a,b){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++){let gA=a[i],gB=b[i];if(gA.from!=gB.from||gA.to!=gB.to||gA.size!=gB.size)return!1}return!0}draw(wrapping){return Decoration.replace({widget:new LineGapWidget(this.size,wrapping)}).range(this.from,this.to)}}class LineGapWidget extends WidgetType{constructor(size,vertical){super(),this.size=size,this.vertical=vertical}eq(other){return other.size==this.size&&other.vertical==this.vertical}toDOM(){let elt=document.createElement("div");return this.vertical?elt.style.height=this.size+"px":(elt.style.width=this.size+"px",elt.style.height="2px",elt.style.display="inline-block"),elt}get estimatedHeight(){return this.vertical?this.size:-1}}class ViewState{constructor(state){this.state=state,this.pixelViewport={left:0,right:window.innerWidth,top:0,bottom:0},this.inView=!0,this.paddingTop=0,this.paddingBottom=0,this.contentDOMWidth=0,this.contentDOMHeight=0,this.editorHeight=0,this.editorWidth=0,this.heightOracle=new HeightOracle,this.scaler=IdScaler,this.scrollTarget=null,this.printing=!1,this.mustMeasureContent=!0,this.visibleRanges=[],this.mustEnforceCursorAssoc=!1,this.heightMap=HeightMap.empty().applyChanges(state.facet(decorations),text.Text.empty,this.heightOracle.setDoc(state.doc),[new ChangedRange(0,0,0,state.doc.length)]),this.viewport=this.getViewport(0,null),this.updateViewportLines(),this.updateForViewport(),this.lineGaps=this.ensureLineGaps([]),this.lineGapDeco=Decoration.set(this.lineGaps.map(gap=>gap.draw(!1))),this.computeVisibleRanges()}updateForViewport(){let viewports=[this.viewport],{main}=this.state.selection;for(let pos,i=0;1>=i;i++)if(pos=i?main.head:main.anchor,!viewports.some(({from,to})=>pos>=from&&pos<=to)){let{from,to}=this.lineBlockAt(pos);viewports.push(new Viewport(from,to))}this.viewports=viewports.sort((a,b)=>a.from-b.from),this.scaler=7e6>=this.heightMap.height/* MaxDOMHeight */?IdScaler:new BigScaler(this.heightOracle.doc,this.heightMap,this.viewports)}updateViewportLines(){this.viewportLines=[],this.heightMap.forEachLine(this.viewport.from,this.viewport.to,this.state.doc,0,0,block=>{this.viewportLines.push(1==this.scaler.scale?block:scaleBlock(block,this.scaler))})}update(update,scrollTarget=null){let prev=this.state;this.state=update.state;let newDeco=this.state.facet(decorations),contentChanges=update.changedRanges,heightChanges=ChangedRange.extendWithRanges(contentChanges,heightRelevantDecoChanges(update.startState.facet(decorations),newDeco,update?update.changes:state.ChangeSet.empty(this.state.doc.length))),prevHeight=this.heightMap.height;this.heightMap=this.heightMap.applyChanges(newDeco,prev.doc,this.heightOracle.setDoc(this.state.doc),heightChanges),this.heightMap.height!=prevHeight&&(update.flags|=2/* Height */);let viewport=heightChanges.length?this.mapViewport(this.viewport,update.changes):this.viewport;(scrollTarget&&(scrollTarget.range.head<viewport.from||scrollTarget.range.head>viewport.to)||!this.viewportIsAppropriate(viewport))&&(viewport=this.getViewport(0,scrollTarget));let updateLines=!update.changes.empty||2&update.flags/* Height */||viewport.from!=this.viewport.from||viewport.to!=this.viewport.to;this.viewport=viewport,this.updateForViewport(),updateLines&&this.updateViewportLines(),(this.lineGaps.length||4e3<this.viewport.to-this.viewport.from/* DoubleMargin */)&&this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps,update.changes))),update.flags|=this.computeVisibleRanges(),scrollTarget&&(this.scrollTarget=scrollTarget),!this.mustEnforceCursorAssoc&&update.selectionSet&&update.view.lineWrapping&&update.state.selection.main.empty&&update.state.selection.main.assoc&&(this.mustEnforceCursorAssoc=!0)}measure(view){let dom=view.contentDOM,style=window.getComputedStyle(dom),oracle=this.heightOracle,whiteSpace=style.whiteSpace,direction="rtl"==style.direction?exports.Direction.RTL:exports.Direction.LTR,refresh=this.heightOracle.mustRefreshForStyle(whiteSpace,direction),measureContent=refresh||this.mustMeasureContent||this.contentDOMHeight!=dom.clientHeight,result=0,bias=0;if(measureContent){this.mustMeasureContent=!1,this.contentDOMHeight=dom.clientHeight;// Vertical padding
let paddingTop=parseInt(style.paddingTop)||0,paddingBottom=parseInt(style.paddingBottom)||0;(this.paddingTop!=paddingTop||this.paddingBottom!=paddingBottom)&&(result|=8/* Geometry */,this.paddingTop=paddingTop,this.paddingBottom=paddingBottom)}// Pixel viewport
let pixelViewport=this.printing?{top:-1e8,bottom:1e8,left:-1e8,right:1e8}:visiblePixelRange(dom,this.paddingTop),dTop=pixelViewport.top-this.pixelViewport.top,dBottom=pixelViewport.bottom-this.pixelViewport.bottom;this.pixelViewport=pixelViewport;let inView=this.pixelViewport.bottom>this.pixelViewport.top&&this.pixelViewport.right>this.pixelViewport.left;if(inView!=this.inView&&(this.inView=inView,inView&&(measureContent=!0)),!this.inView)return 0;let contentWidth=dom.clientWidth;if((this.contentDOMWidth!=contentWidth||this.editorHeight!=view.scrollDOM.clientHeight||this.editorWidth!=view.scrollDOM.clientWidth)&&(this.contentDOMWidth=contentWidth,this.editorHeight=view.scrollDOM.clientHeight,this.editorWidth=view.scrollDOM.clientWidth,result|=8/* Geometry */),measureContent){let lineHeights=view.docView.measureVisibleLineHeights();if(oracle.mustRefreshForHeights(lineHeights)&&(refresh=!0),refresh||oracle.lineWrapping&&Math.abs(contentWidth-this.contentDOMWidth)>oracle.charWidth){let{lineHeight,charWidth}=view.docView.measureTextSize();refresh=oracle.refresh(whiteSpace,direction,lineHeight,charWidth,contentWidth/charWidth,lineHeights),refresh&&(view.docView.minWidth=0,result|=8/* Geometry */)}0<dTop&&0<dBottom?bias=Math.max(dTop,dBottom):0>dTop&&0>dBottom&&(bias=Math.min(dTop,dBottom)),oracle.heightChanged=!1,this.heightMap=this.heightMap.updateHeight(oracle,0,refresh,new MeasuredHeights(this.viewport.from,lineHeights)),oracle.heightChanged&&(result|=2/* Height */)}let viewportChange=!this.viewportIsAppropriate(this.viewport,bias)||this.scrollTarget&&(this.scrollTarget.range.head<this.viewport.from||this.scrollTarget.range.head>this.viewport.to);return viewportChange&&(this.viewport=this.getViewport(bias,this.scrollTarget)),this.updateForViewport(),(2&result/* Height */||viewportChange)&&this.updateViewportLines(),(this.lineGaps.length||4e3<this.viewport.to-this.viewport.from/* DoubleMargin */)&&this.updateLineGaps(this.ensureLineGaps(refresh?[]:this.lineGaps)),result|=this.computeVisibleRanges(),this.mustEnforceCursorAssoc&&(this.mustEnforceCursorAssoc=!1,view.docView.enforceCursorAssoc()),result}get visibleTop(){return this.scaler.fromDOM(this.pixelViewport.top)}get visibleBottom(){return this.scaler.fromDOM(this.pixelViewport.bottom)}getViewport(bias,scrollTarget){// This will divide VP.Margin between the top and the
// bottom, depending on the bias (the change in viewport position
// since the last update). It'll hold a number between 0 and 1
let marginTop=.5-Math.max(-.5,Math.min(.5,bias/1e3/* Margin *//2)),map=this.heightMap,doc=this.state.doc,{visibleTop,visibleBottom}=this,viewport=new Viewport(map.lineAt(visibleTop-1e3*marginTop/* Margin */,QueryType.ByHeight,doc,0,0).from,map.lineAt(visibleBottom+1e3*(1-marginTop)/* Margin */,QueryType.ByHeight,doc,0,0).to);// If scrollTarget is given, make sure the viewport includes that position
if(scrollTarget){let{head}=scrollTarget.range,viewHeight=this.editorHeight;if(head<viewport.from||head>viewport.to){let topPos,block=map.lineAt(head,QueryType.ByPos,doc,0,0);topPos="center"==scrollTarget.y?(block.top+block.bottom)/2-viewHeight/2:"start"==scrollTarget.y||"nearest"==scrollTarget.y&&head<viewport.from?block.top:block.bottom-viewHeight,viewport=new Viewport(map.lineAt(topPos-500,QueryType.ByHeight,doc,0,0).from,map.lineAt(topPos+viewHeight+500,QueryType.ByHeight,doc,0,0).to)}}return viewport}mapViewport(viewport,changes){let from=changes.mapPos(viewport.from,-1),to=changes.mapPos(viewport.to,1);return new Viewport(this.heightMap.lineAt(from,QueryType.ByPos,this.state.doc,0,0).from,this.heightMap.lineAt(to,QueryType.ByPos,this.state.doc,0,0).to)}// Checks if a given viewport covers the visible part of the
// document and not too much beyond that.
viewportIsAppropriate({from,to},bias=0){if(!this.inView)return!0;let{top}=this.heightMap.lineAt(from,QueryType.ByPos,this.state.doc,0,0),{bottom}=this.heightMap.lineAt(to,QueryType.ByPos,this.state.doc,0,0),{visibleTop,visibleBottom}=this;return(0==from||top<=visibleTop-Math.max(10/* MinCoverMargin */,Math.min(-bias,250/* MaxCoverMargin */)))&&(to==this.state.doc.length||bottom>=visibleBottom+Math.max(10/* MinCoverMargin */,Math.min(bias,250/* MaxCoverMargin */)))&&top>visibleTop-2000/* Margin */&&bottom<visibleBottom+2000/* Margin */}mapLineGaps(gaps,changes){if(!gaps.length||changes.empty)return gaps;let mapped=[];for(let gap of gaps)changes.touchesRange(gap.from,gap.to)||mapped.push(new LineGap(changes.mapPos(gap.from),changes.mapPos(gap.to),gap.size));return mapped}// Computes positions in the viewport where the start or end of a
// line should be hidden, trying to reuse existing line gaps when
// appropriate to avoid unneccesary redraws.
// Uses crude character-counting for the positioning and sizing,
// since actual DOM coordinates aren't always available and
// predictable. Relies on generous margins (see LG.Margin) to hide
// the artifacts this might produce from the user.
ensureLineGaps(current){let gaps=[];// This won't work at all in predominantly right-to-left text.
if(this.heightOracle.direction!=exports.Direction.LTR)return gaps;for(let line of this.viewportLines){if(4e3>line.length/* DoubleMargin */)continue;let structure=lineStructure(line.from,line.to,this.state);if(4e3>structure.total/* DoubleMargin */)continue;let viewFrom,viewTo;if(this.heightOracle.lineWrapping){let marginHeight=2e3/* Margin *//this.heightOracle.lineLength*this.heightOracle.lineHeight;viewFrom=findPosition(structure,(this.visibleTop-line.top-marginHeight)/line.height),viewTo=findPosition(structure,(this.visibleBottom-line.top+marginHeight)/line.height)}else{let totalWidth=structure.total*this.heightOracle.charWidth,marginWidth=2e3/* Margin */*this.heightOracle.charWidth;viewFrom=findPosition(structure,(this.pixelViewport.left-marginWidth)/totalWidth),viewTo=findPosition(structure,(this.pixelViewport.right+marginWidth)/totalWidth)}let outside=[];viewFrom>line.from&&outside.push({from:line.from,to:viewFrom}),viewTo<line.to&&outside.push({from:viewTo,to:line.to});let sel=this.state.selection.main;// Make sure the gaps don't cover a selection end
sel.from>=line.from&&sel.from<=line.to&&cutRange(outside,sel.from-10/* SelectionMargin */,sel.from+10/* SelectionMargin */),!sel.empty&&sel.to>=line.from&&sel.to<=line.to&&cutRange(outside,sel.to-10/* SelectionMargin */,sel.to+10/* SelectionMargin */);for(let{from,to}of outside)1e3<to-from/* HalfMargin */&&gaps.push(find(current,gap=>gap.from>=line.from&&gap.to<=line.to&&1e3>Math.abs(gap.from-from)/* HalfMargin */&&1e3>Math.abs(gap.to-to)/* HalfMargin */)||new LineGap(from,to,this.gapSize(line,from,to,structure)))}return gaps}gapSize(line,from,to,structure){let fraction=findFraction(structure,to)-findFraction(structure,from);return this.heightOracle.lineWrapping?line.height*fraction:structure.total*this.heightOracle.charWidth*fraction}updateLineGaps(gaps){LineGap.same(gaps,this.lineGaps)||(this.lineGaps=gaps,this.lineGapDeco=Decoration.set(gaps.map(gap=>gap.draw(this.heightOracle.lineWrapping))))}computeVisibleRanges(){let deco=this.state.facet(decorations);this.lineGaps.length&&(deco=deco.concat(this.lineGapDeco));let ranges=[];rangeset.RangeSet.spans(deco,this.viewport.from,this.viewport.to,{span(from,to){ranges.push({from,to})},point(){}},20);let changed=ranges.length!=this.visibleRanges.length||this.visibleRanges.some((r,i)=>r.from!=ranges[i].from||r.to!=ranges[i].to);return this.visibleRanges=ranges,changed?4/* Viewport */:0}lineBlockAt(pos){return pos>=this.viewport.from&&pos<=this.viewport.to&&this.viewportLines.find(b=>b.from<=pos&&b.to>=pos)||scaleBlock(this.heightMap.lineAt(pos,QueryType.ByPos,this.state.doc,0,0),this.scaler)}lineBlockAtHeight(height){return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height),QueryType.ByHeight,this.state.doc,0,0),this.scaler)}elementAtHeight(height){return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height),this.state.doc,0,0),this.scaler)}get docHeight(){return this.scaler.toDOM(this.heightMap.height)}get contentHeight(){return this.docHeight+this.paddingTop+this.paddingBottom}}class Viewport{constructor(from,to){this.from=from,this.to=to}}const IdScaler={toDOM(n){return n},fromDOM(n){return n},scale:1};// When the height is too big (> VP.MaxDOMHeight), scale down the
// regions outside the viewports so that the total height is
// VP.MaxDOMHeight.
class BigScaler{constructor(doc,heightMap,viewports){let vpHeight=0,base=0,domBase=0;this.viewports=viewports.map(({from,to})=>{let top=heightMap.lineAt(from,QueryType.ByPos,doc,0,0).top,bottom=heightMap.lineAt(to,QueryType.ByPos,doc,0,0).bottom;return vpHeight+=bottom-top,{from,to,top,bottom,domTop:0,domBottom:0}}),this.scale=(7e6/* MaxDOMHeight */-vpHeight)/(heightMap.height-vpHeight);for(let obj of this.viewports)obj.domTop=domBase+(obj.top-base)*this.scale,domBase=obj.domBottom=obj.domTop+(obj.bottom-obj.top),base=obj.bottom}toDOM(n){for(let vp,i=0,base=0,domBase=0;;i++){if(vp=i<this.viewports.length?this.viewports[i]:null,!vp||n<vp.top)return domBase+(n-base)*this.scale;if(n<=vp.bottom)return vp.domTop+(n-vp.top);base=vp.bottom,domBase=vp.domBottom}}fromDOM(n){for(let vp,i=0,base=0,domBase=0;;i++){if(vp=i<this.viewports.length?this.viewports[i]:null,!vp||n<vp.domTop)return base+(n-domBase)/this.scale;if(n<=vp.domBottom)return vp.top+(n-vp.domTop);base=vp.bottom,domBase=vp.domBottom}}}const theme=state.Facet.define({combine:strs=>strs.join(" ")}),darkTheme=state.Facet.define({combine:values=>-1<values.indexOf(!0)}),baseThemeID=styleMod.StyleModule.newName(),baseLightID=styleMod.StyleModule.newName(),baseDarkID=styleMod.StyleModule.newName(),lightDarkIDs={"&light":"."+baseLightID,"&dark":"."+baseDarkID},baseTheme=buildTheme("."+baseThemeID,{"&.cm-editor":{position:"relative !important",boxSizing:"border-box","&.cm-focused":{// Provide a simple default outline to make sure a focused
// editor is visually distinct. Can't leave the default behavior
// because that will apply to the content element, which is
// inside the scrollable container and doesn't include the
// gutters. We also can't use an 'auto' outline, since those
// are, for some reason, drawn behind the element content, which
// will cause things like the active line background to cover
// the outline (#297).
outline:"1px dotted #212121"},display:"flex !important",flexDirection:"column"},".cm-scroller":{display:"flex !important",alignItems:"flex-start !important",fontFamily:"monospace",lineHeight:1.4,height:"100%",overflowX:"auto",position:"relative",zIndex:0},".cm-content":{margin:0,flexGrow:2,minHeight:"100%",display:"block",whiteSpace:"pre",wordWrap:"normal",boxSizing:"border-box",padding:"4px 0",outline:"none","&[contenteditable=true]":{WebkitUserModify:"read-write-plaintext-only"}},".cm-lineWrapping":{whiteSpace_fallback:"pre-wrap",whiteSpace:"break-spaces",wordBreak:"break-word",overflowWrap:"anywhere"},"&light .cm-content":{caretColor:"black"},"&dark .cm-content":{caretColor:"white"},".cm-line":{display:"block",padding:"0 2px 0 4px"},".cm-selectionLayer":{zIndex:-1,contain:"size style"},".cm-selectionBackground":{position:"absolute"},"&light .cm-selectionBackground":{background:"#d9d9d9"},"&dark .cm-selectionBackground":{background:"#222"},"&light.cm-focused .cm-selectionBackground":{background:"#d7d4f0"},"&dark.cm-focused .cm-selectionBackground":{background:"#233"},".cm-cursorLayer":{zIndex:100,contain:"size style",pointerEvents:"none"},"&.cm-focused .cm-cursorLayer":{animation:"steps(1) cm-blink 1.2s infinite"},// Two animations defined so that we can switch between them to
// restart the animation without forcing another style
// recomputation.
"@keyframes cm-blink":{"0%":{},"50%":{visibility:"hidden"},"100%":{}},"@keyframes cm-blink2":{"0%":{},"50%":{visibility:"hidden"},"100%":{}},".cm-cursor, .cm-dropCursor":{position:"absolute",borderLeft:"1.2px solid black",marginLeft:"-0.6px",pointerEvents:"none"},".cm-cursor":{display:"none"},"&dark .cm-cursor":{borderLeftColor:"#444"},"&.cm-focused .cm-cursor":{display:"block"},"&light .cm-activeLine":{backgroundColor:"#f3f9ff"},"&dark .cm-activeLine":{backgroundColor:"#223039"},"&light .cm-specialChar":{color:"red"},"&dark .cm-specialChar":{color:"#f78"},".cm-tab":{display:"inline-block",overflow:"hidden",verticalAlign:"bottom"},".cm-placeholder":{color:"#888",display:"inline-block",verticalAlign:"top"},".cm-button":{verticalAlign:"middle",color:"inherit",fontSize:"70%",padding:".2em 1em",borderRadius:"1px"},"&light .cm-button":{backgroundImage:"linear-gradient(#eff1f5, #d9d9df)",border:"1px solid #888","&:active":{backgroundImage:"linear-gradient(#b4b4b4, #d0d3d6)"}},"&dark .cm-button":{backgroundImage:"linear-gradient(#393939, #111)",border:"1px solid #888","&:active":{backgroundImage:"linear-gradient(#111, #333)"}},".cm-textfield":{verticalAlign:"middle",color:"inherit",fontSize:"70%",border:"1px solid silver",padding:".2em .5em"},"&light .cm-textfield":{backgroundColor:"white"},"&dark .cm-textfield":{border:"1px solid #555",backgroundColor:"inherit"}},lightDarkIDs),observeOptions={childList:!0,characterData:!0,subtree:!0,attributes:!0,characterDataOldValue:!0},useCharData=browser.ie&&11>=browser.ie_version;class DOMObserver{constructor(view,onChange,onScrollChanged){this.view=view,this.onChange=onChange,this.onScrollChanged=onScrollChanged,this.active=!1,this.selectionRange=new DOMSelectionState,this.selectionChanged=!1,this.delayedFlush=-1,this.resizeTimeout=-1,this.queue=[],this.delayedAndroidKey=null,this.scrollTargets=[],this.intersection=null,this.resize=null,this.intersecting=!1,this.gapIntersection=null,this.gaps=[],this.parentCheck=-1,this.dom=view.contentDOM,this.observer=new MutationObserver(mutations=>{for(let mut of mutations)this.queue.push(mut);// IE11 will sometimes (on typing over a selection or
// backspacing out a single character text node) call the
// observer callback before actually updating the DOM.
//
// Unrelatedly, iOS Safari will, when ending a composition,
// sometimes first clear it, deliver the mutations, and then
// reinsert the finished text. CodeMirror's handling of the
// deletion will prevent the reinsertion from happening,
// breaking composition.
(browser.ie&&11>=browser.ie_version||browser.ios&&view.composing)&&mutations.some(m=>"childList"==m.type&&m.removedNodes.length||"characterData"==m.type&&m.oldValue.length>m.target.nodeValue.length)?this.flushSoon():this.flush()}),useCharData&&(this.onCharData=event=>{this.queue.push({target:event.target,type:"characterData",oldValue:event.prevValue}),this.flushSoon()}),this.onSelectionChange=this.onSelectionChange.bind(this),"function"==typeof ResizeObserver&&(this.resize=new ResizeObserver(()=>{this.view.docView.lastUpdate<Date.now()-75&&0>this.resizeTimeout&&(this.resizeTimeout=setTimeout(()=>{this.resizeTimeout=-1,this.view.requestMeasure()},50))}),this.resize.observe(view.scrollDOM)),this.start(),this.onScroll=this.onScroll.bind(this),window.addEventListener("scroll",this.onScroll),"function"==typeof IntersectionObserver&&(this.intersection=new IntersectionObserver(entries=>{0>this.parentCheck&&(this.parentCheck=setTimeout(this.listenForScroll.bind(this),1e3)),0<entries.length&&0<entries[entries.length-1].intersectionRatio!=this.intersecting&&(this.intersecting=!this.intersecting,this.intersecting!=this.view.inView&&this.onScrollChanged(document.createEvent("Event")))},{}),this.intersection.observe(this.dom),this.gapIntersection=new IntersectionObserver(entries=>{0<entries.length&&0<entries[entries.length-1].intersectionRatio&&this.onScrollChanged(document.createEvent("Event"))},{})),this.listenForScroll(),this.readSelectionRange(),this.dom.ownerDocument.addEventListener("selectionchange",this.onSelectionChange)}onScroll(e){this.intersecting&&this.flush(!1),this.onScrollChanged(e)}updateGaps(gaps){if(this.gapIntersection&&(gaps.length!=this.gaps.length||this.gaps.some((g,i)=>g!=gaps[i]))){this.gapIntersection.disconnect();for(let gap of gaps)this.gapIntersection.observe(gap);this.gaps=gaps}}onSelectionChange(event){if(this.readSelectionRange()&&!this.delayedAndroidKey){let{view}=this,sel=this.selectionRange;if(view.state.facet(editable)?view.root.activeElement==this.dom:!!hasSelection(view.dom,sel)){let context=sel.anchorNode&&view.docView.nearest(sel.anchorNode);context&&context.ignoreEvent(event)||((browser.ie&&11>=browser.ie_version||browser.android&&browser.chrome)&&!view.state.selection.main.empty&&// (Selection.isCollapsed isn't reliable on IE)
sel.focusNode&&isEquivalentPosition(sel.focusNode,sel.focusOffset,sel.anchorNode,sel.anchorOffset)?this.flushSoon():this.flush(!1))}// Deletions on IE11 fire their events in the wrong order, giving
// us a selection change event before the DOM changes are
// reported.
// Chrome Android has a similar issue when backspacing out a
// selection (#645).
}}readSelectionRange(){let{root}=this.view,domSel=getSelection(root),range=browser.safari&&11==root.nodeType&&deepActiveElement()==this.view.contentDOM&&safariSelectionRangeHack(this.view)||domSel;// The Selection object is broken in shadow roots in Safari. See
// https://github.com/codemirror/codemirror.next/issues/414
return!this.selectionRange.eq(range)&&(this.selectionRange.setRange(range),this.selectionChanged=!0)}setSelectionRange(anchor,head){this.selectionRange.set(anchor.node,anchor.offset,head.node,head.offset),this.selectionChanged=!1}listenForScroll(){this.parentCheck=-1;let i=0,changed=null;for(let dom=this.dom;dom;)if(1==dom.nodeType)!changed&&i<this.scrollTargets.length&&this.scrollTargets[i]==dom?i++:!changed&&(changed=this.scrollTargets.slice(0,i)),changed&&changed.push(dom),dom=dom.assignedSlot||dom.parentNode;else if(11==dom.nodeType)// Shadow root
dom=dom.host;else break;if(i<this.scrollTargets.length&&!changed&&(changed=this.scrollTargets.slice(0,i)),changed){for(let dom of this.scrollTargets)dom.removeEventListener("scroll",this.onScroll);for(let dom of this.scrollTargets=changed)dom.addEventListener("scroll",this.onScroll)}}ignore(f){if(!this.active)return f();try{return this.stop(),f()}finally{this.start(),this.clear()}}start(){this.active||(this.observer.observe(this.dom,observeOptions),useCharData&&this.dom.addEventListener("DOMCharacterDataModified",this.onCharData),this.active=!0)}stop(){this.active&&(this.active=!1,this.observer.disconnect(),useCharData&&this.dom.removeEventListener("DOMCharacterDataModified",this.onCharData))}// Throw away any pending changes
clear(){this.observer.takeRecords(),this.queue.length=0,this.selectionChanged=!1}// Chrome Android, especially in combination with GBoard, not only
// doesn't reliably fire regular key events, but also often
// surrounds the effect of enter or backspace with a bunch of
// composition events that, when interrupted, cause text duplication
// or other kinds of corruption. This hack makes the editor back off
// from handling DOM changes for a moment when such a key is
// detected (via beforeinput or keydown), and then dispatches the
// key event, throwing away the DOM changes if it gets handled.
delayAndroidKey(key,keyCode){this.delayedAndroidKey||requestAnimationFrame(()=>{let key=this.delayedAndroidKey;this.delayedAndroidKey=null;let startState=this.view.state;dispatchKey(this.view.contentDOM,key.key,key.keyCode)?this.processRecords():this.flush(),this.view.state==startState&&this.view.update([])}),this.delayedAndroidKey&&"Enter"!=key||(this.delayedAndroidKey={key,keyCode})}flushSoon(){0>this.delayedFlush&&(this.delayedFlush=window.setTimeout(()=>{this.delayedFlush=-1,this.flush()},20))}forceFlush(){0<=this.delayedFlush&&(window.clearTimeout(this.delayedFlush),this.delayedFlush=-1,this.flush())}processRecords(){let records=this.queue;for(let mut of this.observer.takeRecords())records.push(mut);records.length&&(this.queue=[]);let from=-1,to=-1,typeOver=!1;for(let record of records){let range=this.readMutation(record);range&&(range.typeOver&&(typeOver=!0),-1==from?({from,to}=range):(from=Math.min(range.from,from),to=Math.max(range.to,to)))}return{from,to,typeOver}}// Apply pending changes, if any
flush(readSelection=!0){// Completely hold off flushing when pending keys are set—the code
// managing those will make sure processRecords is called and the
// view is resynchronized after
if(0<=this.delayedFlush||this.delayedAndroidKey)return;readSelection&&this.readSelectionRange();let{from,to,typeOver}=this.processRecords(),newSel=this.selectionChanged&&hasSelection(this.dom,this.selectionRange);if(!(0>from)||newSel){this.selectionChanged=!1;let startState=this.view.state;this.onChange(from,to,typeOver),this.view.state==startState&&this.view.update([])}}readMutation(rec){let cView=this.view.docView.nearest(rec.target);if(!cView||cView.ignoreMutation(rec))return null;if(cView.markDirty("attributes"==rec.type),"attributes"==rec.type&&(cView.dirty|=4/* Attrs */),"childList"==rec.type){let childBefore=findChild(cView,rec.previousSibling||rec.target.previousSibling,-1),childAfter=findChild(cView,rec.nextSibling||rec.target.nextSibling,1);return{from:childBefore?cView.posAfter(childBefore):cView.posAtStart,to:childAfter?cView.posBefore(childAfter):cView.posAtEnd,typeOver:!1}}return"characterData"==rec.type?{from:cView.posAtStart,to:cView.posAtEnd,typeOver:rec.target.nodeValue==rec.oldValue}:null}destroy(){var _a,_b,_c;this.stop(),null===(_a=this.intersection)||void 0===_a?void 0:_a.disconnect(),null===(_b=this.gapIntersection)||void 0===_b?void 0:_b.disconnect(),null===(_c=this.resize)||void 0===_c?void 0:_c.disconnect();for(let dom of this.scrollTargets)dom.removeEventListener("scroll",this.onScroll);window.removeEventListener("scroll",this.onScroll),this.dom.ownerDocument.removeEventListener("selectionchange",this.onSelectionChange),clearTimeout(this.parentCheck),clearTimeout(this.resizeTimeout)}}class EditorView{/// Construct a new view. You'll usually want to put `view.dom` into
/// your document after creating a view, so that the user can see
/// it.
constructor(/// Initialization options.
config={}){this.plugins=[],this.pluginMap=new Map,this.editorAttrs={},this.contentAttrs={},this.bidiCache=[],this.destroyed=!1,this.updateState=2/* Updating */,this.measureScheduled=-1,this.measureRequests=[],this.contentDOM=document.createElement("div"),this.scrollDOM=document.createElement("div"),this.scrollDOM.tabIndex=-1,this.scrollDOM.className="cm-scroller",this.scrollDOM.appendChild(this.contentDOM),this.announceDOM=document.createElement("div"),this.announceDOM.style.cssText="position: absolute; top: -10000px",this.announceDOM.setAttribute("aria-live","polite"),this.dom=document.createElement("div"),this.dom.appendChild(this.announceDOM),this.dom.appendChild(this.scrollDOM),this._dispatch=config.dispatch||(tr=>this.update([tr])),this.dispatch=this.dispatch.bind(this),this.root=config.root||getRoot(config.parent)||document,this.viewState=new ViewState(config.state||state.EditorState.create()),this.plugins=this.state.facet(viewPlugin).map(spec=>new PluginInstance(spec));for(let plugin of this.plugins)plugin.update(this);this.observer=new DOMObserver(this,(from,to,typeOver)=>{applyDOMChange(this,from,to,typeOver)},event=>{this.inputState.runScrollHandlers(this,event),this.observer.intersecting&&this.measure()}),this.inputState=new InputState(this),this.docView=new DocView(this),this.mountStyles(),this.updateAttrs(),this.updateState=0/* Idle */,ensureGlobalHandler(),this.requestMeasure(),config.parent&&config.parent.appendChild(this.dom)}/// The current editor state.
get state(){return this.viewState.state}/// To be able to display large documents without consuming too much
/// memory or overloading the browser, CodeMirror only draws the
/// code that is visible (plus a margin around it) to the DOM. This
/// property tells you the extent of the current drawn viewport, in
/// document positions.
get viewport(){return this.viewState.viewport}/// When there are, for example, large collapsed ranges in the
/// viewport, its size can be a lot bigger than the actual visible
/// content. Thus, if you are doing something like styling the
/// content in the viewport, it is preferable to only do so for
/// these ranges, which are the subset of the viewport that is
/// actually drawn.
get visibleRanges(){return this.viewState.visibleRanges}/// Returns false when the editor is entirely scrolled out of view
/// or otherwise hidden.
get inView(){return this.viewState.inView}/// Indicates whether the user is currently composing text via
/// [IME](https://en.wikipedia.org/wiki/Input_method).
get composing(){return 0<this.inputState.composing}dispatch(...input){this._dispatch(1==input.length&&input[0]instanceof state.Transaction?input[0]:this.state.update(...input))}/// Update the view for the given array of transactions. This will
/// update the visible document and selection to match the state
/// produced by the transactions, and notify view plugins of the
/// change. You should usually call
/// [`dispatch`](#view.EditorView.dispatch) instead, which uses this
/// as a primitive.
update(transactions){if(0!=this.updateState/* Idle */)throw new Error("Calls to EditorView.update are not allowed while an update is in progress");let update,redrawn=!1,state$1=this.state;for(let tr of transactions){if(tr.startState!=state$1)throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");state$1=tr.state}if(this.destroyed)return void(this.viewState.state=state$1);// When the phrases change, redraw the editor
if(state$1.facet(state.EditorState.phrases)!=this.state.facet(state.EditorState.phrases))return this.setState(state$1);update=new ViewUpdate(this,state$1,transactions);let scrollTarget=this.viewState.scrollTarget;try{this.updateState=2/* Updating */;for(let tr of transactions){if(scrollTarget&&(scrollTarget=scrollTarget.map(tr.changes)),tr.scrollIntoView){let{main}=tr.state.selection;scrollTarget=new ScrollTarget(main.empty?main:state.EditorSelection.cursor(main.head,main.head>main.anchor?-1:1))}for(let e of tr.effects)e.is(scrollTo)?scrollTarget=new ScrollTarget(e.value):e.is(centerOn)?scrollTarget=new ScrollTarget(e.value,"center"):e.is(scrollIntoView)&&(scrollTarget=e.value)}this.viewState.update(update,scrollTarget),this.bidiCache=CachedOrder.update(this.bidiCache,update.changes),update.empty||(this.updatePlugins(update),this.inputState.update(update)),redrawn=this.docView.update(update),this.state.facet(styleModule)!=this.styleModules&&this.mountStyles(),this.updateAttrs(),this.showAnnouncements(transactions),this.docView.updateSelection(redrawn,transactions.some(tr=>tr.isUserEvent("select.pointer")))}finally{this.updateState=0/* Idle */}if((redrawn||scrollTarget||this.viewState.mustEnforceCursorAssoc)&&this.requestMeasure(),!update.empty)for(let listener of this.state.facet(updateListener))listener(update)}/// Reset the view to the given state. (This will cause the entire
/// document to be redrawn and all view plugins to be reinitialized,
/// so you should probably only use it when the new state isn't
/// derived from the old state. Otherwise, use
/// [`dispatch`](#view.EditorView.dispatch) instead.)
setState(newState){if(0!=this.updateState/* Idle */)throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");if(this.destroyed)return void(this.viewState.state=newState);this.updateState=2/* Updating */;try{for(let plugin of this.plugins)plugin.destroy(this);this.viewState=new ViewState(newState),this.plugins=newState.facet(viewPlugin).map(spec=>new PluginInstance(spec)),this.pluginMap.clear();for(let plugin of this.plugins)plugin.update(this);this.docView=new DocView(this),this.inputState.ensureHandlers(this),this.mountStyles(),this.updateAttrs(),this.bidiCache=[]}finally{this.updateState=0/* Idle */}this.requestMeasure()}updatePlugins(update){let prevSpecs=update.startState.facet(viewPlugin),specs=update.state.facet(viewPlugin);if(prevSpecs!=specs){let newPlugins=[];for(let spec of specs){let found=prevSpecs.indexOf(spec);if(0>found)newPlugins.push(new PluginInstance(spec));else{let plugin=this.plugins[found];plugin.mustUpdate=update,newPlugins.push(plugin)}}for(let plugin of this.plugins)plugin.mustUpdate!=update&&plugin.destroy(this);this.plugins=newPlugins,this.pluginMap.clear(),this.inputState.ensureHandlers(this)}else for(let p of this.plugins)p.mustUpdate=update;for(let i=0;i<this.plugins.length;i++)this.plugins[i].update(this)}/// @internal
measure(flush=!0){if(this.destroyed)return;-1<this.measureScheduled&&cancelAnimationFrame(this.measureScheduled),this.measureScheduled=0,flush&&this.observer.flush();let updated=null;try{for(let i=0;;i++){this.updateState=1/* Measuring */;let oldViewport=this.viewport,changed=this.viewState.measure(this);if(!changed&&!this.measureRequests.length&&null==this.viewState.scrollTarget)break;if(5<i){console.warn(this.measureRequests.length?"Measure loop restarted more than 5 times":"Viewport failed to stabilize");break}let measuring=[];// Only run measure requests in this cycle when the viewport didn't change
4&changed/* Viewport */||([this.measureRequests,measuring]=[measuring,this.measureRequests]);let measured=measuring.map(m=>{try{return m.read(this)}catch(e){return logException(this.state,e),BadMeasure}}),update=new ViewUpdate(this,this.state),redrawn=!1;update.flags|=changed,updated?updated.flags|=changed:updated=update,this.updateState=2/* Updating */,update.empty||(this.updatePlugins(update),this.inputState.update(update),this.updateAttrs(),redrawn=this.docView.update(update));for(let i=0;i<measuring.length;i++)if(measured[i]!=BadMeasure)try{let m=measuring[i];m.write&&m.write(measured[i],this)}catch(e){logException(this.state,e)}if(this.viewState.scrollTarget&&(this.docView.scrollIntoView(this.viewState.scrollTarget),this.viewState.scrollTarget=null),redrawn&&this.docView.updateSelection(!0),this.viewport.from==oldViewport.from&&this.viewport.to==oldViewport.to&&0==this.measureRequests.length)break}}finally{this.updateState=0/* Idle */,this.measureScheduled=-1}if(updated&&!updated.empty)for(let listener of this.state.facet(updateListener))listener(updated)}/// Get the CSS classes for the currently active editor themes.
get themeClasses(){return baseThemeID+" "+(this.state.facet(darkTheme)?baseDarkID:baseLightID)+" "+this.state.facet(theme)}updateAttrs(){let editorAttrs=attrsFromFacet(this,editorAttributes,{class:"cm-editor"+(this.hasFocus?" cm-focused ":" ")+this.themeClasses}),contentAttrs={spellcheck:"false",autocorrect:"off",autocapitalize:"off",translate:"no",contenteditable:this.state.facet(editable)?"true":"false",class:"cm-content",style:`${browser.tabSize}: ${this.state.tabSize}`,role:"textbox","aria-multiline":"true"};this.state.readOnly&&(contentAttrs["aria-readonly"]="true"),attrsFromFacet(this,contentAttributes,contentAttrs),this.observer.ignore(()=>{updateAttrs(this.contentDOM,this.contentAttrs,contentAttrs),updateAttrs(this.dom,this.editorAttrs,editorAttrs)}),this.editorAttrs=editorAttrs,this.contentAttrs=contentAttrs}showAnnouncements(trs){let first=!0;for(let tr of trs)for(let effect of tr.effects)if(effect.is(EditorView.announce)){first&&(this.announceDOM.textContent=""),first=!1;let div=this.announceDOM.appendChild(document.createElement("div"));div.textContent=effect.value}}mountStyles(){this.styleModules=this.state.facet(styleModule),styleMod.StyleModule.mount(this.root,this.styleModules.concat(baseTheme).reverse())}readMeasured(){if(2==this.updateState/* Updating */)throw new Error("Reading the editor layout isn't allowed during an update");0==this.updateState/* Idle */&&-1<this.measureScheduled&&this.measure(!1)}/// Schedule a layout measurement, optionally providing callbacks to
/// do custom DOM measuring followed by a DOM write phase. Using
/// this is preferable reading DOM layout directly from, for
/// example, an event handler, because it'll make sure measuring and
/// drawing done by other components is synchronized, avoiding
/// unnecessary DOM layout computations.
requestMeasure(request){if(0>this.measureScheduled&&(this.measureScheduled=requestAnimationFrame(()=>this.measure())),request){if(null!=request.key)for(let i=0;i<this.measureRequests.length;i++)if(this.measureRequests[i].key===request.key)return void(this.measureRequests[i]=request);this.measureRequests.push(request)}}/// Collect all values provided by the active plugins for a given
/// field.
pluginField(field){let result=[];for(let plugin of this.plugins)plugin.update(this).takeField(field,result);return result}/// Get the value of a specific plugin, if present. Note that
/// plugins that crash can be dropped from a view, so even when you
/// know you registered a given plugin, it is recommended to check
/// the return value of this method.
plugin(plugin){let known=this.pluginMap.get(plugin);return(void 0===known||known&&known.spec!=plugin)&&this.pluginMap.set(plugin,known=this.plugins.find(p=>p.spec==plugin)||null),known&&known.update(this).value}/// The top position of the document, in screen coordinates. This
/// may be negative when the editor is scrolled down. Points
/// directly to the top of the first line, not above the padding.
get documentTop(){return this.contentDOM.getBoundingClientRect().top+this.viewState.paddingTop}/// Reports the padding above and below the document.
get documentPadding(){return{top:this.viewState.paddingTop,bottom:this.viewState.paddingBottom}}/// Find the line or block widget at the given vertical position.
///
/// By default, this position is interpreted as a screen position,
/// meaning `docTop` is set to the DOM top position of the editor
/// content (forcing a layout). You can pass a different `docTop`
/// value—for example 0 to interpret `height` as a document-relative
/// position, or a precomputed document top
/// (`view.contentDOM.getBoundingClientRect().top`) to limit layout
/// queries.
///
/// *Deprecated: use `elementAtHeight` instead.*
blockAtHeight(height,docTop){let top=ensureTop(docTop,this);return this.elementAtHeight(height-top).moveY(top)}/// Find the text line or block widget at the given vertical
/// position (which is interpreted as relative to the [top of the
/// document](#view.EditorView.documentTop)
elementAtHeight(height){return this.readMeasured(),this.viewState.elementAtHeight(height)}/// Find information for the visual line (see
/// [`visualLineAt`](#view.EditorView.visualLineAt)) at the given
/// vertical position. The resulting block info might hold another
/// array of block info structs in its `type` field if this line
/// consists of more than one block.
///
/// Defaults to treating `height` as a screen position. See
/// [`blockAtHeight`](#view.EditorView.blockAtHeight) for the
/// interpretation of the `docTop` parameter.
///
/// *Deprecated: use `lineBlockAtHeight` instead.*
visualLineAtHeight(height,docTop){let top=ensureTop(docTop,this);return this.lineBlockAtHeight(height-top).moveY(top)}/// Find the line block (see
/// [`lineBlockAt`](#view.EditorView.lineBlockAt) at the given
/// height.
lineBlockAtHeight(height){return this.readMeasured(),this.viewState.lineBlockAtHeight(height)}/// Iterate over the height information of the visual lines in the
/// viewport. The heights of lines are reported relative to the
/// given document top, which defaults to the screen position of the
/// document (forcing a layout).
///
/// *Deprecated: use `viewportLineBlocks` instead.*
viewportLines(f,docTop){let top=ensureTop(docTop,this);for(let line of this.viewportLineBlocks)f(line.moveY(top))}/// Get the extent and vertical position of all [line
/// blocks](#view.EditorView.lineBlockAt) in the viewport. Positions
/// are relative to the [top of the
/// document](#view.EditorView.documentTop);
get viewportLineBlocks(){return this.viewState.viewportLines}/// Find the extent and height of the visual line (a range delimited
/// on both sides by either non-[hidden](#view.Decoration^range)
/// line breaks, or the start/end of the document) at the given position.
///
/// Vertical positions are computed relative to the `docTop`
/// argument, which defaults to 0 for this method. You can pass
/// `view.contentDOM.getBoundingClientRect().top` here to get screen
/// coordinates.
///
/// *Deprecated: use `lineBlockAt` instead.*
visualLineAt(pos,docTop=0){return this.lineBlockAt(pos).moveY(docTop+this.viewState.paddingTop)}/// Find the line block around the given document position. A line
/// block is a range delimited on both sides by either a
/// non-[hidden](#view.Decoration^range) line breaks, or the
/// start/end of the document. It will usually just hold a line of
/// text, but may be broken into multiple textblocks by block
/// widgets.
lineBlockAt(pos){return this.viewState.lineBlockAt(pos)}/// The editor's total content height.
get contentHeight(){return this.viewState.contentHeight}/// Move a cursor position by [grapheme
/// cluster](#text.findClusterBreak). `forward` determines whether
/// the motion is away from the line start, or towards it. Motion in
/// bidirectional text is in visual order, in the editor's [text
/// direction](#view.EditorView.textDirection). When the start
/// position was the last one on the line, the returned position
/// will be across the line break. If there is no further line, the
/// original position is returned.
///
/// By default, this method moves over a single cluster. The
/// optional `by` argument can be used to move across more. It will
/// be called with the first cluster as argument, and should return
/// a predicate that determines, for each subsequent cluster,
/// whether it should also be moved over.
moveByChar(start,forward,by){return skipAtoms(this,start,moveByChar(this,start,forward,by))}/// Move a cursor position across the next group of either
/// [letters](#state.EditorState.charCategorizer) or non-letter
/// non-whitespace characters.
moveByGroup(start,forward){return skipAtoms(this,start,moveByChar(this,start,forward,initial=>byGroup(this,start.head,initial)))}/// Move to the next line boundary in the given direction. If
/// `includeWrap` is true, line wrapping is on, and there is a
/// further wrap point on the current line, the wrap point will be
/// returned. Otherwise this function will return the start or end
/// of the line.
moveToLineBoundary(start,forward,includeWrap=!0){return moveToLineBoundary(this,start,forward,includeWrap)}/// Move a cursor position vertically. When `distance` isn't given,
/// it defaults to moving to the next line (including wrapped
/// lines). Otherwise, `distance` should provide a positive distance
/// in pixels.
///
/// When `start` has a
/// [`goalColumn`](#state.SelectionRange.goalColumn), the vertical
/// motion will use that as a target horizontal position. Otherwise,
/// the cursor's own horizontal position is used. The returned
/// cursor will have its goal column set to whichever column was
/// used.
moveVertically(start,forward,distance){return skipAtoms(this,start,moveVertically(this,start,forward,distance))}// FIXME remove on next major version
scrollPosIntoView(pos){this.dispatch({effects:scrollTo.of(state.EditorSelection.cursor(pos))})}/// Find the DOM parent node and offset (child offset if `node` is
/// an element, character offset when it is a text node) at the
/// given document position.
///
/// Note that for positions that aren't currently in
/// `visibleRanges`, the resulting DOM position isn't necessarily
/// meaningful (it may just point before or after a placeholder
/// element).
domAtPos(pos){return this.docView.domAtPos(pos)}/// Find the document position at the given DOM node. Can be useful
/// for associating positions with DOM events. Will raise an error
/// when `node` isn't part of the editor content.
posAtDOM(node,offset=0){return this.docView.posFromDOM(node,offset)}posAtCoords(coords,precise=!0){return this.readMeasured(),posAtCoords(this,coords,precise)}/// Get the screen coordinates at the given document position.
/// `side` determines whether the coordinates are based on the
/// element before (-1) or after (1) the position (if no element is
/// available on the given side, the method will transparently use
/// another strategy to get reasonable coordinates).
coordsAtPos(pos,side=1){this.readMeasured();let rect=this.docView.coordsAt(pos,side);if(!rect||rect.left==rect.right)return rect;let line=this.state.doc.lineAt(pos),order=this.bidiSpans(line),span=order[BidiSpan.find(order,pos-line.from,-1,side)];return flattenRect(rect,span.dir==exports.Direction.LTR==0<side)}/// The default width of a character in the editor. May not
/// accurately reflect the width of all characters (given variable
/// width fonts or styling of invididual ranges).
get defaultCharacterWidth(){return this.viewState.heightOracle.charWidth}/// The default height of a line in the editor. May not be accurate
/// for all lines.
get defaultLineHeight(){return this.viewState.heightOracle.lineHeight}/// The text direction
/// ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
/// CSS property) of the editor.
get textDirection(){return this.viewState.heightOracle.direction}/// Whether this editor [wraps lines](#view.EditorView.lineWrapping)
/// (as determined by the
/// [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
/// CSS property of its content element).
get lineWrapping(){return this.viewState.heightOracle.lineWrapping}/// Returns the bidirectional text structure of the given line
/// (which should be in the current document) as an array of span
/// objects. The order of these spans matches the [text
/// direction](#view.EditorView.textDirection)—if that is
/// left-to-right, the leftmost spans come first, otherwise the
/// rightmost spans come first.
bidiSpans(line){if(line.length>MaxBidiLine)return trivialOrder(line.length);let dir=this.textDirection;for(let entry of this.bidiCache)if(entry.from==line.from&&entry.dir==dir)return entry.order;let order=computeOrder(line.text,this.textDirection);return this.bidiCache.push(new CachedOrder(line.from,line.to,dir,order)),order}/// Check whether the editor has focus.
get hasFocus(){var _a;// Safari return false for hasFocus when the context menu is open
// or closing, which leads us to ignore selection changes from the
// context menu because it looks like the editor isn't focused.
// This kludges around that.
return(document.hasFocus()||browser.safari&&(null===(_a=this.inputState)||void 0===_a?void 0:_a.lastContextMenu)>Date.now()-3e4)&&this.root.activeElement==this.contentDOM}/// Put focus on the editor.
focus(){this.observer.ignore(()=>{focusPreventScroll(this.contentDOM),this.docView.updateSelection()})}/// Clean up this editor view, removing its element from the
/// document, unregistering event handlers, and notifying
/// plugins. The view instance can no longer be used after
/// calling this.
destroy(){for(let plugin of this.plugins)plugin.destroy(this);this.plugins=[],this.inputState.destroy(),this.dom.remove(),this.observer.destroy(),-1<this.measureScheduled&&cancelAnimationFrame(this.measureScheduled),this.destroyed=!0}/// Returns an effect that can be
/// [added](#state.TransactionSpec.effects) to a transaction to
/// cause it to scroll the given position or range into view.
static scrollIntoView(pos,options={}){return scrollIntoView.of(new ScrollTarget("number"==typeof pos?state.EditorSelection.cursor(pos):pos,options.y,options.x,options.yMargin,options.xMargin))}/// Facet that can be used to add DOM event handlers. The value
/// should be an object mapping event names to handler functions. The
/// first such function to return true will be assumed to have handled
/// that event, and no other handlers or built-in behavior will be
/// activated for it.
/// These are registered on the [content
/// element](#view.EditorView.contentDOM), except for `scroll`
/// handlers, which will be called any time the editor's [scroll
/// element](#view.EditorView.scrollDOM) or one of its parent nodes
/// is scrolled.
static domEventHandlers(handlers){return ViewPlugin.define(()=>({}),{eventHandlers:handlers})}/// Create a theme extension. The first argument can be a
/// [`style-mod`](https://github.com/marijnh/style-mod#documentation)
/// style spec providing the styles for the theme. These will be
/// prefixed with a generated class for the style.
///
/// Because the selectors will be prefixed with a scope class, rule
/// that directly match the editor's [wrapper
/// element](#view.EditorView.dom)—to which the scope class will be
/// added—need to be explicitly differentiated by adding an `&` to
/// the selector for that element—for example
/// `&.cm-focused`.
///
/// When `dark` is set to true, the theme will be marked as dark,
/// which will cause the `&dark` rules from [base
/// themes](#view.EditorView^baseTheme) to be used (as opposed to
/// `&light` when a light theme is active).
static theme(spec,options){let prefix=styleMod.StyleModule.newName(),result=[theme.of(prefix),styleModule.of(buildTheme(`.${prefix}`,spec))];return options&&options.dark&&result.push(darkTheme.of(!0)),result}/// Create an extension that adds styles to the base theme. Like
/// with [`theme`](#view.EditorView^theme), use `&` to indicate the
/// place of the editor wrapper element when directly targeting
/// that. You can also use `&dark` or `&light` instead to only
/// target editors with a dark or light theme.
static baseTheme(spec){return state.Prec.lowest(styleModule.of(buildTheme("."+baseThemeID,spec,lightDarkIDs)))}}/// Effect that can be [added](#state.TransactionSpec.effects) to a
/// transaction to make it scroll the given range into view.
///
/// *Deprecated*. Use [`scrollIntoView`](#view.EditorView^scrollIntoView) instead.
EditorView.scrollTo=scrollTo,EditorView.centerOn=centerOn,EditorView.styleModule=styleModule,EditorView.inputHandler=inputHandler,EditorView.exceptionSink=exceptionSink,EditorView.updateListener=updateListener,EditorView.editable=editable,EditorView.mouseSelectionStyle=mouseSelectionStyle,EditorView.dragMovesSelection=dragMovesSelection$1,EditorView.clickAddsSelectionRange=clickAddsSelectionRange,EditorView.decorations=decorations,EditorView.darkTheme=darkTheme,EditorView.contentAttributes=contentAttributes,EditorView.editorAttributes=editorAttributes,EditorView.lineWrapping=EditorView.contentAttributes.of({class:"cm-lineWrapping"}),EditorView.announce=state.StateEffect.define();// Maximum line length for which we compute accurate bidi info
const MaxBidiLine=4096;let resizeDebounce=-1;const BadMeasure={};class CachedOrder{constructor(from,to,dir,order){this.from=from,this.to=to,this.dir=dir,this.order=order}static update(cache,changes){if(changes.empty)return cache;let result=[],lastDir=cache.length?cache[cache.length-1].dir:exports.Direction.LTR;for(let entry,i=Math.max(0,cache.length-10);i<cache.length;i++)entry=cache[i],entry.dir!=lastDir||changes.touchesRange(entry.from,entry.to)||result.push(new CachedOrder(changes.mapPos(entry.from,1),changes.mapPos(entry.to,-1),entry.dir,entry.order));return result}}const currentPlatform=browser.mac?"mac":browser.windows?"win":browser.linux?"linux":"key",handleKeyEvents=EditorView.domEventHandlers({keydown(event,view){return runHandlers(getKeymap(view.state),event,view,"editor")}}),keymap=state.Facet.define({enables:handleKeyEvents}),Keymaps=new WeakMap;let storedPrefix=null;const PrefixTimeout=4e3,CanHidePrimary=!browser.ios,selectionConfig=state.Facet.define({combine(configs){return state.combineConfig(configs,{cursorBlinkRate:1200,drawRangeCursor:!0},{cursorBlinkRate:(a,b)=>Math.min(a,b),drawRangeCursor:(a,b)=>a||b})}});class Piece{constructor(left,top,width,height,className){this.left=left,this.top=top,this.width=width,this.height=height,this.className=className}draw(){let elt=document.createElement("div");return elt.className=this.className,this.adjust(elt),elt}adjust(elt){elt.style.left=this.left+"px",elt.style.top=this.top+"px",0<=this.width&&(elt.style.width=this.width+"px"),elt.style.height=this.height+"px"}eq(p){return this.left==p.left&&this.top==p.top&&this.width==p.width&&this.height==p.height&&this.className==p.className}}const drawSelectionPlugin=ViewPlugin.fromClass(class{constructor(view){this.view=view,this.rangePieces=[],this.cursors=[],this.measureReq={read:this.readPos.bind(this),write:this.drawSel.bind(this)},this.selectionLayer=view.scrollDOM.appendChild(document.createElement("div")),this.selectionLayer.className="cm-selectionLayer",this.selectionLayer.setAttribute("aria-hidden","true"),this.cursorLayer=view.scrollDOM.appendChild(document.createElement("div")),this.cursorLayer.className="cm-cursorLayer",this.cursorLayer.setAttribute("aria-hidden","true"),view.requestMeasure(this.measureReq),this.setBlinkRate()}setBlinkRate(){this.cursorLayer.style.animationDuration=this.view.state.facet(selectionConfig).cursorBlinkRate+"ms"}update(update){let confChanged=update.startState.facet(selectionConfig)!=update.state.facet(selectionConfig);(confChanged||update.selectionSet||update.geometryChanged||update.viewportChanged)&&this.view.requestMeasure(this.measureReq),update.transactions.some(tr=>tr.scrollIntoView)&&(this.cursorLayer.style.animationName="cm-blink"==this.cursorLayer.style.animationName?"cm-blink2":"cm-blink"),confChanged&&this.setBlinkRate()}readPos(){let{state}=this.view,conf=state.facet(selectionConfig),rangePieces=state.selection.ranges.map(r=>r.empty?[]:measureRange(this.view,r)).reduce((a,b)=>a.concat(b)),cursors=[];for(let r of state.selection.ranges){let prim=r==state.selection.main;if(r.empty?!prim||CanHidePrimary:conf.drawRangeCursor){let piece=measureCursor(this.view,r,prim);piece&&cursors.push(piece)}}return{rangePieces,cursors}}drawSel({rangePieces,cursors}){if(rangePieces.length!=this.rangePieces.length||rangePieces.some((p,i)=>!p.eq(this.rangePieces[i]))){this.selectionLayer.textContent="";for(let p of rangePieces)this.selectionLayer.appendChild(p.draw());this.rangePieces=rangePieces}if(cursors.length!=this.cursors.length||cursors.some((c,i)=>!c.eq(this.cursors[i]))){let oldCursors=this.cursorLayer.children;if(oldCursors.length!==cursors.length){this.cursorLayer.textContent="";for(const c of cursors)this.cursorLayer.appendChild(c.draw())}else cursors.forEach((c,idx)=>c.adjust(oldCursors[idx]));this.cursors=cursors}}destroy(){this.selectionLayer.remove(),this.cursorLayer.remove()}}),themeSpec={".cm-line":{"& ::selection":{backgroundColor:"transparent !important"},"&::selection":{backgroundColor:"transparent !important"}}};CanHidePrimary&&(themeSpec[".cm-line"].caretColor="transparent !important");const hideNativeSelection=state.Prec.highest(EditorView.theme(themeSpec)),setDropCursorPos=state.StateEffect.define({map(pos,mapping){return null==pos?null:mapping.mapPos(pos)}}),dropCursorPos=state.StateField.define({create(){return null},update(pos,tr){return null!=pos&&(pos=tr.changes.mapPos(pos)),tr.effects.reduce((pos,e)=>e.is(setDropCursorPos)?e.value:pos,pos)}}),drawDropCursor=ViewPlugin.fromClass(class{constructor(view){this.view=view,this.cursor=null,this.measureReq={read:this.readPos.bind(this),write:this.drawCursor.bind(this)}}update(update){var _a;let cursorPos=update.state.field(dropCursorPos);null==cursorPos?null!=this.cursor&&(null===(_a=this.cursor)||void 0===_a?void 0:_a.remove(),this.cursor=null):(!this.cursor&&(this.cursor=this.view.scrollDOM.appendChild(document.createElement("div")),this.cursor.className="cm-dropCursor"),(update.startState.field(dropCursorPos)!=cursorPos||update.docChanged||update.geometryChanged)&&this.view.requestMeasure(this.measureReq))}readPos(){let pos=this.view.state.field(dropCursorPos),rect=null!=pos&&this.view.coordsAtPos(pos);if(!rect)return null;let outer=this.view.scrollDOM.getBoundingClientRect();return{left:rect.left-outer.left+this.view.scrollDOM.scrollLeft,top:rect.top-outer.top+this.view.scrollDOM.scrollTop,height:rect.bottom-rect.top}}drawCursor(pos){this.cursor&&(pos?(this.cursor.style.left=pos.left+"px",this.cursor.style.top=pos.top+"px",this.cursor.style.height=pos.height+"px"):this.cursor.style.left="-100000px")}destroy(){this.cursor&&this.cursor.remove()}setDropPos(pos){this.view.state.field(dropCursorPos)!=pos&&this.view.dispatch({effects:setDropCursorPos.of(pos)})}},{eventHandlers:{dragover(event){this.setDropPos(this.view.posAtCoords({x:event.clientX,y:event.clientY}))},dragleave(event){event.target!=this.view.contentDOM&&this.view.contentDOM.contains(event.relatedTarget)||this.setDropPos(null)},dragend(){this.setDropPos(null)},drop(){this.setDropPos(null)}}});class MatchDecorator{/// Create a decorator.
constructor(config){let{regexp,decoration,boundary,maxLength=1e3}=config;if(!regexp.global)throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");this.regexp=regexp,this.getDeco="function"==typeof decoration?decoration:()=>decoration,this.boundary=boundary,this.maxLength=maxLength}/// Compute the full set of decorations for matches in the given
/// view's viewport. You'll want to call this when initializing your
/// plugin.
createDeco(view){let build=new rangeset.RangeSetBuilder;for(let{from,to}of matchRanges(view,this.maxLength))iterMatches(view.state.doc,this.regexp,from,to,(a,b,m)=>build.add(a,b,this.getDeco(m,view,a)));return build.finish()}/// Update a set of decorations for a view update. `deco` _must_ be
/// the set of decorations produced by _this_ `MatchDecorator` for
/// the view state before the update.
updateDeco(update,deco){let changeFrom=1e9,changeTo=-1;return update.docChanged&&update.changes.iterChanges((_f,_t,from,to)=>{to>update.view.viewport.from&&from<update.view.viewport.to&&(changeFrom=Math.min(from,changeFrom),changeTo=Math.max(to,changeTo))}),update.viewportChanged||1e3<changeTo-changeFrom?this.createDeco(update.view):-1<changeTo?this.updateRange(update.view,deco.map(update.changes),changeFrom,changeTo):deco}updateRange(view,deco,updateFrom,updateTo){for(let r of view.visibleRanges){let from=Math.max(r.from,updateFrom),to=Math.min(r.to,updateTo);if(to>from){let fromLine=view.state.doc.lineAt(from),toLine=fromLine.to<to?view.state.doc.lineAt(to):fromLine,start=Math.max(r.from,fromLine.from),end=Math.min(r.to,toLine.to);if(this.boundary){for(;from>fromLine.from;from--)if(this.boundary.test(fromLine.text[from-1-fromLine.from])){start=from;break}for(;to<toLine.to;to++)if(this.boundary.test(toLine.text[to-toLine.from])){end=to;break}}let m,ranges=[];if(fromLine==toLine)for(this.regexp.lastIndex=start-fromLine.from;(m=this.regexp.exec(fromLine.text))&&m.index<end-fromLine.from;){let pos=m.index+fromLine.from;ranges.push(this.getDeco(m,view,pos).range(pos,pos+m[0].length))}else iterMatches(view.state.doc,this.regexp,start,end,(from,to,m)=>ranges.push(this.getDeco(m,view,from).range(from,to)));deco=deco.update({filterFrom:start,filterTo:end,filter:(from,to)=>from<start||to>end,add:ranges})}}return deco}}const UnicodeRegexpSupport=null==/x/.unicode?"g":"gu",Specials=new RegExp("[\0-\b\n-\x1F\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\uFEFF\uFFF9-\uFFFC]",UnicodeRegexpSupport),Names={0:"null",7:"bell",8:"backspace",10:"newline",11:"vertical tab",13:"carriage return",27:"escape",8203:"zero width space",8204:"zero width non-joiner",8205:"zero width joiner",8206:"left-to-right mark",8207:"right-to-left mark",8232:"line separator",8237:"left-to-right override",8238:"right-to-left override",8233:"paragraph separator",65279:"zero width no-break space",65532:"object replacement"};let _supportsTabSize=null;const specialCharConfig=state.Facet.define({combine(configs){let config=state.combineConfig(configs,{render:null,specialChars:Specials,addSpecialChars:null});return(config.replaceTabs=!supportsTabSize())&&(config.specialChars=new RegExp("\t|"+config.specialChars.source,UnicodeRegexpSupport)),config.addSpecialChars&&(config.specialChars=new RegExp(config.specialChars.source+"|"+config.addSpecialChars.source,UnicodeRegexpSupport)),config}});/// Returns an extension that installs highlighting of special
/// characters.
let _plugin=null;class SpecialCharWidget extends WidgetType{constructor(options,code){super(),this.options=options,this.code=code}eq(other){return other.code==this.code}toDOM(view){let ph=placeholder$1(this.code),desc=view.state.phrase("Control character")+" "+(Names[this.code]||"0x"+this.code.toString(16)),custom=this.options.render&&this.options.render(this.code,desc,ph);if(custom)return custom;let span=document.createElement("span");return span.textContent=ph,span.title=desc,span.setAttribute("aria-label",desc),span.className="cm-specialChar",span}ignoreEvent(){return!1}}class TabWidget extends WidgetType{constructor(width){super(),this.width=width}eq(other){return other.width==this.width}toDOM(){let span=document.createElement("span");return span.textContent="\t",span.className="cm-tab",span.style.width=this.width+"px",span}ignoreEvent(){return!1}}const plugin=ViewPlugin.fromClass(class{constructor(){this.height=1e3,this.attrs={style:"padding-bottom: 1000px"}}update(update){let height=update.view.viewState.editorHeight-update.view.defaultLineHeight;height!=this.height&&(this.height=height,this.attrs={style:`padding-bottom: ${height}px`})}}),lineDeco=Decoration.line({class:"cm-activeLine"}),activeLineHighlighter=ViewPlugin.fromClass(class{constructor(view){this.decorations=this.getDeco(view)}update(update){(update.docChanged||update.selectionSet)&&(this.decorations=this.getDeco(update.view))}getDeco(view){let lastLineStart=-1,deco=[];for(let r of view.state.selection.ranges){if(!r.empty)return Decoration.none;let line=view.lineBlockAt(r.head);line.from>lastLineStart&&(deco.push(lineDeco.range(line.from)),lastLineStart=line.from)}return Decoration.set(deco)}},{decorations:v=>v.decorations});/// Returns an extension that makes sure the content has a bottom
/// margin equivalent to the height of the editor, minus one line
/// height, so that every line in the document can be scrolled to the
/// top of the editor.
///
/// This is only meaningful when the editor is scrollable, and should
/// not be enabled in editors that take the size of their content.
class Placeholder extends WidgetType{constructor(content){super(),this.content=content}toDOM(){let wrap=document.createElement("span");return wrap.className="cm-placeholder",wrap.style.pointerEvents="none",wrap.appendChild("string"==typeof this.content?document.createTextNode(this.content):this.content),"string"==typeof this.content?wrap.setAttribute("aria-label","placeholder "+this.content):wrap.setAttribute("aria-hidden","true"),wrap}ignoreEvent(){return!1}}/// Extension that enables a placeholder—a piece of example content
/// to show when the editor is empty.
/// @internal
const __test={HeightMap,HeightOracle,MeasuredHeights,QueryType,ChangedRange,computeOrder,moveVisually};return Object.defineProperty(exports,"Range",{enumerable:!0,get:function(){return rangeset.Range}}),exports.BidiSpan=BidiSpan,exports.BlockInfo=BlockInfo,exports.Decoration=Decoration,exports.EditorView=EditorView,exports.MatchDecorator=MatchDecorator,exports.PluginField=PluginField,exports.PluginFieldProvider=PluginFieldProvider,exports.ViewPlugin=ViewPlugin,exports.ViewUpdate=ViewUpdate,exports.WidgetType=WidgetType,exports.__test=__test,exports.drawSelection=/// Returns an extension that hides the browser's native selection and
/// cursor, replacing the selection with a background behind the text
/// (with the `cm-selectionBackground` class), and the
/// cursors with elements overlaid over the code (using
/// `cm-cursor-primary` and `cm-cursor-secondary`).
///
/// This allows the editor to display secondary selection ranges, and
/// tends to produce a type of selection more in line with that users
/// expect in a text editor (the native selection styling will often
/// leave gaps between lines and won't fill the horizontal space after
/// a line when the selection continues past it).
///
/// It does have a performance cost, in that it requires an extra DOM
/// layout cycle for many updates (the selection is drawn based on DOM
/// layout information that's only available after laying out the
/// content).
function(config={}){return[selectionConfig.of(config),drawSelectionPlugin,hideNativeSelection]},exports.dropCursor=/// Draws a cursor at the current drop position when something is
/// dragged over the editor.
function(){return[dropCursorPos,drawDropCursor]},exports.highlightActiveLine=/// Mark lines that have a cursor on them with the `"cm-activeLine"`
/// DOM class.
function(){return activeLineHighlighter},exports.highlightSpecialChars=function(/// Configuration options.
config={}){return[specialCharConfig.of(config),specialCharPlugin()]},exports.keymap=keymap,exports.logException=logException,exports.placeholder=function(content){return ViewPlugin.fromClass(class{constructor(view){this.view=view,this.placeholder=Decoration.set([Decoration.widget({widget:new Placeholder(content),side:1}).range(0)])}get decorations(){return this.view.state.doc.length?Decoration.none:this.placeholder}},{decorations:v=>v.decorations})},exports.runScopeHandlers=function(view,event,scope){return runHandlers(getKeymap(view.state),event,view,scope)},exports.scrollPastEnd=function(){return[plugin,contentAttributes.of(view=>{var _a;return(null===(_a=view.plugin(plugin))||void 0===_a?void 0:_a.attrs)||null})]},exports}