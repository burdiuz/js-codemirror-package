async function moduleInitFunction(require,exports={}){function changeEnd(changes){let end=0;return changes.iterChangedRanges((_,to)=>end=to),end}function cmd(side,selection){return function({state,dispatch}){if(!selection&&state.readOnly)return!1;let historyState=state.field(historyField_,!1);if(!historyState)return!1;let tr=historyState.pop(side,state,selection);return!!tr&&(dispatch(tr),!0)}}/// Undo a single group of history events. Returns false if no group
/// was available.
function depth(side){return function(state){let histState=state.field(historyField_,!1);if(!histState)return 0;let branch=0==side/* Done */?histState.done:histState.undone;return branch.length-(branch.length&&!branch[0].changes?1:0)}}/// The amount of undoable change events available in a given state.
function updateBranch(branch,to,maxLen,newEvent){let start=to+1>maxLen+20?to-maxLen-1:0,newBranch=branch.slice(start,to);return newBranch.push(newEvent),newBranch}function isAdjacent(a,b){let ranges=[],isAdjacent=!1;return a.iterChangedRanges((f,t)=>ranges.push(f,t)),b.iterChangedRanges((_f,_t,f,t)=>{for(let i=0;i<ranges.length;){let from=ranges[i++],to=ranges[i++];t>=from&&f<=to&&(isAdjacent=!0)}}),isAdjacent}function eqSelectionShape(a,b){return a.ranges.length==b.ranges.length&&0===a.ranges.filter((r,i)=>r.empty!=b.ranges[i].empty).length}function conc(a,b){return a.length?b.length?a.concat(b):a:b}function addSelection(branch,selection){if(!branch.length)return[HistEvent.selection([selection])];else{let lastEvent=branch[branch.length-1],sels=lastEvent.selectionsAfter.slice(Math.max(0,lastEvent.selectionsAfter.length-MaxSelectionsPerEvent));return sels.length&&sels[sels.length-1].eq(selection)?branch:(sels.push(selection),updateBranch(branch,branch.length-1,1e9,lastEvent.setSelAfter(sels)))}}// Assumes the top item has one or more selectionAfter values
function popSelection(branch){let last=branch[branch.length-1],newBranch=branch.slice();return newBranch[branch.length-1]=last.setSelAfter(last.selectionsAfter.slice(0,last.selectionsAfter.length-1)),newBranch}// Add a mapping to the top event in the given branch. If this maps
// away all the changes and effects in that item, drop it and
// propagate the mapping to the next item.
function addMappingToBranch(branch,mapping){if(!branch.length)return branch;let length=branch.length,selections=none;for(;length;){let event=mapEvent(branch[length-1],mapping,selections);if(event.changes&&!event.changes.empty||event.effects.length){// Event survived mapping
let result=branch.slice(0,length);return result[length-1]=event,result}mapping=event.mapped,length--,selections=event.selectionsAfter}return selections.length?[HistEvent.selection(selections)]:none}function mapEvent(event,mapping,extraSelections){let selections=conc(event.selectionsAfter.length?event.selectionsAfter.map(s=>s.map(mapping)):none,extraSelections);// Change-less events don't store mappings (they are always the last event in a branch)
if(!event.changes)return HistEvent.selection(selections);let mappedChanges=event.changes.map(mapping),before=mapping.mapDesc(event.changes,!0),fullMapping=event.mapped?event.mapped.composeDesc(before):before;return new HistEvent(mappedChanges,state.StateEffect.mapEffects(event.effects,mapping),fullMapping,event.startSelection.map(before),selections)}Object.defineProperty(exports,"__esModule",{value:!0});var state=await require("@codemirror/state"),view=await require("@codemirror/view");const fromHistory=state.Annotation.define(),isolateHistory=state.Annotation.define(),invertedEffects=state.Facet.define(),historyConfig=state.Facet.define({combine(configs){return state.combineConfig(configs,{minDepth:100,newGroupDelay:500},{minDepth:Math.max,newGroupDelay:Math.min})}}),historyField_=state.StateField.define({create(){return HistoryState.empty},update(state$1,tr){let config=tr.state.facet(historyConfig),fromHist=tr.annotation(fromHistory);if(fromHist){let selection=tr.docChanged?state.EditorSelection.single(changeEnd(tr.changes)):void 0,item=HistEvent.fromTransaction(tr,selection),from=fromHist.side,other=0==from/* Done */?state$1.undone:state$1.done;return other=item?updateBranch(other,other.length,config.minDepth,item):addSelection(other,tr.startState.selection),new HistoryState(0==from/* Done */?fromHist.rest:other,0==from/* Done */?other:fromHist.rest)}let isolate=tr.annotation(isolateHistory);if(("full"==isolate||"before"==isolate)&&(state$1=state$1.isolate()),!1===tr.annotation(state.Transaction.addToHistory))return tr.changes.empty?state$1:state$1.addMapping(tr.changes.desc);let event=HistEvent.fromTransaction(tr),time=tr.annotation(state.Transaction.time),userEvent=tr.annotation(state.Transaction.userEvent);return event?state$1=state$1.addChanges(event,time,userEvent,config.newGroupDelay,config.minDepth):tr.selection&&(state$1=state$1.addSelection(tr.startState.selection,time,userEvent,config.newGroupDelay)),("full"==isolate||"after"==isolate)&&(state$1=state$1.isolate()),state$1},toJSON(value){return{done:value.done.map(e=>e.toJSON()),undone:value.undone.map(e=>e.toJSON())}},fromJSON(json){return new HistoryState(json.done.map(HistEvent.fromJSON),json.undone.map(HistEvent.fromJSON))}}),undo=cmd(0/* Done */,!1),redo=cmd(1/* Undone */,!1),undoSelection=cmd(0/* Done */,!0),redoSelection=cmd(1/* Undone */,!0),undoDepth=depth(0/* Done */),redoDepth=depth(1/* Undone */);/// Transaction annotation that will prevent that transaction from
/// being combined with other transactions in the undo history. Given
/// `"before"`, it'll prevent merging with previous transactions. With
/// `"after"`, subsequent transactions won't be combined with this
/// one. With `"full"`, the transaction is isolated on both sides.
// History events store groups of changes or effects that need to be
// undone/redone together.
class HistEvent{constructor(// The changes in this event. Normal events hold at least one
// change or effect. But it may be necessary to store selection
// events before the first change, in which case a special type of
// instance is created which doesn't hold any changes, with
// changes == startSelection == undefined
changes,// The effects associated with this event
effects,mapped,// The selection before this event
startSelection,// Stores selection changes after this event, to be used for
// selection undo/redo.
selectionsAfter){this.changes=changes,this.effects=effects,this.mapped=mapped,this.startSelection=startSelection,this.selectionsAfter=selectionsAfter}setSelAfter(after){return new HistEvent(this.changes,this.effects,this.mapped,this.startSelection,after)}toJSON(){var _a,_b,_c;return{changes:null===(_a=this.changes)||void 0===_a?void 0:_a.toJSON(),mapped:null===(_b=this.mapped)||void 0===_b?void 0:_b.toJSON(),startSelection:null===(_c=this.startSelection)||void 0===_c?void 0:_c.toJSON(),selectionsAfter:this.selectionsAfter.map(s=>s.toJSON())}}static fromJSON(json){return new HistEvent(json.changes&&state.ChangeSet.fromJSON(json.changes),[],json.mapped&&state.ChangeDesc.fromJSON(json.mapped),json.startSelection&&state.EditorSelection.fromJSON(json.startSelection),json.selectionsAfter.map(state.EditorSelection.fromJSON))}// This does not check `addToHistory` and such, it assumes the
// transaction needs to be converted to an item. Returns null when
// there are no changes or effects in the transaction.
static fromTransaction(tr,selection){let effects=none;for(let invert of tr.startState.facet(invertedEffects)){let result=invert(tr);result.length&&(effects=effects.concat(result))}return!effects.length&&tr.changes.empty?null:new HistEvent(tr.changes.invert(tr.startState.doc),effects,void 0,selection||tr.startState.selection,none)}static selection(selections){return new HistEvent(void 0,none,void 0,void 0,selections)}}const none=[],MaxSelectionsPerEvent=200;class HistoryState{constructor(done,undone,prevTime=0,prevUserEvent=void 0){this.done=done,this.undone=undone,this.prevTime=prevTime,this.prevUserEvent=prevUserEvent}isolate(){return this.prevTime?new HistoryState(this.done,this.undone):this}addChanges(event,time,userEvent,newGroupDelay,maxLen){let done=this.done,lastEvent=done[done.length-1];return done=lastEvent&&lastEvent.changes&&!lastEvent.changes.empty&&event.changes&&(!userEvent||/^(input\.type|delete)($|\.)/.test(userEvent))&&(!lastEvent.selectionsAfter.length&&time-this.prevTime<newGroupDelay&&isAdjacent(lastEvent.changes,event.changes)||// For compose (but not compose.start) events, always join with previous event
"input.type.compose"==userEvent)?updateBranch(done,done.length-1,maxLen,new HistEvent(event.changes.compose(lastEvent.changes),conc(event.effects,lastEvent.effects),lastEvent.mapped,lastEvent.startSelection,none)):updateBranch(done,done.length,maxLen,event),new HistoryState(done,none,time,userEvent)}addSelection(selection,time,userEvent,newGroupDelay){let last=this.done.length?this.done[this.done.length-1].selectionsAfter:none;return 0<last.length&&time-this.prevTime<newGroupDelay&&userEvent==this.prevUserEvent&&userEvent&&/^select($|\.)/.test(userEvent)&&eqSelectionShape(last[last.length-1],selection)?this:new HistoryState(addSelection(this.done,selection),this.undone,time,userEvent)}addMapping(mapping){return new HistoryState(addMappingToBranch(this.done,mapping),addMappingToBranch(this.undone,mapping),this.prevTime,this.prevUserEvent)}pop(side,state,selection){let branch=0==side/* Done */?this.done:this.undone;if(0==branch.length)return null;let event=branch[branch.length-1];if(selection&&event.selectionsAfter.length)return state.update({selection:event.selectionsAfter[event.selectionsAfter.length-1],annotations:fromHistory.of({side,rest:popSelection(branch)}),userEvent:0==side/* Done */?"select.undo":"select.redo",scrollIntoView:!0});if(!event.changes)return null;else{let rest=1==branch.length?none:branch.slice(0,branch.length-1);return event.mapped&&(rest=addMappingToBranch(rest,event.mapped)),state.update({changes:event.changes,selection:event.startSelection,effects:event.effects,annotations:fromHistory.of({side,rest}),filter:!1,userEvent:0==side/* Done */?"undo":"redo",scrollIntoView:!0})}}}HistoryState.empty=new HistoryState(none,none);return exports.history=/// Create a history extension with the given configuration.
function(config={}){return[historyField_,historyConfig.of(config),view.EditorView.domEventHandlers({beforeinput(e,view){let command="historyUndo"==e.inputType?undo:"historyRedo"==e.inputType?redo:null;return!!command&&(e.preventDefault(),command(view))}})]}/// The state field used to store the history data. Should probably
/// only be used when you want to
/// [serialize](#state.EditorState.toJSON) or
/// [deserialize](#state.EditorState^fromJSON) state objects in a way
/// that preserves history.
,exports.historyField=historyField_,exports.historyKeymap=[{key:"Mod-z",run:undo,preventDefault:!0},{key:"Mod-y",mac:"Mod-Shift-z",run:redo,preventDefault:!0},{key:"Mod-u",run:undoSelection,preventDefault:!0},{key:"Alt-u",mac:"Mod-Shift-u",run:redoSelection,preventDefault:!0}],exports.invertedEffects=invertedEffects,exports.isolateHistory=isolateHistory,exports.redo=redo,exports.redoDepth=redoDepth,exports.redoSelection=redoSelection,exports.undo=undo,exports.undoDepth=undoDepth,exports.undoSelection=undoSelection,exports}