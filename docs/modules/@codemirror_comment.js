async function moduleInitFunction(require,exports={}){function command(f,option){return({state,dispatch})=>{if(state.readOnly)return!1;let tr=f(option,state.selection.ranges,state);return!!tr&&(dispatch(state.update(tr)),!0)}}/// Comment or uncomment the current selection using line comments.
/// The line comment syntax is taken from the
/// [`commentTokens`](#comment.CommentTokens) [language
/// data](#state.EditorState.languageDataAt).
function getConfig(state,pos=state.selection.main.head){let data=state.languageDataAt("commentTokens",pos);return data.length?data[0]:{}}/// Determines if the given range is block-commented in the given
/// state.
function findBlockComment(state,{open,close},from,to){let textBefore=state.sliceDoc(from-SearchMargin,from),textAfter=state.sliceDoc(to,to+SearchMargin),spaceBefore=/\s*$/.exec(textBefore)[0].length,spaceAfter=/^\s*/.exec(textAfter)[0].length,beforeOff=textBefore.length-spaceBefore;if(textBefore.slice(beforeOff-open.length,beforeOff)==open&&textAfter.slice(spaceAfter,spaceAfter+close.length)==close)return{open:{pos:from-spaceBefore,margin:spaceBefore&&1},close:{pos:to+spaceAfter,margin:spaceAfter&&1}};let startText,endText;100>=to-from?startText=endText=state.sliceDoc(from,to):(startText=state.sliceDoc(from,from+SearchMargin),endText=state.sliceDoc(to-SearchMargin,to));let startSpace=/^\s*/.exec(startText)[0].length,endSpace=/\s*$/.exec(endText)[0].length,endOff=endText.length-endSpace-close.length;return startText.slice(startSpace,startSpace+open.length)==open&&endText.slice(endOff,endOff+close.length)==close?{open:{pos:from+startSpace+open.length,margin:/\s/.test(startText.charAt(startSpace+open.length))?1:0},close:{pos:to-endSpace-close.length,margin:/\s/.test(endText.charAt(endOff-1))?1:0}}:null}// Performs toggle, comment and uncomment of block comments in
// languages that support them.
function changeBlockComment(option,ranges,state$1){let tokens=ranges.map(r=>getConfig(state$1,r.from).block);if(!tokens.every(c=>c))return null;let comments=ranges.map((r,i)=>findBlockComment(state$1,tokens[i],r.from,r.to));if(2!=option/* Uncomment */&&!comments.every(c=>c)){let index=0;return state$1.changeByRange(range=>{let{open,close}=tokens[index++];if(comments[index])return{range};let shift=open.length+1;return{changes:[{from:range.from,insert:open+" "},{from:range.to,insert:" "+close}],range:state.EditorSelection.range(range.anchor+shift,range.head+shift)}})}if(1!=option/* Comment */&&comments.some(c=>c)){let changes=[];for(let comment,i=0;i<comments.length;i++)if(comment=comments[i]){let token=tokens[i],{open,close}=comment;changes.push({from:open.pos-token.open.length,to:open.pos+open.margin},{from:close.pos-close.margin,to:close.pos+token.close.length})}return{changes}}return null}// Performs toggle, comment and uncomment of line comments.
function changeLineComment(option,ranges,state){let lines=[],prevLine=-1;for(let{from,to}of ranges){let startI=lines.length,minIndent=1e9;for(let line,pos=from;pos<=to;){if(line=state.doc.lineAt(pos),line.from>prevLine&&(from==to||to>line.from)){prevLine=line.from;let token=getConfig(state,pos).line;if(!token)continue;let indent=/^\s*/.exec(line.text)[0].length,empty=indent==line.length,comment=line.text.slice(indent,indent+token.length)==token?indent:-1;indent<line.text.length&&indent<minIndent&&(minIndent=indent),lines.push({line,comment,token,indent,empty,single:!1})}pos=line.to+1}if(1e9>minIndent)for(let i=startI;i<lines.length;i++)lines[i].indent<lines[i].line.text.length&&(lines[i].indent=minIndent);lines.length==startI+1&&(lines[startI].single=!0)}if(2!=option/* Uncomment */&&lines.some(l=>0>l.comment&&(!l.empty||l.single))){let changes=[];for(let{line,token,indent,empty,single}of lines)(single||!empty)&&changes.push({from:line.from+indent,insert:token+" "});let changeSet=state.changes(changes);return{changes:changeSet,selection:state.selection.map(changeSet,1)}}if(1!=option/* Comment */&&lines.some(l=>0<=l.comment)){let changes=[];for(let{line,comment,token}of lines)if(0<=comment){let from=line.from+comment,to=from+token.length;" "==line.text[to-line.from]&&to++,changes.push({from,to})}return{changes}}return null}Object.defineProperty(exports,"__esModule",{value:!0});var state=await require("@codemirror/state");/// Comment or uncomment the current selection. Will use line comments
/// if available, otherwise falling back to block comments.
const toggleComment=target=>{let config=getConfig(target.state);return config.line?toggleLineComment(target):!!config.block&&toggleBlockComment(target)},toggleLineComment=command(changeLineComment,0/* Toggle */),lineComment=command(changeLineComment,1/* Comment */),lineUncomment=command(changeLineComment,2/* Uncomment */),toggleBlockComment=command(changeBlockComment,0/* Toggle */),blockComment=command(changeBlockComment,1/* Comment */),blockUncomment=command(changeBlockComment,2/* Uncomment */),SearchMargin=50;return exports.blockComment=blockComment,exports.blockUncomment=blockUncomment,exports.commentKeymap=[{key:"Mod-/",run:toggleComment},{key:"Alt-A",run:toggleBlockComment}],exports.lineComment=lineComment,exports.lineUncomment=lineUncomment,exports.toggleBlockComment=toggleBlockComment,exports.toggleComment=toggleComment,exports.toggleLineComment=toggleLineComment,exports}