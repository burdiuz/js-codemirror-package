async function moduleInitFunction(require,exports={}){function tagName(doc,tag){let name=tag&&tag.getChild("TagName");return name?doc.sliceString(name.from,name.to):""}function elementName(doc,tree){let tag=tree&&tree.firstChild;return tag&&"OpenTag"==tag.name?tagName(doc,tag):""}function attrName(doc,tag,pos){let attr=tag&&tag.getChildren("Attribute").find(a=>a.from<=pos&&a.to>=pos),name=attr&&attr.getChild("AttributeName");return name?doc.sliceString(name.from,name.to):""}function findParentElement(tree){for(let cur=tree&&tree.parent;cur;cur=cur.parent)if("Element"==cur.name)return cur;return null}function findLocation(state,pos){var _a;let at=language.syntaxTree(state).resolveInner(pos,-1),inTag=null;for(let cur=at;!inTag&&cur.parent;cur=cur.parent)("OpenTag"==cur.name||"CloseTag"==cur.name||"SelfClosingTag"==cur.name||"MismatchedCloseTag"==cur.name)&&(inTag=cur);if(inTag&&(inTag.to>pos||inTag.lastChild.type.isError)){let elt=inTag.parent;if("TagName"==at.name)return"CloseTag"==inTag.name||"MismatchedCloseTag"==inTag.name?{type:"closeTag",from:at.from,context:elt}:{type:"openTag",from:at.from,context:findParentElement(elt)};if("AttributeName"==at.name)return{type:"attrName",from:at.from,context:inTag};if("AttributeValue"==at.name)return{type:"attrValue",from:at.from,context:inTag};let before=at==inTag||"Attribute"==at.name?at.childBefore(pos):at;return"StartTag"==(null===before||void 0===before?void 0:before.name)?{type:"openTag",from:pos,context:findParentElement(elt)}:"StartCloseTag"==(null===before||void 0===before?void 0:before.name)&&before.to<=pos?{type:"closeTag",from:pos,context:elt}:"Is"==(null===before||void 0===before?void 0:before.name)?{type:"attrValue",from:pos,context:inTag}:before?{type:"attrName",from:pos,context:inTag}:null}if("StartCloseTag"==at.name)return{type:"closeTag",from:pos,context:at.parent};for(;at.parent&&at.to==pos&&(null===(_a=at.lastChild)||void 0===_a||!_a.type.isError);)at=at.parent;return"Element"==at.name||"Text"==at.name||"Document"==at.name?{type:"tag",from:pos,context:"Element"==at.name?at:findParentElement(at)}:null}function attrCompletion(spec){return Object.assign(Object.assign({type:"property"},spec.completion||{}),{label:spec.name})}function valueCompletion(spec){return"string"==typeof spec?{label:`"${spec}"`,type:"constant"}:/^"/.test(spec.label)?spec:Object.assign(Object.assign({},spec),{label:`"${spec.label}"`})}function completeFromSchema(eltSpecs,attrSpecs){let allAttrs=[],globalAttrs=[],attrValues=Object.create(null);for(let s of attrSpecs){let completion=attrCompletion(s);allAttrs.push(completion),s.global&&globalAttrs.push(completion),s.values&&(attrValues[s.name]=s.values.map(valueCompletion))}let allElements=[],topElements=[],byName=Object.create(null);for(let s of eltSpecs){let attrs=globalAttrs,attrVals=attrValues;s.attributes&&(attrs=attrs.concat(s.attributes.map(s=>"string"==typeof s?allAttrs.find(a=>a.label==s)||{label:s,type:"property"}:(s.values&&(attrVals==attrValues&&(attrVals=Object.create(attrVals)),attrVals[s.name]=s.values.map(valueCompletion)),attrCompletion(s)))));let elt=new Element(s,attrs,attrVals);byName[elt.name]=elt,allElements.push(elt),s.top&&topElements.push(elt)}topElements.length||(topElements=allElements);for(let i=0;i<allElements.length;i++){let s=eltSpecs[i],elt=allElements[i];if(s.children)for(let ch of s.children)byName[ch]&&elt.children.push(byName[ch]);else elt.children=allElements}return cx=>{var _a;let{doc}=cx.state,loc=findLocation(cx.state,cx.pos);if(!loc||"tag"==loc.type&&!cx.explicit)return null;let{type,from,context}=loc;if("openTag"==type){let children=topElements,parentName=elementName(doc,context);if(parentName){let parent=byName[parentName];children=(null===parent||void 0===parent?void 0:parent.children)||allElements}return{from,options:children.map(ch=>ch.completion),span:Identifier}}if("closeTag"==type){let parentName=elementName(doc,context);return parentName?{from,to:cx.pos+(">"==doc.sliceString(cx.pos,cx.pos+1)?1:0),options:[(null===(_a=byName[parentName])||void 0===_a?void 0:_a.closeNameCompletion)||{label:parentName+">",type:"type"}],span:Identifier}:null}if("attrName"==type){let parent=byName[tagName(doc,context)];return{from,options:(null===parent||void 0===parent?void 0:parent.attrs)||globalAttrs,span:Identifier}}if("attrValue"==type){let attr=attrName(doc,context,from);if(!attr)return null;let parent=byName[tagName(doc,context)],values=((null===parent||void 0===parent?void 0:parent.attrValues)||attrValues)[attr];return values&&values.length?{from,to:cx.pos+("\""==doc.sliceString(cx.pos,cx.pos+1)?1:0),options:values,span:/^"[^"]*"?$/}:null}if("tag"==type){let parentName=elementName(doc,context),parent=byName[parentName],closing=[],last=context&&context.lastChild;parentName&&(!last||"CloseTag"!=last.name||tagName(doc,last)!=parentName)&&closing.push(parent?parent.closeCompletion:{label:"</"+parentName+">",type:"type",boost:2});let options=closing.concat(((null===parent||void 0===parent?void 0:parent.children)||(context?allElements:topElements)).map(e=>e.openCompletion));if(context&&(null===parent||void 0===parent?void 0:parent.text.length)){let openTag=context.firstChild;openTag.to>cx.pos-20&&!/\S/.test(cx.state.sliceDoc(openTag.to,cx.pos))&&(options=options.concat(parent.text))}return{from,options,span:/^<\/?[:\-\.\w\u00b7-\uffff]*$/}}return null}}/// A language provider based on the [Lezer XML
/// parser](https://github.com/lezer-parser/xml), extended with
/// highlighting and indentation information.
Object.defineProperty(exports,"__esModule",{value:!0});var xml$1=await require("@lezer/xml"),language=await require("@codemirror/language"),highlight=await require("@codemirror/highlight");class Element{constructor(spec,attrs,attrValues){this.attrs=attrs,this.attrValues=attrValues,this.children=[],this.name=spec.name,this.completion=Object.assign(Object.assign({type:"type"},spec.completion||{}),{label:this.name}),this.openCompletion=Object.assign(Object.assign({},this.completion),{label:"<"+this.name}),this.closeCompletion=Object.assign(Object.assign({},this.completion),{label:"</"+this.name+">",boost:2}),this.closeNameCompletion=Object.assign(Object.assign({},this.completion),{label:this.name+">"}),this.text=spec.textContent?spec.textContent.map(s=>({label:s,type:"text"})):[]}}const Identifier=/^[:\-\.\w\u00b7-\uffff]*$/,xmlLanguage=language.LRLanguage.define({parser:xml$1.parser.configure({props:[language.indentNodeProp.add({Element(context){let closed=/^\s*<\//.test(context.textAfter);return context.lineIndent(context.node.from)+(closed?0:context.unit)},"OpenTag CloseTag SelfClosingTag"(context){return context.column(context.node.from)+context.unit}}),language.foldNodeProp.add({Element(subtree){let first=subtree.firstChild,last=subtree.lastChild;return first&&"OpenTag"==first.name?{from:first.to,to:"CloseTag"==last.name?last.from:subtree.to}:null}}),highlight.styleTags({Text:highlight.tags.content,"StartTag StartCloseTag EndTag SelfCloseEndTag":highlight.tags.angleBracket,TagName:highlight.tags.tagName,"MismatchedCloseTag/Tagname":[highlight.tags.tagName,highlight.tags.invalid],AttributeName:highlight.tags.attributeName,AttributeValue:highlight.tags.attributeValue,Is:highlight.tags.definitionOperator,"EntityReference CharacterReference":highlight.tags.character,Comment:highlight.tags.blockComment,ProcessingInst:highlight.tags.processingInstruction,DoctypeDecl:highlight.tags.documentMeta,Cdata:highlight.tags.special(highlight.tags.string)})]}),languageData:{commentTokens:{block:{open:"<!--",close:"-->"}},indentOnInput:/^\s*<\/$/}});return exports.completeFromSchema=completeFromSchema,exports.xml=/// XML language support. Includes schema-based autocompletion when
/// configured.
function(conf={}){return new language.LanguageSupport(xmlLanguage,xmlLanguage.data.of({autocomplete:completeFromSchema(conf.elements||[],conf.attributes||[])}))},exports.xmlLanguage=xmlLanguage,exports}